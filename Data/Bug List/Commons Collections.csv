Summary,Issue key,Issue id,Issue Type,Status,Project key,Project name,Project type,Project lead,Project description,Project url,Priority,Resolution,Assignee,Reporter,Creator,Created,Updated,Last Viewed,Resolved,Affects Version/s,Affects Version/s,Affects Version/s,Affects Version/s,Affects Version/s,Fix Version/s,Fix Version/s,Fix Version/s,Component/s,Component/s,Component/s,Component/s,Component/s,Due Date,Votes,Labels,Labels,Labels,Description,Environment,Log Work,Log Work,Log Work,Original Estimate,Remaining Estimate,Time Spent,Work Ratio,Σ Original Estimate,Σ Remaining Estimate,Σ Time Spent,Security Level,Outward issue link (Cloners),Outward issue link (Duplicate),Outward issue link (Incorporates),Outward issue link (Reference),Outward issue link (Reference),Outward issue link (dependent),Attachment,Attachment,Attachment,Attachment,Attachment,Attachment,Attachment,Attachment,Attachment,Custom field (Attachment count),Custom field (Blog - New Blog Administrators),Custom field (Blog - New Blog PMC),Custom field (Blog - Write access),Custom field (Blog Administrator?),Custom field (Blogs - Admin for blog),Custom field (Blogs - Email Address),Custom field (Blogs - Existing Blog Access Level),Custom field (Blogs - Existing Blog Name),Custom field (Blogs - New Blog Write Access),Custom field (Blogs - Username),Custom field (Bug Category),Custom field (Bugzilla - Email Notification Address),Custom field (Bugzilla - List of usernames),Custom field (Bugzilla - PMC Name),Custom field (Bugzilla - Project Name),Custom field (Bugzilla Id),Custom field (Change Category),Custom field (Complexity),Custom field (Date of First Response),Custom field (Discovered By),Custom field (Docs Text),Custom field (Enable Automatic Patch Review),Custom field (Epic Link),Custom field (Existing GitBox Approval),Custom field (External issue ID),Custom field (External issue URL),Custom field (Flags),Custom field (Flags),Custom field (Git Notification Mailing List),Custom field (Git Repository Import Path),Custom field (Git Repository Name),Custom field (Git Repository Type),Custom field (GitHub Options),Custom field (Github Integration),Custom field (Github Integrations - Other),Custom field (Global Rank),Custom field (INFRA - Subversion Repository Path),Custom field (Initial Confluence Contributors),Custom field (Last public comment date),Custom field (Machine Readable Info),Custom field (New-TLP-TLPName),Custom field (Priority),Custom field (Project),Custom field (Protected Branch),Custom field (Rank),Custom field (Rank (Obsolete)),Custom field (Severity),Custom field (Severity),Custom field (Space Description),Custom field (Space Key),Custom field (Space Name),Custom field (Test and Documentation Plan),Custom field (Testcase included),Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment
ExtendedProperties.save swallows instead of throws IOException,COLLECTIONS-712,13222320,Bug,Open,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Trivial,,,ph26,ph26,18/Mar/19 13:39,18/Mar/19 14:48,07/Apr/19 20:37,,3.2.2,,,,,,,,Properties,,,,,,0,,,,"commons-collections-3.2.2-src/src/java/org/apache/commons/collections/ExtendedProperties.java

/**
  * Save the properties to the given output stream.
  * ...
  * @throws IOException if an IO error occurs - no it does not.
  */
public synchronized void save(OutputStream output, String header) throws IOException {
...
PrintWriter theWrtr = new PrintWriter(output);
 ...
 // theWrter.flush();
 // missing: if (theWrtr.checkError()) throw new IOException();

Impact: caller cannot tell if the properties were completely saved, perhaps the disk filled up instead. Missing checkError is an antipattern for PrintWriter and PrintStream.",,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,9223372036854775807,,,2019-03-18 13:39:28.0,,,,,,0|z00tgo:,9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"NullPointerExceptions in CompositeCollection, CompositeSet, and CompositeMap",COLLECTIONS-710,13212660,Bug,Resolved,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,sychelsea,sychelsea,29/Jan/19 22:00,09/Feb/19 23:01,07/Apr/19 20:37,09/Feb/19 23:01,4.2,,,,,4.3.1,,,Collection,Map,Set,,,,0,nullpointerexception,,,"If we first add a null element into CompositeCollection by CompositeCollection.addComposited(nullElement), projects will crash and throw java.lang.NullPointerException when we call CompositeCollection.size().

For example, we have following code:

ArrayList<String> nullList = null;
CompositeCollection<String> cc = new CompositeCollection<String>(list);
cc.addComposited(nullList);
System.out.println(cc.size());

 

We will get:

{{Exception in thread ""main"" java.lang.NullPointerException}}
at org.apache.commons.collections4.collection.CompositeCollection.size(CompositeCollection.java:103)

 

Because in CompositeCollection.size(), it iterate all items in the Collection, call item.size() and sum up their size. If the item point to null, the program will crash.

 

This bug also exists in other methods of CompositeCollection. Moreover, CompositeSet and CompositeMap have the same bug.","Windows 10

Eclipse IDE for Java Developers     Version: 2018-09 (4.9.0)",,,,3600,3600,,0%,3600,3600,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2019-02-09 23:01:58.617,,,false,,,,,,,,,,,,,,9223372036854775807,,,Sat Feb 09 23:01:58 UTC 2019,,,,,,0|yi0gfk:,9223372036854775807,,,,,,,,"09/Feb/19 23:01;garydgregory;[~sychelsea],

Thank you for your report.

Fixes are in git master. Please verify and close. If there are still problems, please provide a PR on GitHub.

Gary",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
MultiSet.Entry::getCount() isn't 0 after removing the last element,COLLECTIONS-709,13210557,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Minor,Fixed,,CasualSuperman,CasualSuperman,19/Jan/19 23:30,20/Jan/19 17:41,07/Apr/19 20:37,20/Jan/19 15:06,4.1,4.2,,,,4.3,,,,,,,,,0,,,,"Removing the final element(s) in a MultiSet doesn't set the count on a MultiSet.Entry to zero.
{code:java}
protected int getCountAfterRemoval(MultiSet<String> multiset) {
  MultiSet.Entry<String> entry = multiset.entrySet().iterator().next();
  entry.getCount(); // = 2
  multiset.remove(entry.getElement());
  entry.getCount(); // = 1
  multiset.remove(entry.getElement());
  return entry.getCount(); // Still = 1, should be 0
}
{code}",,"CasualSuperman commented on pull request #66: COLLECTIONS-709 Set Entry count to 0 after remove
URL: https://github.com/apache/commons-collections/pull/66
 
 
   After removing the last element of a MultiSet, the Entry doesn't have a count of 0. This makes the count accurate after removing the last item of a MultiSet.
 
----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;19/Jan/19 23:34;githubbot;600","grimreaper commented on issue #66: COLLECTIONS-709 Set Entry count to 0 after remove
URL: https://github.com/apache/commons-collections/pull/66#issuecomment-455824429
 
 
   This seems reasonable to me.
 
----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;19/Jan/19 23:40;githubbot;600","CasualSuperman commented on pull request #66: COLLECTIONS-709 Set Entry count to 0 after remove
URL: https://github.com/apache/commons-collections/pull/66
 
 
   
 
----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;20/Jan/19 15:15;githubbot;600",,0,1800,,,0,1800,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2019-01-20 15:06:17.674,,,false,,,,,,,,,,,,,,9223372036854775807,,,Sun Jan 20 17:41:14 UTC 2019,,,,,,0|yi03i8:,9223372036854775807,,,,,,,,19/Jan/19 23:35;CasualSuperman;Pull request created with a fix: https://github.com/apache/commons-collections/pull/66,20/Jan/19 15:06;garydgregory;In git master now. Please verify and close this ticket and the PR.,20/Jan/19 17:41;CasualSuperman;Just realized the commit message says COMMONS-706 instead of COMMONS-709. Not sure how important that is to fix.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
StackOverflowError in SetUniqueList.add() when it receives itself,COLLECTIONS-701,13195362,Bug,Resolved,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Critical,Fixed,,shong03,shong03,31/Oct/18 12:38,23/Nov/18 07:32,07/Apr/19 20:37,23/Nov/18 07:32,3.2.2,,,,,4.3,,,Collection,,,,,,0,,,,"Hi.

We found that the following test case fails with a StackOverFlowError exception:
{code:java}
test() {        
   SetUniqueList l = new SetUniqueList(new LinkedList<Object>()) ;        
   l.add((Object) l) ;    
}{code}
The add() execution traps into an infinite recursion which crashes the program.

From the stack trace, we found that the infinite recursion occurs

at AbstractList.hashCode() since it invokes hashCode() of each of its elements.

 ",,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2018-10-31 15:07:39.869,,,false,,,,,Important,,,,,,,,,9223372036854775807,,,Fri Nov 23 07:32:49 UTC 2018,,,,,,0|i3zucv:,9223372036854775807,,,,,,,,"31/Oct/18 15:07;garydgregory;Here is an example stack trace:
{noformat}
java.lang.StackOverflowError
 at java.util.LinkedList$ListItr.<init>(LinkedList.java:879)
 at java.util.LinkedList.listIterator(LinkedList.java:868)
 at java.util.AbstractList.listIterator(AbstractList.java:299)
 at java.util.AbstractSequentialList.iterator(AbstractSequentialList.java:239)
 at java.util.AbstractList.hashCode(AbstractList.java:540)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)
 at java.util.AbstractList.hashCode(AbstractList.java:541)
 at org.apache.commons.collections4.list.AbstractListDecorator.hashCode(AbstractListDecorator.java:74)

{noformat}","08/Nov/18 17:39;githubbot;GitHub user drajakumar opened a pull request:

    https://github.com/apache/commons-collections/pull/57

    COLLECTIONS-701 SetUniqueList.add() crashes due to infinite recursion…

    … when it receives itself

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/drajakumar/commons-collections master

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/commons-collections/pull/57.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #57
    
----
commit be0cea3c907bb4ab1083384377521942d17e15bd
Author: Don Jeba <donjeba@...>
Date:   2018-11-08T17:36:05Z

    COLLECTIONS-701 SetUniqueList.add() crashes due to infinite recursion when it receives itself

----
","08/Nov/18 17:39;githubbot;GitHub user drajakumar opened a pull request:

    https://github.com/apache/commons-collections/pull/57

    COLLECTIONS-701 SetUniqueList.add() crashes due to infinite recursion…

    … when it receives itself

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/drajakumar/commons-collections master

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/commons-collections/pull/57.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #57
    
----
commit be0cea3c907bb4ab1083384377521942d17e15bd
Author: Don Jeba <donjeba@...>
Date:   2018-11-08T17:36:05Z

    COLLECTIONS-701 SetUniqueList.add() crashes due to infinite recursion when it receives itself

----
","08/Nov/18 18:34;drajakumar;raised pr [https://github.com/apache/commons-collections/pull/57] as fix for this but CI build job is failing with error which is not related to my change. Can you kindly help on where i am going wrong, thank you!

[https://travis-ci.org/apache/commons-collections/jobs/452504978]

 ","08/Nov/18 19:04;githubbot;Github user garydgregory commented on the issue:

    https://github.com/apache/commons-collections/pull/57
  
    Hi @drajakumar ,
    
    I'm not sure this patch makes sense. Take a look at ```org.apache.commons.collections4.list.Collections701Test```: For ```ArrayList``` and ```HashSet```, adding a collection to itself is fine. 
    
    In this patch, the argument is not only silently ignored, but the behavior is not even documented. Whatever we do, we really need to document _anything_ that deviates from the standard JRE ```List``` contract.
    
    IMO, the fix should be so that a ```SetUniqueList``` behaves like a ```ArrayList``` and ```HashSet```, it just works.
","09/Nov/18 14:22;githubbot;Github user drajakumar commented on the issue:

    https://github.com/apache/commons-collections/pull/57
  
    closing the pr as the fix is not as expected
","09/Nov/18 14:22;githubbot;Github user drajakumar closed the pull request at:

    https://github.com/apache/commons-collections/pull/57
","09/Nov/18 14:22;githubbot;Github user drajakumar closed the pull request at:

    https://github.com/apache/commons-collections/pull/57
","09/Nov/18 14:58;githubbot;Github user garydgregory commented on the issue:

    https://github.com/apache/commons-collections/pull/57
  
    You did not have to close the PR, I was hoping you would provide a more complete solution ;-)
","09/Nov/18 15:27;githubbot;Github user drajakumar commented on the issue:

    https://github.com/apache/commons-collections/pull/57
  
    sure @garydgregory  i am analyzing for a fix as per the expectation, will update you.
",09/Nov/18 15:34;erans;I'm wondering why the proposed fix was deemed wrong.,"11/Nov/18 16:21;githubbot;GitHub user drajakumar reopened a pull request:

    https://github.com/apache/commons-collections/pull/57

    COLLECTIONS-701 SetUniqueList.add() crashes due to infinite recursion…

    … when it receives itself

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/drajakumar/commons-collections master

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/commons-collections/pull/57.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #57
    
----
commit be0cea3c907bb4ab1083384377521942d17e15bd
Author: Don Jeba <donjeba@...>
Date:   2018-11-08T17:36:05Z

    COLLECTIONS-701 SetUniqueList.add() crashes due to infinite recursion when it receives itself

commit ddde35c943058b55a59e88c9f5d60ed53f3e08ef
Author: Rajakumar <drajakumar@...>
Date:   2018-11-09T14:27:11Z

    Merge branch 'master' of github.com:apache/commons-collections

----
","11/Nov/18 16:21;githubbot;GitHub user drajakumar reopened a pull request:

    https://github.com/apache/commons-collections/pull/57

    COLLECTIONS-701 SetUniqueList.add() crashes due to infinite recursion…

    … when it receives itself

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/drajakumar/commons-collections master

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/commons-collections/pull/57.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #57
    
----
commit be0cea3c907bb4ab1083384377521942d17e15bd
Author: Don Jeba <donjeba@...>
Date:   2018-11-08T17:36:05Z

    COLLECTIONS-701 SetUniqueList.add() crashes due to infinite recursion when it receives itself

commit ddde35c943058b55a59e88c9f5d60ed53f3e08ef
Author: Rajakumar <drajakumar@...>
Date:   2018-11-09T14:27:11Z

    Merge branch 'master' of github.com:apache/commons-collections

----
","11/Nov/18 16:48;githubbot;Github user drajakumar commented on the issue:

    https://github.com/apache/commons-collections/pull/57
  
    @garydgregory can you kindly check the new fix, thank you!
","14/Nov/18 17:58;githubbot;Github user drajakumar commented on the issue:

    https://github.com/apache/commons-collections/pull/57
  
    @garydgregory can you kindly check the new fix, thank you!
","23/Nov/18 07:32;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/commons-collections/pull/57
","23/Nov/18 07:32;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/commons-collections/pull/57
","23/Nov/18 07:32;garydgregory;[~shong03], [~drajakumar]:

In git master. Please verify and close.

Gary",,,,,,,,,,,,,,,,,,,,,,,,,,,,,
JavaDoc for FixedSizeList should warn that modifying underlying list is still allowed and is not prevented,COLLECTIONS-697,13188930,Bug,Open,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,,,george.ranjan@gmail.com,george.ranjan@gmail.com,02/Oct/18 17:33,06/Oct/18 20:20,07/Apr/19 20:37,,,,,,,,,,,,,,,,0,,,,"I just noticed that it is not explicitly mentioned in the JavaDoc that modifying the underlying list of a FixedSizeList would actually land up modifying the list of the constructed FixedSizeList.  Not sure if this was by design, but at the very list I think the JavaDoc should caution against this.

Following is a test case that written that you could use to check this.

{code:java}

public void testAllowsMutationOfUnderlyingCollection() {

 List<String> decoratedList = new ArrayList<>();
 decoratedList.add(""item 1"");
 decoratedList.add(""item 2"");
 //
 FixedSizeList<String> fixedSizeList = FixedSizeList.fixedSizeList(decoratedList);
 int sizeBefore = fixedSizeList.size();
 //
 boolean changed = decoratedList.add(""New Value"");
 Assert.assertTrue(changed);
 //
 Assert.assertEquals(""Modifying an the underlying list is allowed"", sizeBefore + 1, fixedSizeList.size());
}

{code}",,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2018-10-02 17:48:35.607,,,false,,,,,,,,,,,,,,9223372036854775807,,,Sat Oct 06 20:20:29 UTC 2018,,,,,,0|i3yqvb:,9223372036854775807,,,,,,,,"02/Oct/18 17:48;githubbot;GitHub user george-ranjan opened a pull request:

    https://github.com/apache/commons-collections/pull/55

    COLLECTIONS-697 Added relevant JavaDoc and a test which proves

    I just noticed that it is not explicitly mentioned in the JavaDoc that modifying the underlying list of a FixedSizeList would actually land up modifying the list of the constructed FixedSizeList. Not sure if this was by design, but at the very list I think the JavaDoc should caution against this.
    
    This Pull Request has the necessary updates to the JavaDoc and a test that proves the findings.
    
    NOTE: this is my first PR and I have tried to follow the guidelines.  Pleas let me know if I need to do anything more.  Thanks!

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/george-ranjan/commons-collections COLLECTIONS-697_FixedSizeList

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/commons-collections/pull/55.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #55
    
----
commit 1517ed304eef7737b7175a997d77cca384be8631
Author: george-ranjan <george.ranjan@...>
Date:   2018-10-02T17:44:07Z

    COLLECTIONS-697 Added relevant JavaDoc and a test which proves

----
","02/Oct/18 17:48;githubbot;GitHub user george-ranjan opened a pull request:

    https://github.com/apache/commons-collections/pull/55

    COLLECTIONS-697 Added relevant JavaDoc and a test which proves

    I just noticed that it is not explicitly mentioned in the JavaDoc that modifying the underlying list of a FixedSizeList would actually land up modifying the list of the constructed FixedSizeList. Not sure if this was by design, but at the very list I think the JavaDoc should caution against this.
    
    This Pull Request has the necessary updates to the JavaDoc and a test that proves the findings.
    
    NOTE: this is my first PR and I have tried to follow the guidelines.  Pleas let me know if I need to do anything more.  Thanks!

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/george-ranjan/commons-collections COLLECTIONS-697_FixedSizeList

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/commons-collections/pull/55.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #55
    
----
commit 1517ed304eef7737b7175a997d77cca384be8631
Author: george-ranjan <george.ranjan@...>
Date:   2018-10-02T17:44:07Z

    COLLECTIONS-697 Added relevant JavaDoc and a test which proves

----
","03/Oct/18 10:51;githubbot;Github user grimreaper commented on a diff in the pull request:

    https://github.com/apache/commons-collections/pull/55#discussion_r222264747
  
    --- Diff: src/main/java/org/apache/commons/collections4/list/FixedSizeList.java ---
    @@ -31,6 +31,12 @@
      * The add, remove, clear and retain operations are unsupported.
      * The set method is allowed (as it doesn't change the list size).
      * <p>
    + * <p>
    --- End diff --
    
    extra `<p>`
","03/Oct/18 10:51;githubbot;Github user grimreaper commented on a diff in the pull request:

    https://github.com/apache/commons-collections/pull/55#discussion_r222264719
  
    --- Diff: src/test/java/org/apache/commons/collections4/list/FixedSizeListTest.java ---
    @@ -66,4 +68,20 @@ public String getCompatibilityVersion() {
     //        writeExternalFormToDisk((java.io.Serializable) getCollection(), ""src/test/resources/data/test/FixedSizeList.fullCollection.version4.obj"");
     //    }
     
    +
    --- End diff --
    
    extra newline
","03/Oct/18 17:09;githubbot;Github user george-ranjan commented on the issue:

    https://github.com/apache/commons-collections/pull/55
  
    @grimreaper fixed & pushed.
","03/Oct/18 17:27;githubbot;Github user grimreaper commented on the issue:

    https://github.com/apache/commons-collections/pull/55
  
    cool. Now we're waiting for INFRA-17094. 
","06/Oct/18 20:20;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/commons-collections/pull/55
","06/Oct/18 20:20;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/commons-collections/pull/55
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
PatriciaTrie.subMap() does not return the expected outcome,COLLECTIONS-695,13184962,Bug,Resolved,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Invalid,,kwin,kwin,13/Sep/18 17:29,09/Oct/18 10:05,07/Apr/19 20:37,09/Oct/18 10:05,4.2,,,,,,,,,,,,,,0,,,,"I use a {{PatriciaTrie}} to basically retrieve the entry whose key is the longest prefix of a requested key. 

Now I do have a simple trie with only two entries:
# {{""/"":<somevalue>}}
# {{""/libs/cq/flow/widgets"":<someothervalue>""}}

If I call {{subMap(""/"", ""/libs/cq/gui/components/authoring/dialog/""}} I would expect to only get back a map containing only entry 1. Instead I get back both entries. This happens primarily with those two specific keys. 

According to the javadoc of {{PatriciaTrie}} 
{quote}
The Trie can return operations in lexicographical order using the 'prefixMap', 'submap', or 'iterator' methods. 
{quote}
(https://commons.apache.org/proper/commons-collections/apidocs/org/apache/commons/collections4/trie/PatriciaTrie.html) 
therefore I assumed that according to the lexicographical order only the ""/"" entry should be contained in here.

Is this a bug or am I misinterpreting the Javadoc?",,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,9223372036854775807,,,Tue Oct 09 10:05:41 UTC 2018,,,,,,0|i3y2gn:,9223372036854775807,,,,,,,,"09/Oct/18 10:05;kwin;To answer my own question: I was not correctly interpreting the order. Actually {{/libs/cq/gui/components/authoring/dialog/}} is lexicographically ordered after {{/libs/cq/flow/widgets}}, this is because the first different character at position 10 is in one case {{f}} and in the other case a {{g}}. Since the latter is lexicographically ordered after the former, the outcome is like this. So this is just a misinterpretation of the ordering.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Source code compilation error,COLLECTIONS-690,13173372,Bug,Resolved,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Won't Fix,,jayanthgh,jayanthgh,20/Jul/18 05:13,20/Jul/18 08:56,07/Apr/19 20:37,20/Jul/18 08:56,3.2.2,,,,,,,,Collection,,,,,,0,,,,"# Took source code from ""https://github.com/apache/commons-collections/tree/collections-3.2.2""
 # Trying to compile the code using ""ant compile"" in command prompt
 # Got the compilation error. Error logs is attached.","Windows 10 
JDK 1.8",,,,,,,,,,,,,,,,,,20/Jul/18 05:10;jayanthgh;commons_collections_3_2_2.txt;https://issues.apache.org/jira/secure/attachment/12932360/commons_collections_3_2_2.txt,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2018-07-20 08:56:09.523,,,false,,,,,Important,,,,,,,,,9223372036854775807,,,Fri Jul 20 08:56:09 UTC 2018,,,,,,0|i3w3lj:,9223372036854775807,,,,,,,,"20/Jul/18 08:56;sebb@apache.org;Sorry, but version 3.2.2 is quite old now.

Please use the latest version, i.e. 4.2",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Link to Javadoc API broken,COLLECTIONS-689,13172571,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Minor,Fixed,,Richard.Walker@ands.org.au,Richard.Walker@ands.org.au,17/Jul/18 06:51,18/Jul/18 23:53,07/Apr/19 20:37,17/Jul/18 16:08,4.2,,,,,4.3,,,Collection,,,,,,0,,,,"On the front page [https://commons.apache.org/proper/commons-collections/] in the Documentation section, the link to the Javadoc API for ""The current release 4.2"" is broken.",,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2018-07-17 16:08:10.635,,,false,,,,,,,,,,,,,,9223372036854775807,,,Wed Jul 18 23:53:03 UTC 2018,,,,,,0|i3vyo7:,9223372036854775807,,,,,,,,17/Jul/18 16:08;garydgregory;Thank you for your report. The live site has been patched. Please verify and close.,"18/Jul/18 23:53;Richard.Walker@ands.org.au;(The link _was_ version-agnostic, i.e.: https://commons.apache.org/proper/commons-collections/javadocs/api-release/)

I confirm that the new version-specific link does indeed work.

 ",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Coveralls.io set to wrong branch?,COLLECTIONS-686,13165891,Bug,Open,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Trivial,,,fury,fury,13/Jun/18 17:40,13/Jun/18 17:40,07/Apr/19 20:37,,,,,,,,,,,,,,,,0,,,,"According to

[https://coveralls.io/github/apache/commons-collections]

the default branch is *trunk* and has 85% coverage (last commit June 2017). But the real working github branch is *master* and has 87% coverage.

This is why the coveralls badge on Github shows 85% I guess. I suggest switching the default branch on coveralls from trunk to master.

 

 ","[https://coveralls.io/github/apache/commons-collections?branch=master]

[https://coveralls.io/github/apache/commons-collections]

 ",,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,9223372036854775807,,,2018-06-13 17:40:51.0,,,,,,0|i3utqn:,9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
IterableUtils has public constructor,COLLECTIONS-685,13165496,Bug,Open,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Trivial,,,fury,fury,12/Jun/18 06:04,12/Jun/18 21:48,07/Apr/19 20:37,,,,,,,5.0,,,Collection,,,,,,0,,,,IterableUtils has public constructor. All other Utils classes have their constructor made private to prohibit instantiation.,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2018-06-12 06:07:10.376,,,false,,,,,,,,,,,,,,9223372036854775807,,,Tue Jun 12 21:48:25 UTC 2018,,,,,,0|i3urb3:,9223372036854775807,,,,,,,,"12/Jun/18 06:07;githubbot;GitHub user sfuhrm opened a pull request:

    https://github.com/apache/commons-collections/pull/40

    COLLECTIONS-685: IterableUtils has public constructor

    Constructor for Utils class was not private. 
    This was obviously not intended as all other Utils classes have private constructors.

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/sfuhrm/commons-collections COLLECTIONS-685

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/commons-collections/pull/40.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #40
    
----
commit 49bc94faccddc2f81ce8af1db2bce8ccbede82d9
Author: Stephan Fuhrmann <s@...>
Date:   2018-06-12T06:02:06Z

    Constructor for Utils class was not private. This was obviously not intended as all other Utils classes have private constructors.

----
","12/Jun/18 06:07;githubbot;GitHub user sfuhrm opened a pull request:

    https://github.com/apache/commons-collections/pull/40

    COLLECTIONS-685: IterableUtils has public constructor

    Constructor for Utils class was not private. 
    This was obviously not intended as all other Utils classes have private constructors.

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/sfuhrm/commons-collections COLLECTIONS-685

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/commons-collections/pull/40.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #40
    
----
commit 49bc94faccddc2f81ce8af1db2bce8ccbede82d9
Author: Stephan Fuhrmann <s@...>
Date:   2018-06-12T06:02:06Z

    Constructor for Utils class was not private. This was obviously not intended as all other Utils classes have private constructors.

----
","12/Jun/18 06:13;githubbot;Github user sfuhrm commented on the issue:

    https://github.com/apache/commons-collections/pull/40
  
    BTW, TravisCI is right, technically this is an API change, but I suggest that all API uses are neither useful nor make sense.

","12/Jun/18 17:48;garydgregory;You cannot make a public API private without breaking binary compatiblity, so this is a no go in 4.x but would be OK for 5.0.","12/Jun/18 21:47;fury;[~garydgregory] thanks for your review! I undestand your view of the situation.

I'll close the PR so no one needs to bother about this. This ticket can stay open as a reminder.","12/Jun/18 21:48;githubbot;Github user sfuhrm commented on the issue:

    https://github.com/apache/commons-collections/pull/40
  
    Closing because of breaking the API.
    May be interesting for commons-cli 5.0.
","12/Jun/18 21:48;githubbot;Github user sfuhrm closed the pull request at:

    https://github.com/apache/commons-collections/pull/40
","12/Jun/18 21:48;githubbot;Github user sfuhrm closed the pull request at:

    https://github.com/apache/commons-collections/pull/40
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
README.md contains pointer to non-existing Maven artifact/javadoc,COLLECTIONS-683,13165370,Bug,Open,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Minor,,,fury,fury,11/Jun/18 16:47,13/Jun/18 08:12,07/Apr/19 20:37,,,,,,,,,,,,,,,,0,,,,"The README.md file contains references to the
 * 4.2 maven artefact on maven central (see XML snippet)
 * 4.2 Javadoc on javadoc.io (see badge)

These pointers do not exist and confuse the developers.

The current version in fact is 4.1.

 

 

 ",,,,,,,,,,,,,,,,COLLECTIONS-682,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2018-06-11 22:52:37.918,,,false,,,,,,,,,,,,,,9223372036854775807,,,Tue Jun 12 05:01:06 UTC 2018,,,,,,0|i3uqj3:,9223372036854775807,,,,,,,,11/Jun/18 22:52;garydgregory;That's because you are looking at git master...,"12/Jun/18 05:01;fury;Comparing to another commons-project: For commons-cli, the referred artefact version in the XML snippet seems right:

[https://github.com/apache/commons-cli]

Any clues what the difference is?",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
README.md contains unresolved template references,COLLECTIONS-682,13165366,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Trivial,Fixed,,fury,fury,11/Jun/18 16:43,12/Jun/18 21:40,07/Apr/19 20:37,11/Jun/18 22:51,,,,,,4.2,,,,,,,,,0,,,,"The README.md file contains an unresolved reference to

{{${project.description}}}

 ",https://github.com/apache/commons-collections/blob/master/README.md,,,,,,,,,,,,,,,,,,11/Jun/18 16:42;fury;readme-2018-06-11.png;https://issues.apache.org/jira/secure/attachment/12927330/readme-2018-06-11.png,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2018-06-11 22:51:47.146,,,false,,,,,,,,,,,,,,9223372036854775807,,,Tue Jun 12 21:40:59 UTC 2018,,,,,,0|i3uqi7:,9223372036854775807,,,,,,,,11/Jun/18 22:51;garydgregory;Fixed in git master. Please verify and close.,12/Jun/18 21:40;fury;Thanks for fixing so fast!,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
CollectionUtilsTest test for collect is broken,COLLECTIONS-680,13154833,Bug,Resolved,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,konangelop,konangelop,24/Apr/18 15:08,12/Jun/18 21:50,07/Apr/19 20:37,12/Jun/18 21:50,,,,,,,,,Collection,,,,,,0,,,,Cannot resolve method ConnectionUtils.collect in line 1289.,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2018-06-12 05:21:25.689,,,false,,,,,,,,,,,,,,9223372036854775807,,,Tue Jun 12 21:50:15 UTC 2018,,,,,,0|i3syjb:,9223372036854775807,,,,,,,,"12/Jun/18 05:21;fury;The build on TravisCI works:

[https://travis-ci.org/apache/commons-collections]

Can you please check with the current code?",12/Jun/18 21:50;garydgregory;Travis looks green ATM. Please review and close or comment.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
MultiValuedMap JavaDoc Typo,COLLECTIONS-679,13145828,Bug,Open,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Trivial,,,belugabehr,belugabehr,16/Mar/18 19:02,04/Apr/18 16:23,07/Apr/19 20:37,,,,,,,,,,,,,,,,0,,,,"https://github.com/apache/commons-collections/blob/36d33722c37417b2fba57106fee185a5e422ee47/src/main/java/org/apache/commons/collections4/MultiValuedMap.java#L35

The example code provided refers to a class called _MultiValuedHashMap_.  There is no such class in Commons Collection4.  Perhaps _ArrayListValuedHashMap_ is a better example.",,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2018-04-04 16:23:44.609,,,false,,,,,,,,,,,,,,9223372036854775807,,,Wed Apr 04 16:23:44 UTC 2018,,,,,,0|i3rf87:,9223372036854775807,,,,,,,,04/Apr/18 16:23;garydgregory;Please feel free to provide a PR on GitHub: https://github.com/apache/commons-collections,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
ListUtils.partition potential integer overflow,COLLECTIONS-673,13135817,Bug,Resolved,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,jmark,jmark,02/Feb/18 17:18,12/Jun/18 21:45,07/Apr/19 20:37,12/Jun/18 21:45,4.1,,,,,4.2,,,List,,,,,,0,,,,"When calling {{ListUtils.partition()}} with a large size and large list, it is possible that an integer overflow will occur in the {{size()}} method that causes incorrect behavior. This will occur when using a size that, when added to list.size() will be larger than {{Integer.MAX_VALUE}}

Current version of Guava's {{Lists.partition()}} handle this correctly, so perhaps the code for {{ListUtils.partition()}} needs to be updated based on the latest Guava code.

A simple illustration of this:
{code}
List<String> aList = Arrays.asList(""1"", ""2"", ""3"", ""4"", ""5"");
List<List<String>> partitioned = ListUtils.partition(aList, Integer.MAX_VALUE);
System.out.println(""Number of partitions: "" + partitioned.size());
for(List<String> l : partitioned)  {
     System.out.println(l);
}
{code}

The above code works correctly when using Guava's {{Lists.partition()}} instead.",,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2018-02-03 01:03:04.001,,,false,,,,,,,,,,,,,,9223372036854775807,,,Tue Jun 12 21:45:28 UTC 2018,,,,,,0|i3ppz3:,9223372036854775807,,,,,,,,"03/Feb/18 01:03;garydgregory;Thank for your report [~jmark].

We welcome patches, with unit tests of course! :)","09/Jun/18 17:33;githubbot;GitHub user sfuhrm opened a pull request:

    https://github.com/apache/commons-collections/pull/37

    COLLECTIONS-673: Fix inspired by the Guava partition() implementation

    A fix for the COLLECTIONS-673 bug and a unit test proving the fix for the shown defect.
    
    See https://issues.apache.org/jira/browse/COLLECTIONS-673

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/sfuhrm/commons-collections COLLECTIONS-673

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/commons-collections/pull/37.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #37
    
----
commit faf27f611f4429c77a800124b5fb6f641f871c0f
Author: Stephan Fuhrmann <s@...>
Date:   2018-06-09T17:30:13Z

    COLLECTIONS-673: Fix inspired by the Guava partition() implementation

----
","09/Jun/18 17:33;githubbot;GitHub user sfuhrm opened a pull request:

    https://github.com/apache/commons-collections/pull/37

    COLLECTIONS-673: Fix inspired by the Guava partition() implementation

    A fix for the COLLECTIONS-673 bug and a unit test proving the fix for the shown defect.
    
    See https://issues.apache.org/jira/browse/COLLECTIONS-673

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/sfuhrm/commons-collections COLLECTIONS-673

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/commons-collections/pull/37.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #37
    
----
commit faf27f611f4429c77a800124b5fb6f641f871c0f
Author: Stephan Fuhrmann <s@...>
Date:   2018-06-09T17:30:13Z

    COLLECTIONS-673: Fix inspired by the Guava partition() implementation

----
","09/Jun/18 17:37;githubbot;Github user coveralls commented on the issue:

    https://github.com/apache/commons-collections/pull/37
  
    
    [![Coverage Status](https://coveralls.io/builds/17407790/badge)](https://coveralls.io/builds/17407790)
    
    Coverage increased (+0.007%) to 86.582% when pulling **faf27f611f4429c77a800124b5fb6f641f871c0f on sfuhrm:COLLECTIONS-673** into **13ba1cc91ea441ab012fa4e9724fbca397f1b1cf on apache:master**.

","12/Jun/18 21:44;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/commons-collections/pull/37
","12/Jun/18 21:44;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/commons-collections/pull/37
","12/Jun/18 21:45;garydgregory;Thank you for your patch, please verify and close.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Unexpected ConcurrentModificationException when altering Collection of a MultiValuedMap,COLLECTIONS-663,13116181,Bug,Open,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Trivial,,kinow,chris333,chris333,04/Nov/17 17:38,06/Nov/17 03:44,07/Apr/19 20:37,,,,,,,,,,,,,,,,0,,,,"Testcase:
{code}	@Test
	public void test() {
		MultiValuedMap<Integer, Integer> multiMap = new HashSetValuedHashMap<>();
		multiMap.put(1, 10);
		multiMap.put(2, 20);
		for (Collection<Integer> innerCollection : multiMap.asMap().values()) {
			for (Iterator<Integer> iterator = innerCollection.iterator(); iterator.hasNext();) {
				Integer i = iterator.next();
				iterator.remove(); // only the innerCollection is altered
			}
			// innerCollection.add(6); // adding stuff back should also work...
		}
	}{code}
This test unexpectedly throws a ConcurrentModificationException.
The issue is that when calling {{iterator.remove()}} the {{AbstractMultiValuedMap.ValuesIterator}} detects that the Collection is empty and calls {{AbstractMultiValuedMap.this.remove(key);}}.

It may be better if the iterator of the inner collection had a reference on the iterator if the outer map and called {{containerIterator.remove()}} instead.
*Note:* this solution would again present issues if the user tries to add new elements in this now empty collection (which was removed from the parent).


In the current state, it is quite unclear why an exception is thrown, without debugging the code. 
",,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2017-11-05 03:21:04.071,,,false,,,,,,,,,,,,,,9223372036854775807,,,Mon Nov 06 03:44:34 UTC 2017,,,,,,0|i3meo7:,9223372036854775807,,,,,,,,"05/Nov/17 03:21;kinow;I believe the Javadocs from asMap from MultiValuedMap indicate it works for as a view for a state in the collection. If you have to alter the map or the values collection, I'd try first using the mapIterator() method from the MultiValuedMap. It returns a custom iterator.

The following altered code works for me:

{code:java}
    public void testAlteringCollection() {
        MultiValuedMap<Integer, Integer> multiMap = new HashSetValuedHashMap<>();
        multiMap.put(1, 10);
        multiMap.put(2, 20);
        Iterator<Integer> it = multiMap.mapIterator();
        for (Iterator<Integer> iterator = multiMap.mapIterator(); iterator.hasNext();) {
            Integer i = iterator.next();
            iterator.remove(); // only the innerCollection is altered
        }
    }
{code}

Does it help? Bruno","05/Nov/17 13:18;chris333;Thank you for your response.

I once used the {{MapIterator}}, sadly I found out that it doesn't support what I try to achieve:
{code}	@Test
	public void testWhatINeedToWork() {
		// ArrayListValuedHashMap<Integer, Integer> multiMap = new ArrayListValuedHashMap<>();
		MultiValuedMap<Integer, Integer> multiMap = new HashSetValuedHashMap<>();

		multiMap.put(1, 10);
		multiMap.put(1, 11);
		multiMap.put(2, 20);
		Iterator<Integer> it = multiMap.mapIterator();
		for (MapIterator<Integer, Integer> iterator = multiMap.mapIterator(); iterator.hasNext();) {
			iterator.next();
			Integer value = iterator.getValue();
			if ((value % 2) == 0) {
				// Integer is immutable, we need to replace using setValue(.)
				iterator.setValue(value * 2);
			}
		}
	}{code}
My issue was that {{MapIterator.setValue(.)}} is not supported.

(My current workaround is storing the elements I need to change in a list, and pushing them back in the map afterwards)

I understand the difficulty in implementing it for {{HashSetValuedHashMap}} though, as the {{HashSet.iterator}} doesn't support it either (sadly, that's what I need).
I observed that {{ArrayListValuedHashMap}} doesn't support {{setValue(.)}} either (should be possible, as {{ArrayList.listIterator}} has this feature.","06/Nov/17 03:44;kinow;Oh, not sure if there's a better way. Got what I think is your desired result with a not very elegant code.

{code:java}
    public void testWhatINeedToWork() {
        // ArrayListValuedHashMap<Integer, Integer> multiMap = new ArrayListValuedHashMap<>();
        MultiValuedMap<Integer, Integer> multiMap = new HashSetValuedHashMap<>();

        multiMap.put(1, 10);
        multiMap.put(1, 11);
        multiMap.put(2, 20);

        MapIterator<Integer, Integer> it = multiMap.mapIterator();
        while (it.hasNext()) {
            Integer key = it.next();
            if (key % 2 == 0) {
                Collection<Integer> values = multiMap.get(key);
                multiMap.putAll(key * 2, values);
                it.remove();
            }
        }
    }
{code}",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Build failures when building with Java 9,COLLECTIONS-662,13108787,Bug,Resolved,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,pascalschumacher,vamsi.kavuri,vamsi.kavuri,12/Oct/17 04:12,20/Oct/17 16:33,07/Apr/19 20:37,20/Oct/17 14:09,,,,,,,,,,,,,,,0,,,,"*mvn clean test* fails with following errors when using with java-9
{code:java}
Tests in error: 
  MapUtilsTest.testgetByteValue:1051 » ServiceConfiguration sun.util.locale.prov...
  MapUtilsTest.testgetDoubleValue:956 » ServiceConfiguration sun.util.locale.pro...
  MapUtilsTest.testgetFloatValue:974 » ServiceConfiguration sun.util.locale.prov...
  MapUtilsTest.testgetIntValue:1012 » ServiceConfiguration sun.util.locale.provi...
  MapUtilsTest.testgetLongValue:992 » ServiceConfiguration sun.util.locale.provi...
  MapUtilsTest.testgetShortValue:1031 » ServiceConfiguration sun.util.locale.pro...
  ListIteratorWrapperTest.testRemove:116 » ServiceConfiguration sun.util.locale....

Tests run: 16088, Failures: 0, Errors: 7, Skipped: 0
{code}
",,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2017-10-12 04:16:19.519,,,false,,,,,,,,,,,,,,9223372036854775807,,,Fri Oct 20 16:33:39 UTC 2017,,,,,,0|i3l60v:,9223372036854775807,,,,,,,,"12/Oct/17 04:16;githubbot;GitHub user vamsi-kavuri opened a pull request:

    https://github.com/apache/commons-collections/pull/30

     COLLECTIONS-662 : Override Jacoco version for Java9 compatibility

    Overriding Jacoco version fixed the failures in Java 9.

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/vamsi-kavuri/commons-collections java9_compat

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/commons-collections/pull/30.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #30
    
----
commit 191826a52a3d77a821d3715cc4074ed6348b6e0a
Author: Kavuri, Vamsi <vamsi.kavuri@capitalone.com>
Date:   2017-10-12T04:04:10Z

    override jacoco version for java9 compatibiltiy

commit 627b825a24eb03fb5d29f2eb5243034bafc12d94
Author: Vamsi <vamsi.kavuri@gmail.com>
Date:   2017-10-12T04:05:46Z

    Update pom.xml

----
","12/Oct/17 04:16;githubbot;GitHub user vamsi-kavuri opened a pull request:

    https://github.com/apache/commons-collections/pull/30

     COLLECTIONS-662 : Override Jacoco version for Java9 compatibility

    Overriding Jacoco version fixed the failures in Java 9.

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/vamsi-kavuri/commons-collections java9_compat

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/commons-collections/pull/30.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #30
    
----
commit 191826a52a3d77a821d3715cc4074ed6348b6e0a
Author: Kavuri, Vamsi <vamsi.kavuri@capitalone.com>
Date:   2017-10-12T04:04:10Z

    override jacoco version for java9 compatibiltiy

commit 627b825a24eb03fb5d29f2eb5243034bafc12d94
Author: Vamsi <vamsi.kavuri@gmail.com>
Date:   2017-10-12T04:05:46Z

    Update pom.xml

----
","12/Oct/17 04:20;githubbot;Github user coveralls commented on the issue:

    https://github.com/apache/commons-collections/pull/30
  
    
    [![Coverage Status](https://coveralls.io/builds/13681730/badge)](https://coveralls.io/builds/13681730)
    
    Coverage remained the same at 86.616% when pulling **627b825a24eb03fb5d29f2eb5243034bafc12d94 on vamsi-kavuri:java9_compat** into **07de4dd578727555bb94ed421498f455838b317d on apache:master**.

","12/Oct/17 07:55;githubbot;Github user PascalSchumacher commented on the issue:

    https://github.com/apache/commons-collections/pull/30
  
    Thanks!
","12/Oct/17 07:55;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/commons-collections/pull/30
","12/Oct/17 07:55;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/commons-collections/pull/30
","20/Oct/17 14:09;chtompki;Pascal merged this, I think.",20/Oct/17 16:33;pascalschumacher;Yes. Thanks for resolving the issue and adding the changes.xml entry. I forgot to do that. :( Sorry.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Intermittent test failures in Windows for HashSetValuedHashMap,COLLECTIONS-661,13106660,Bug,Resolved,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,kinow,kinow,kinow,03/Oct/17 09:54,12/Oct/17 06:31,07/Apr/19 20:37,12/Oct/17 06:31,4.1,,,,,4.2,,,Map,,,,,,0,,,,"The collection HashSetValuedHashMap was added in 4.1. On Windows, test failures are not so common on JVM 8. But on Linux they are harder to happen (but still do [1], [2]).

When using Windows and JVM 8, running tests on Eclipse, or Maven fail. But debugging on Windows with Eclipse sometimes work. Indicating it may be due to a concurrency issue, where debugging adds some extra time hiding the real issue.

I have a few ideas of where/why it could be happening, but am without a Windows box for a few days as I'm travelling. I'm reading the codebase in the meantime, but if anybody feels like working on it, feel free to chime in and suggest a fix/patch.

[1] https://travis-ci.org/apache/commons-collections/jobs/282169803
[2] http://markmail.org/thread/exwm7ggjtxzbtlkd",,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2017-10-03 18:37:16.012,,,false,,,,,,,,,,,,,,9223372036854775807,,,Thu Oct 12 06:29:56 UTC 2017,,,,,,0|i3kthr:,9223372036854775807,,,,,,,,"03/Oct/17 18:37;garydgregory;Could this be related to this note in {{Object.hashCode(Object)}}:
{code:java}
     * <li>It is <em>not</em> required that if two objects are unequal
     *     according to the {@link java.lang.Object#equals(java.lang.Object)}
     *     method, then calling the {@code hashCode} method on each of the
     *     two objects must produce distinct integer results.  However, the
     *     programmer should be aware that producing distinct integer results
     *     for unequal objects may improve the performance of hash tables.
{code}
","11/Oct/17 07:37;githubbot;GitHub user kinow opened a pull request:

    https://github.com/apache/commons-collections/pull/28

    COLLECTIONS-661: fix for concurrency issue in HashSetValuedHashMapTest

    The `getMap()` method, when testing a `HashSetValuedHashMap`, would return an object of this type. Which is an instance of `SetValuedMap`.
    
    Running it in debug mode would - most of the times - run the tests and succeed. Running normally - especially on Windows - would result in intermittent, but very frequent, failures.
    
    The `getMap()` method sometimes, depending on the order and execution of tests, will be null. So the collection added to the map will be either a `Hashset`, or a `Arrays$ArrayList`. When the types are different, `hashCode()` and `equals()` calls return incorrect values, resulting in the errors we have seen in COLLECTIONS-661.
    
    A good solution would be to re-design the tests. The `TestMultiValuedMapAsMap` is testing `MultiValuedMap`'s, which include `HashSetValuedHashMap`. However, some of its methods contain extra logic for when the type under test has some characteristics like being an instance of `SetValuedMap`.
    
    It might be possible to come up with a better design, where there are multiple test classes, for `MultiValuedMap`'s that use `SetValuedMap`'s; `MultieValuedMap`'s that use `List`'s, and so it goes.
    
    Or we could add a class to the parent class, with a flag defining the type under test. For now, I have used the `makeObject()` method, which returns the collection under test. Then I validate its instance type. There is also a comment above the code to indicate why we are using `makeObject()` and not `getMap()`.
    
    It was a fun ticket. Happy to get feedback on better solutions, or feel free to edit this pull request if you have right to it, or merge if you are happy and it has gathered some consensus.
    
    Cheers,
    Bruno

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/kinow/commons-collections COLLECTIONS-661

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/commons-collections/pull/28.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #28
    
----
commit 6e8951ed0325abe3e07e32aded0b27aacdbc1011
Author: Bruno P. Kinoshita <brunodepaulak@yahoo.com.br>
Date:   2017-10-11T07:27:25Z

    COLLECTIONS-661: fix for concurrency issue in HashSetValuedHashMapTest

----
","11/Oct/17 07:37;githubbot;GitHub user kinow opened a pull request:

    https://github.com/apache/commons-collections/pull/28

    COLLECTIONS-661: fix for concurrency issue in HashSetValuedHashMapTest

    The `getMap()` method, when testing a `HashSetValuedHashMap`, would return an object of this type. Which is an instance of `SetValuedMap`.
    
    Running it in debug mode would - most of the times - run the tests and succeed. Running normally - especially on Windows - would result in intermittent, but very frequent, failures.
    
    The `getMap()` method sometimes, depending on the order and execution of tests, will be null. So the collection added to the map will be either a `Hashset`, or a `Arrays$ArrayList`. When the types are different, `hashCode()` and `equals()` calls return incorrect values, resulting in the errors we have seen in COLLECTIONS-661.
    
    A good solution would be to re-design the tests. The `TestMultiValuedMapAsMap` is testing `MultiValuedMap`'s, which include `HashSetValuedHashMap`. However, some of its methods contain extra logic for when the type under test has some characteristics like being an instance of `SetValuedMap`.
    
    It might be possible to come up with a better design, where there are multiple test classes, for `MultiValuedMap`'s that use `SetValuedMap`'s; `MultieValuedMap`'s that use `List`'s, and so it goes.
    
    Or we could add a class to the parent class, with a flag defining the type under test. For now, I have used the `makeObject()` method, which returns the collection under test. Then I validate its instance type. There is also a comment above the code to indicate why we are using `makeObject()` and not `getMap()`.
    
    It was a fun ticket. Happy to get feedback on better solutions, or feel free to edit this pull request if you have right to it, or merge if you are happy and it has gathered some consensus.
    
    Cheers,
    Bruno

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/kinow/commons-collections COLLECTIONS-661

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/commons-collections/pull/28.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #28
    
----
commit 6e8951ed0325abe3e07e32aded0b27aacdbc1011
Author: Bruno P. Kinoshita <brunodepaulak@yahoo.com.br>
Date:   2017-10-11T07:27:25Z

    COLLECTIONS-661: fix for concurrency issue in HashSetValuedHashMapTest

----
","11/Oct/17 07:40;githubbot;Github user coveralls commented on the issue:

    https://github.com/apache/commons-collections/pull/28
  
    
    [![Coverage Status](https://coveralls.io/builds/13663731/badge)](https://coveralls.io/builds/13663731)
    
    Coverage increased (+0.008%) to 85.126% when pulling **6e8951ed0325abe3e07e32aded0b27aacdbc1011 on kinow:COLLECTIONS-661** into **1d21a49c27d9eab8d02785a783fcfba387a3e8e1 on apache:master**.

","12/Oct/17 06:29;githubbot;Github user kinow commented on the issue:

    https://github.com/apache/commons-collections/pull/28
  
    Merged inhttps://github.com/apache/commons-collections/commit/eed8a7adb3de7441751e846f4a75d110dd205f23. Closing it.
","12/Oct/17 06:29;githubbot;Github user kinow closed the pull request at:

    https://github.com/apache/commons-collections/pull/28
","12/Oct/17 06:29;githubbot;Github user kinow closed the pull request at:

    https://github.com/apache/commons-collections/pull/28
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Uncomment test in AbstractMapTest regarding LRUMap equals,COLLECTIONS-660,13106652,Bug,Resolved,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Minor,Fixed,kinow,kinow,kinow,03/Oct/17 09:41,04/Oct/17 04:44,07/Apr/19 20:37,04/Oct/17 04:39,4.1,,,,,4.2,,,Map,,,,,,0,,,,"AbstractMapTest has a [commented out|https://github.com/apache/commons-collections/blob/c8bdf60d1d0be609094e14054be0b9af0fb05521/src/test/java/org/apache/commons/collections4/map/AbstractMapTest.java#L1959] line, with a comment as follows:

{quote}his fails for LRUMap because confirmed.equals() somehow modifies map, causing concurrent modification exceptions.{quote}

While working on another test failing on Windows, I believe I've found the why for that comment, and how to fix it. Just need to finish debugging another part, and find a good Internet connection to push the fix.",,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,Patch,,,,,,,,,9223372036854775807,,,Wed Oct 04 04:44:06 UTC 2017,,,,,,0|i3ktfz:,9223372036854775807,,,,,,,,"04/Oct/17 04:40;kinow;Due to the order of the arguments of the assertEquals, we were calling TreeMap#equals, which would create a normal iterator instead of calling mapIterator().

This would change the modCount in the parent, resulting finally in the concurrent modification exception.","04/Oct/17 04:44;kinow;Fixed in 9d4f2ba886b003980f2c37a4de7a3e6c3c701820, and changes.xml entry in 1d21a49c27d9eab8d02785a783fcfba387a3e8e1",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"""union"" method is resulting in data loss",COLLECTIONS-657,13103306,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Critical,Invalid,,kibertoad,kibertoad,19/Sep/17 18:12,19/Sep/17 18:38,07/Apr/19 20:37,19/Sep/17 18:38,4.1,,,,,,,,,,,,,,0,,,,"Create 2 instances of StringReader from strings (1 and 2), put them into a list A.
Create empty list B.
Call CollectionUtils.union(A, B);

Expected result: [1, 2]
Actual result: [1, 1].",,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,9223372036854775807,,,Tue Sep 19 18:38:45 UTC 2017,,,,,,0|i3k8wv:,9223372036854775807,,,,,,,,"19/Sep/17 18:38;kibertoad;After digging in further to create a reproduction test, figured out it's actually an issue with how equals is implemented in Drools library.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Fix site build on Java 8,COLLECTIONS-656,13101595,Bug,Resolved,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Minor,Fixed,kinow,kinow,kinow,12/Sep/17 10:42,13/Sep/17 07:52,07/Apr/19 20:37,13/Sep/17 07:52,4.1,,,,,4.2,,,,,,,,,0,documentation,site,,"Building the current master branch from git fails with

{noformat}
[INFO] Generating ""FindBugs"" report             --- findbugs-maven-plugin:2.5.5:findbugs
[INFO] Locale is en
[INFO] Fork Value is true
     [java] The following errors occurred during analysis:
     [java]   Error scanning java/util/Map$Entry for referenced classes
     [java]     java.lang.ArrayIndexOutOfBoundsException: 5735
     [java]       At org.objectweb.asm.ClassReader.readClass(Unknown Source)
     [java]       At org.objectweb.asm.ClassReader.accept(Unknown Source)
     [java]       At edu.umd.cs.findbugs.asm.FBClassReader.accept(FBClassReader.java:44)
     [java]       At org.objectweb.asm.ClassReader.accept(Unknown Source)
     [java]       At edu.umd.cs.findbugs.classfile.engine.ClassParserUsingASM.parse(ClassParserUsingASM.java:110)
     [java]       At edu.umd.cs.findbugs.classfile.engine.ClassParserUsingASM.parse(ClassParserUsingASM.java:587)
     [java]       At edu.umd.cs.findbugs.classfile.engine.ClassInfoAnalysisEngine.analyze(ClassInfoAnalysisEngine.java:76)
     [java]       At edu.umd.cs.findbugs.classfile.engine.ClassInfoAnalysisEngine.analyze(ClassInfoAnalysisEngine.java:38)
     [java]       At edu.umd.cs.findbugs.classfile.impl.AnalysisCache.getClassAnalysis(AnalysisCache.java:268)
     [java]       At edu.umd.cs.findbugs.FindBugs2.buildReferencedClassSet(FindBugs2.java:891)
     [java]       At edu.umd.cs.findbugs.FindBugs2.execute(FindBugs2.java:222)
     [java]       At edu.umd.cs.findbugs.FindBugs.runMain(FindBugs.java:393)
     [java]       At edu.umd.cs.findbugs.FindBugs2.main(FindBugs2.java:1317)
     [java]   Error scanning java/util/Comparator for referenced classes
     [java]     java.lang.ArrayIndexOutOfBoundsException: 1320
     [java]       At org.objectweb.asm.ClassReader.readClass(Unknown Source)
     [java]       At org.objectweb.asm.ClassReader.accept(Unknown Source)
     [java]       At edu.umd.cs.findbugs.asm.FBClassReader.accept(FBClassReader.java:44)
     [java]       At org.objectweb.asm.ClassReader.accept(Unknown Source)
     [java]       At edu.umd.cs.findbugs.classfile.engine.ClassParserUsingASM.parse(ClassParserUsingASM.java:110)
     [java]       At edu.umd.cs.findbugs.classfile.engine.ClassParserUsingASM.parse(ClassParserUsingASM.java:587)
     [java]       At edu.umd.cs.findbugs.classfile.engine.ClassInfoAnalysisEngine.analyze(ClassInfoAnalysisEngine.java:76)
     [java]       At edu.umd.cs.findbugs.classfile.engine.ClassInfoAnalysisEngine.analyze(ClassInfoAnalysisEngine.java:38)
     [java]       At edu.umd.cs.findbugs.classfile.impl.AnalysisCache.getClassAnalysis(AnalysisCache.java:268)
     [java]       At edu.umd.cs.findbugs.FindBugs2.buildReferencedClassSet(FindBugs2.java:891)
     [java]       At edu.umd.cs.findbugs.FindBugs2.execute(FindBugs2.java:222)
     [java]       At edu.umd.cs.findbugs.FindBugs.runMain(FindBugs.java:393)
     [java]       At edu.umd.cs.findbugs.FindBugs2.main(FindBugs2.java:1317)
     [java]   Unable to get XClass for java/util/AbstractMap$SimpleEntry
     [java]     java.lang.ArrayIndexOutOfBoundsException: 5735
     [java]       At org.objectweb.asm.ClassReader.readClass(Unknown Source)
     [java]       At org.objectweb.asm.ClassReader.accept(Unknown Source)
     [java]       At edu.umd.cs.findbugs.asm.FBClassReader.accept(FBClassReader.java:44)
     [java]       At org.objectweb.asm.ClassReader.accept(Unknown Source)
     [java]       At edu.umd.cs.findbugs.classfile.engine.ClassParserUsingASM.parse(ClassParserUsingASM.java:110)
     [java]       At edu.umd.cs.findbugs.classfile.engine.ClassParserUsingASM.parse(ClassParserUsingASM.java:587)
     [java]       At edu.umd.cs.findbugs.classfile.engine.ClassInfoAnalysisEngine.analyze(ClassInfoAnalysisEngine.java:76)
     [java]       At edu.umd.cs.findbugs.classfile.engine.ClassInfoAnalysisEngine.analyze(ClassInfoAnalysisEngine.java:38)
     [java]       At edu.umd.cs.findbugs.classfile.impl.AnalysisCache.getClassAnalysis(AnalysisCache.java:268)
     [java]       At edu.umd.cs.findbugs.FindBugs2.buildReferencedClassSet(FindBugs2.java:891)
     [java]       At edu.umd.cs.findbugs.FindBugs2.execute(FindBugs2.java:222)
     [java]       At edu.umd.cs.findbugs.FindBugs.runMain(FindBugs.java:393)
     [java]       At edu.umd.cs.findbugs.FindBugs2.main(FindBugs2.java:1317)
     [java]   Unable to get XClass for org/apache/commons/collections4/map/StaticBucketMap$Node
     [java]     java.lang.ArrayIndexOutOfBoundsException: 5735
     [java]       At org.objectweb.asm.ClassReader.readClass(Unknown Source)
     [java]       At org.objectweb.asm.ClassReader.accept(Unknown Source)
     [java]       At edu.umd.cs.findbugs.asm.FBClassReader.accept(FBClassReader.java:44)
     [java]       At org.objectweb.asm.ClassReader.accept(Unknown Source)
     [java]       At edu.umd.cs.findbugs.classfile.engine.ClassParserUsingASM.parse(ClassParserUsingASM.java:110)
     [java]       At edu.umd.cs.findbugs.classfile.engine.ClassParserUsingASM.parse(ClassParserUsingASM.java:587)
     [java]       At edu.umd.cs.findbugs.classfile.engine.ClassInfoAnalysisEngine.analyze(ClassInfoAnalysisEngine.java:76)
     [java]       At edu.umd.cs.findbugs.classfile.engine.ClassInfoAnalysisEngine.analyze(ClassInfoAnalysisEngine.java:38)
     [java]       At edu.umd.cs.findbugs.classfile.impl.AnalysisCache.getClassAnalysis(AnalysisCache.java:268)
     [java]       At edu.umd.cs.findbugs.FindBugs2.buildReferencedClassSet(FindBugs2.java:891)
     [java]       At edu.umd.cs.findbugs.FindBugs2.execute(FindBugs2.java:222)
     [java]       At edu.umd.cs.findbugs.FindBugs.runMain(FindBugs.java:393)
     [java]       At edu.umd.cs.findbugs.FindBugs2.main(FindBugs2.java:1317)
...
{noformat}

Tested locally, and updating the commons-parent version to 42, and specifying the findbugs version from the parent property seems to fix the issue. As it could affect other parts of the build/release artefacts, I'll send a pull request to allow others to review before the parent is updated.",,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2017-09-12 22:45:57.451,,,false,,,,,Patch,,,,,,,,,9223372036854775807,,,Tue Sep 12 22:45:57 UTC 2017,,,,,,0|i3jyhr:,9223372036854775807,,,,,,,,"12/Sep/17 22:45;githubbot;Github user kinow commented on the issue:

    https://github.com/apache/commons-collections/pull/26
  
    Fixed in 1081b725bea339fcda33d70c71b9eb1859d60d8f and 6a10051a7b5b3c615180413fe116c61780754969. Thanks to @garydgregory !
","12/Sep/17 22:45;githubbot;Github user kinow closed the pull request at:

    https://github.com/apache/commons-collections/pull/26
","12/Sep/17 22:45;githubbot;Github user kinow closed the pull request at:

    https://github.com/apache/commons-collections/pull/26
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
An obvious bug in CollectionUtils,COLLECTIONS-652,13086518,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Minor,Fixed,,samray,samray,12/Jul/17 08:49,02/Aug/17 16:50,07/Apr/19 20:37,02/Aug/17 16:50,3.2.1,,,,,3.2.2,,,Collection,,,,,,0,easyfix,,,"In CollectionUtils.java:
Line number: 1121

    /**
     * Removes the elements in <code>remove</code> from <code>collection</code>. That is, this
     * method returns a collection containing all the elements in <code>c</code>
     * that are not in <code>remove</code>. The cardinality of an element <code>e</code>
     * in the returned collection is the same as the cardinality of <code>e</code>
     * in <code>collection</code> unless <code>remove</code> contains <code>e</code>, in which
     * case the cardinality is zero. This method is useful if you do not wish to modify
     * the collection <code>c</code> and thus cannot call <code>collection.removeAll(remove);</code>.
     * 
     * @param collection  the collection from which items are removed (in the returned collection)
     * @param remove  the items to be removed from the returned <code>collection</code>
     * @return a <code>Collection</code> containing all the elements of <code>collection</code> except
     * any elements that also occur in <code>remove</code>.
     * @throws NullPointerException if either parameter is null
     * @since Commons Collections 3.2
     */
    public static Collection removeAll(Collection collection, Collection remove) {
        return ListUtils.retainAll(collection, remove);
    }
The method should call ListUtils.removeAll(Collection collection, Collection remove) instead of calling ListUtils.retailAll(collection,remove)","windows 7, jdk8. This bug is so obvious so I think it is nothing to do with environment",,,,600,600,,0%,600,600,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2017-08-02 16:50:02.666,,"    /**
     * Removes the elements in <code>remove</code> from <code>collection</code>. That is, this
     * method returns a collection containing all the elements in <code>c</code>
     * that are not in <code>remove</code>. The cardinality of an element <code>e</code>
     * in the returned collection is the same as the cardinality of <code>e</code>
     * in <code>collection</code> unless <code>remove</code> contains <code>e</code>, in which
     * case the cardinality is zero. This method is useful if you do not wish to modify
     * the collection <code>c</code> and thus cannot call <code>collection.removeAll(remove);</code>.
     * 
     * @param collection  the collection from which items are removed (in the returned collection)
     * @param remove  the items to be removed from the returned <code>collection</code>
     * @return a <code>Collection</code> containing all the elements of <code>collection</code> except
     * any elements that also occur in <code>remove</code>.
     * @throws NullPointerException if either parameter is null
     * @since Commons Collections 3.2
     */",false,,,,,Important,Patch,,,,,,,,9223372036854775807,,,Wed Aug 02 16:50:02 UTC 2017,,,,,,0|i3hf0f:,9223372036854775807,,,,,,,,02/Aug/17 16:50;sebb@apache.org;This was fixed in 3.2.2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
More uniform safe-null methods in CollectionUtils,COLLECTIONS-604,13075163,Bug,Open,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Minor,,kinow,kinow,kinow,26/May/17 12:41,29/Jun/17 00:44,07/Apr/19 20:37,,4.1,,,,,,,,Collection,,,,,,1,,,,"Currently, there are 65 public methods in `CollectionUtils`. And 53 without the deprecated ones. Out of these, 24 handle `null` arguments. The remaining methods throw a `NullPointerException` (NPE) at some part of its code.

The methods that handle nulls, throw NPE, or return empty columns, boolean values, or just doesn't do anything.

As a user of the API, I would expect a more uniform behaviour across the methods of `CollectionUtils`. COLLECTIONS-600 address one of these methods.

`removeAll` (2x) and `retainAll` (2x) both state that a NPE will be thrown if either parameter is `null`. However, they never check if the values are null, and instead allow the code to run until a NPE is thrown.

And the following code shows that `isEmpty` and `isFull` behave differently too.

{code:java}
Collection<String> c = null;
System.out.println(CollectionUtils.isEmpty(c)); // return true
System.out.println(CollectionUtils.isFull(c));  // throws a NPE
{code}

If I don't have to worry about `null`s with `#isEmpty`, I would expect the same from its related-method `#isFull`.

What would be a good approach for it? Define a behaviour to all methods? Or leave as is, but add more documentation?

There are a few methods that can easily be updated to check for `null` values. Others would require a bit more thinking. An example if the method in question for COLLECTIONS-600. It checks equality of collections, and when both collections are `null`, it says that they are equals. Google Guava [Iterables#elementsEqual|https://github.com/google/guava/blob/312aeb938bd35b5b7c8930e19ff5d1ca38e49424/guava/src/com/google/common/collect/Iterables.java#L232] and [Iterators#elementsEqual|https://github.com/google/guava/blob/312aeb938bd35b5b7c8930e19ff5d1ca38e49424/guava/src/com/google/common/collect/Iterators.java#L274] do not check for null values, for what it is worth.",,,,,,,,,,,,,,,,,,,26/May/17 12:51;kinow;COLLECTIONS-604.csv;https://issues.apache.org/jira/secure/attachment/12870066/COLLECTIONS-604.csv,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2017-05-28 14:00:17.185,,,false,,,,,,,,,,,,,,9223372036854775807,,,Thu Jun 29 00:44:07 UTC 2017,,,,,,0|i3fipr:,9223372036854775807,,,,,,,,26/May/17 12:51;kinow;CSV file used for this issue.,"28/May/17 14:00;jholtkamp;A good comparison for {{null}}-behaviour would be a look to {{StringUtils}} et. al. in my mind, because 
a) {{StringUtils}} handles {{null}} values reasonably and
b) that would align behaviours across the different Commons libraries","05/Jun/17 18:00;jholtkamp;As [~britter] writes on the Mailing List:
{quote}Nobody seems to have an opinion on this issue so you should start implementing your preference.{quote}
Should we design an approach together or what is your favourite way of implementing this here?","06/Jun/17 10:05;kinow;Hi [~jholtkamp],

>Should we design an approach together

+1

> or what is your favourite way of implementing this here?

I liked your arguments for an approach that follows the behaviour in `StringUtils`.

[~tn], any feedback on this? We might change some JavaDocs, and make it null-safe in some cases, without breaking binary compatibility, but still changing the behaviour. I was reading the last updates in the tickets, and I think we drove the design of many changes in 4.x. So if you have anything in mind I'd appreciate any feedback before we start changing the code. Later we may look at other classes to make this behaviour consistent across the whole [collections] component.

Cheers
Bruno ","28/Jun/17 10:05;jholtkamp;[~kinow] No feedback from his side, so I'd start implementing some example cases on the weekend.",29/Jun/17 00:44;kinow;Sounds like a good idea [~jholtkamp]!,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"Small improvements for generics, conditional statements, and warnings suppressions",COLLECTIONS-603,13074427,Bug,Resolved,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Minor,Fixed,kinow,kinow,kinow,24/May/17 08:02,24/May/17 08:21,07/Apr/19 20:37,24/May/17 08:21,,,,,,4.2,,,Collection,,,,,,0,,,,Place holder for pull request #17,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,Patch,,,,,,,,,9223372036854775807,,,2017-05-24 08:02:31.0,,,,,,0|i3fe67:,9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Improve efficiency of DefaultedMap.get,COLLECTIONS-602,13073447,Bug,Resolved,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,kinow,jmark,jmark,19/May/17 14:23,24/May/17 09:35,07/Apr/19 20:37,24/May/17 09:35,,,,,,4.2,,,,,,,,,0,help-wanted,,,"The current implementation of {{org.apache.commons.collections4.map.DefaultedMap.get()}} is inefficient since it always require two map lookups. There is no need to check map.containsKey() every time. I would suggest implementing this method similar to the way that Java 8 does with {{Map.getOrDefault()}}. My proposed implementation would be something like this:

{code}
public V get(final Object key) {
    V v;
    return ((v = map.get(key) != null) || map.containsKey(key)) ? v : value.transform((K) key);
}
{code}

It can be further optimized to not even call map.containsKey() if map is known to not contain null values.",,,,,,,,,,,,,,,,,,,22/May/17 13:26;jmark;COLLECTIONS-602.patch;https://issues.apache.org/jira/secure/attachment/12869258/COLLECTIONS-602.patch,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2017-05-19 23:43:23.177,,,false,,,,,,,,,,,,,,9223372036854775807,,,Wed May 24 09:35:28 UTC 2017,,,,,,0|i3f84f:,9223372036854775807,,,,,,,,19/May/17 23:43;kinow;Sounds like a good argument [~jmark]. Would you be interested in submitting a pull request? :-),"21/May/17 02:56;jmark;Sure, just let me know what the process for that is.","21/May/17 05:13;kinow;For general information on how to contribute, see [this page|https://commons.apache.org/patches.html].

Commons Collections is still using Subversion for code management, this is the repository https://svn.apache.org/repos/asf/commons/proper/collections/trunk

If you are comfortable with Subversion, you can check out that repository, make your changes, and follow the information in the first link to create a JIRA ticket, and a patch to attach to the ticket with your changes.

If you are more comfortable or prefer to use Git, you can fork https://github.com/apache/commons-collections, make all the changes in your own forked repository, and then [submit a pull request|https://help.github.com/articles/about-pull-requests/].

A committer will review your patch or pull request, and either ask for feedback or changes, and then merge it (-:

Hope that helps
Bruno","22/May/17 13:26;jmark;Yes, that is what I was looking for, thanks.

I am attaching a patch to this ticket.
",22/May/17 13:26;jmark;Patch for proposed solution.,"24/May/17 09:35;kinow;Patch applied. All tests pass, coverage of the get method kept at 100%, no issues found in CPD, PMD, FindBugs, or Checkstyle. Nice and simple improvement, if the object exists in the map, it will avoid some work. The class javadocs cover thread safety, and this change is aligned with what is stated there.

Thanks for taking your time to submit this patch [~jmark].

Cheers
Bruno",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
commons-collections unit tests broken in Java 8,COLLECTIONS-601,13057481,Bug,Resolved,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Cannot Reproduce,,mureinik,mureinik,20/Mar/17 10:38,25/May/17 11:07,07/Apr/19 20:37,24/May/17 08:25,Nightly Builds,,,,,,,,,,,,,,0,test,,,"Building the upstream trunk (currently, patch 30b2aca) fails the unit tests in Java 8, but passes in Java 7 on the same machine. Attached logs with env details an errors of a successful Java 7 build and an unsuccessful Java 8 build","Maven 3.3.9, Java 1.8.0-121-1.b14, Fedora 25 - full details in attached logs",,,,,,,,,,,,,,,,,,20/Mar/17 10:45;mureinik;commons-collections.java7.build.log;https://issues.apache.org/jira/secure/attachment/12859544/commons-collections.java7.build.log,20/Mar/17 10:45;mureinik;commons-collections.java8.build.log;https://issues.apache.org/jira/secure/attachment/12859543/commons-collections.java8.build.log,,,,,,,,2.0,,,,,,,,,,,,,,,,,,,2017-03-20 21:51:54.519,,,false,,,,,,,,,,,,,,9223372036854775807,,,Thu May 25 11:07:29 UTC 2017,,,,,,0|i3ciav:,9223372036854775807,,,,,,,,"20/Mar/17 21:51;sebb@apache.org;Does not fail on Jenkins:

https://builds.apache.org/view/Apache%20Commons/job/Commons-Collections-Java8/1/console

The error looks like it may be an ordering issue.
Could be due to a test bug, a code bug or a JVM bug.","24/May/17 08:25;kinow;The job mentioned above was run against: jdk1.8.0_121

And for me

{noformat}
Results :

Tests run: 16069, Failures: 0, Errors: 0, Skipped: 0

[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 25.850 s
[INFO] Finished at: 2017-05-24T20:23:49+12:00
[INFO] Final Memory: 29M/561M
[INFO] ------------------------------------------------------------------------
{noformat}

Running on

{noformat}
Apache Maven 3.3.9 (bb52d8502b132ec0a5a3f4c09453c07478323dc5; 2015-11-11T05:41:47+13:00)
Maven home: /opt/maven
Java version: 1.8.0_131, vendor: Oracle Corporation
Java home: /usr/lib/jvm/java-8-oracle/jre
Default locale: en_US, platform encoding: UTF-8
OS name: ""linux"", version: ""4.4.0-78-generic"", arch: ""amd64"", family: ""unix""
{noformat}

As this can't be reproduced now with recent Java 8 releases, will resolve this issue.","25/May/17 11:07;mureinik;I can confirm the build passes on my machine with the following environment:

    Apache Maven 3.3.9 (NON-CANONICAL_2016-07-01T11:53:38Z_mockbuild; 2016-07-01T14:53:38+03:00)
    Maven home: /usr/share/maven
    Java version: 1.8.0_131, vendor: Oracle Corporation
    Java home: /usr/lib/jvm/java-1.8.0-openjdk-1.8.0.131-1.b12.fc25.x86_64/jre
    Default locale: en_US, platform encoding: UTF-8
    OS name: ""linux"", version: ""4.10.15-200.fc25.x86_64"", arch: ""amd64"", family: ""unix""

Thanks [~brunodepaulak@yahoo.com.br]",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
HashEntry array object naming data initialized with double the size during deserialization,COLLECTIONS-599,13025071,Bug,Open,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Critical,,,tejast5,tejast5,02/Dec/16 11:58,02/Feb/18 10:10,07/Apr/19 20:37,,3.1,,,,,4.1,,,Collection,Map,,,,,0,,,,"Common collections 3.1 and 3.2 are used at many places and frameworks including struts2. 
Supose a LinkedMap object it is created and have size greater than zero is serialized. While deserializing this object , array of HashEntry naming data delacred in AbstractHashedMap always initialises with a new capacity of double its double of the serialized object. 

Please see the below API declared in AbstractHashedMap class :

{code:java}
protected void checkCapacity()
  {
    if (this.size >= this.threshold)
    {
      int newCapacity = this.data.length * 2;
      if (newCapacity <= 1073741824) {
        ensureCapacity(newCapacity);
      }
    }
  }
{code}",,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2017-11-06 06:16:19.289,,,false,,,,,Important,,,,,,,,,9223372036854775807,,,Fri Feb 02 10:10:00 UTC 2018,,,,,,0|i372nr:,9223372036854775807,,,,,,,,"02/Dec/16 12:05;tejast5;Possible fix would be calculating threshold before putting the data in doReadObject API. 
Calculating threshold would not initialize the array by double.
Please find the code below : 

{code:java}
protected void doReadObject(ObjectInputStream in)
    throws IOException, ClassNotFoundException
  {
    this.loadFactor = in.readFloat();
    int capacity = in.readInt();
    int size = in.readInt();
    init();
    this.data = new HashEntry[capacity];
    this.threshold = calculateThreshold(this.data.length, this.loadFactor);
    for (int i = 0; i < size; i++)
    {
      Object key = in.readObject();
      Object value = in.readObject();
      put(key, value);
    }
    
  }
{code}

Why these is critical because this version of jar are been used by struts 2 . 
I saw these been changed in version 4.1 , but if you classes in 4.1 are declared in different package.
We should have provide fix for these version as we cant change jars which is internally using these stuff. 

",06/Nov/17 06:16;mingleizhang;Does anyone give me a permission that can contribute code to apache/commons ? Thank you very much! Minglei.,"06/Nov/17 15:55;garydgregory;Hi [~mingleizhang],

Please feel free to provide a pull request on GitHub with a unit test.

https://github.com/apache/commons-collections

Are you expecting that such a change would be in the 3.x AND 4.x (master) branches?

Gary","07/Nov/17 01:30;mingleizhang;Hi, [~garydgregory] I would think this change should be in 3.X, then 4.X master branches can rebase code from 3.X. As I found its affects versions is 3.1.","07/Nov/17 02:09;mingleizhang;I suspect that whether this issue belongs to a bug, instead, I think it should be a performance issue.","07/Nov/17 02:09;mingleizhang;I suspect that whether this issue belongs to a bug, instead, I think it should be a performance issue.","01/Feb/18 17:50;saleem-akbar;I also came across this problem (in my scenario I ended up with an out-of-memory error using non-sticky session replication) and also figured out the same solution, which was to to calculate the threshold before populating the data.

 

Anyway, I've submitted the following PR's for 3.2.x (we're currently using 3.2.2) and master.

[https://github.com/apache/commons-collections/pull/34]

[https://github.com/apache/commons-collections/pull/35]

 

If approved, could we please have an official 3.2.x release (at this point 3.2.3) asap?

 

Cheers

Saleem

 

 ",01/Feb/18 18:51;garydgregory;The fix has been committed to git master. I re-wrote the unit test method to use Java 7 idioms.,"02/Feb/18 10:10;saleem-akbar;Thanks :-)

",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Correction of Javadoc for org.apache.commons.collections4.functors.CatchAndRethrowClosure,COLLECTIONS-597,13013873,Bug,Resolved,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Trivial,Fixed,garydgregory,sadguten,sadguten,20/Oct/16 13:47,21/Oct/16 05:53,07/Apr/19 20:37,21/Oct/16 05:53,4.0,4.1,,,,4.2,,,Functor,,,,,,0,documentation,,,"Correct the javadoc for org.apache.commons.collections4.functors.CatchAndRethrowClosure, replacing:
CollctionUtils.forAllDo(strList, writer);
by:
CollectionUtils.forAllDo(strList, writer);
",,,,,300,300,,0%,300,300,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2016-10-21 05:53:34.639,,,false,,,,,,,,,,,,,,9223372036854775807,,,Fri Oct 21 05:53:34 UTC 2016,,,,,,0|i355kf:,9223372036854775807,,,,,,,,21/Oct/16 05:53;garydgregory;In SVN trunk.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
FileInputStream is not closed,COLLECTIONS-596,13008874,Bug,Resolved,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Won't Fix,,kal0ian,kal0ian,30/Sep/16 13:36,24/May/17 08:34,07/Apr/19 20:37,24/May/17 08:34,3.2.2,,,,,,,,,,,,,,0,,,,In ExtendedProperties class on 602 line the function load is called with input stream. I do not see anywhere stream to be closed. Is there any reason for that?,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2017-05-24 08:34:22.293,,,false,,,,,,,,,,,,,,9223372036854775807,,,Wed May 24 08:34:22 UTC 2017,,,,,,0|i34avr:,9223372036854775807,,,,,,,,"24/May/17 08:34;kinow;This class has been removed from [collections] when the 4.x version was released. See COLLECTIONS-351 for more.

The place where you can find a similar class now is [configuration], probably PropertiesConfiguration. PropertiesConfiguration also contains some calls to a load method passing an InputSteam, which is never closed... but the input stream is passed to the library by the user, so the library in this case should not close it, as users may decide to do something else with it, and are then responsible for properly handling the stream.

Marking as Won't Resolve.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
ListOrderedSet remove(),COLLECTIONS-595,13007463,Bug,Resolved,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Not A Bug,,maleven,maleven,25/Sep/16 21:08,24/May/17 09:52,07/Apr/19 20:37,24/May/17 09:52,4.1,,,,,,,,Set,,,,,,0,,,,"Hello Apache,

I have a class which overrides equals() and hashCode().
I create a ListOrderedSet<MyClass> mySet= new ListOrderedSet<MyClass>(), and add objects to it:
mySet.add(obj1);
etc.

Each object is initialized in the constructor with two properties first. The other properties are set afterwards, when
they are already contained in the ListOrderedSet. After I change/add some properties, then if I do mySet.contains(obj1), false is returned.
I read about that when a hashmap is created with the objects inside and then changing the objects inside it does not change
the hasmap's internal hashcode for the objects or something like that.

These properties are found in the equals and hashcode. (When not there is no issue.).

The following happens. If I still want to remove an object which was changed afterwards, in the method: public E remove(final int index),
inside public E remove(final int index) false is returned. But the object is still removed and in the debugger the following can be seen:

DEBUG Info:

this.collections.map.size == 5 (internal HashMap)
this.collections.setOrder.size == 4. (internal ArrayList)

Afterwards if I print the list with the overrided toString() method IndexOutOfBoundsException is thrown when getting the size of mySet
via mySet.size(), but not when I use an iterator to count the objects in the set.

{code:java}
    public int getSize() {
    	
    	OrderedIterator it = mySet.iterator();
    	int i = 0;
    	while(it.hasNext()){
    		
    		it.next();
		i++;
    		
    	}
//if i return i then the items are 4, when returning memorySet.size(), the items are 5.
//    	return i;
        return mySet.size();

    }

    @Override
    public String toString() {

        String toReturn = ""\n"";
 

        for (int i = 0; i < getSize(); i++) {


            toReturn = toReturn + mySet.get(i) + ""\n"";


        }
        return toReturn;

    }
{code}

So my question is: is this a bug or is it because of my changing/updating the objects in the list, and why if it returns false when removing it got deleted anyway?
Should it not got deleted to start with? 

Thank you for your effort.

P.S. I am a self taught programmer. It's my first time sending a bug issue, maybe it's a bit long or I did not send with it other information I should have.
","Windows 10, Eclipse Neon Release (4.6.0)",,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2016-10-28 16:57:20.091,,,false,,,,,,,,,,,,,,9223372036854775807,,,Wed May 24 09:52:13 UTC 2017,,,,,,0|i34267:,9223372036854775807,,,,,,,,"28/Oct/16 16:57;Xaerxess;If I understand correctly, you modify elements of your type {{MyClass}} after putting them into set? If so, you're violating set contract[1], which expects immutable elements (or at least in terms of equals and hashCode):

{quote}
Note: Great care must be exercised if mutable objects are used as set elements. The behavior of a set is not specified if the value of an object is changed in a manner that affects equals comparisons while the object is an element in the set. A special case of this prohibition is that it is not permissible for a set to contain itself as an element.
{quote}

[1]: https://docs.oracle.com/javase/8/docs/api/java/util/Set.html","24/May/17 09:52;kinow;+1 to [~Xaerxess]'s comment. Also think it is not a bug in the code, but rather the way you are using the class.

The class Javadoc also hints on that direction.

>This class cannot implement the List interface directly as various interface methods (notably equals/hashCode) are incompatible with a set.

Which indicates this class' behaviour is closer related to a Set, rather than a List.

Marking as not a defect and resolving the issue.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Compilation errors (generics) with JDK9,COLLECTIONS-593,12986486,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Not A Problem,,Don-vip,Don-vip,03/Jul/16 18:55,28/Mar/17 22:54,07/Apr/19 20:37,28/Mar/17 22:54,4.x,,,,,,,,,,,,,,0,generics,jdk9,josm-found,"Current codebase does not compile with JDK9 (build 125): 28 errors below.

I am not sure if this is a bug of JDK9 of a stricter compilation rule with generics.

    [javac] /var/lib/jenkins/jobs/Java-EarlyAccess-JOSM-Plugins/workspace/jdk/JDK9/apache-commons/src/org/apache/commons/collections4/BagUtils.java:98: error: incompatible types: Bag<CAP#1> cannot be converted to Bag<E>
    [javac]         return UnmodifiableBag.unmodifiableBag(bag);
    [javac]                                               ^
    [javac]   where E is a type-variable:
    [javac]     E extends Object declared in method <E>unmodifiableBag(Bag<? extends E>)
    [javac]   where CAP#1 is a fresh type-variable:
    [javac]     CAP#1 extends E from capture of ? extends E
    [javac] /var/lib/jenkins/jobs/Java-EarlyAccess-JOSM-Plugins/workspace/jdk/JDK9/apache-commons/src/org/apache/commons/collections4/CollectionUtils.java:795: error: incompatible types: Collection<CAP#1> cannot be converted to Collection<C>
    [javac]                 final Collection<C> resultCollection = collect(collection, transformer);
    [javac]                                                               ^
    [javac]   where C is a type-variable:
    [javac]     C extends Object declared in method <C>transform(Collection<C>,Transformer<? super C,? extends C>)
    [javac]   where CAP#1 is a fresh type-variable:
    [javac]     CAP#1 extends C from capture of ? extends C
    [javac] /var/lib/jenkins/jobs/Java-EarlyAccess-JOSM-Plugins/workspace/jdk/JDK9/apache-commons/src/org/apache/commons/collections4/CollectionUtils.java:1835: error: incompatible types: Collection<CAP#1> cannot be converted to Collection<C>
    [javac]         return UnmodifiableCollection.unmodifiableCollection(collection);
    [javac]                                                             ^
    [javac]   where C is a type-variable:
    [javac]     C extends Object declared in method <C>unmodifiableCollection(Collection<? extends C>)
    [javac]   where CAP#1 is a fresh type-variable:
    [javac]     CAP#1 extends C from capture of ? extends C
    [javac] /var/lib/jenkins/jobs/Java-EarlyAccess-JOSM-Plugins/workspace/jdk/JDK9/apache-commons/src/org/apache/commons/collections4/FluentIterable.java:311: error: incompatible types: FluentIterable<CAP#1> cannot be converted to FluentIterable<O>
    [javac]         return of(IterableUtils.transformedIterable(iterable, transformer));
    [javac]                  ^
    [javac]   where O,E are type-variables:
    [javac]     O extends Object declared in method <O>transform(Transformer<? super E,? extends O>)
    [javac]     E extends Object declared in class FluentIterable
    [javac]   where CAP#1 is a fresh type-variable:
    [javac]     CAP#1 extends O from capture of ? extends O
    [javac] /var/lib/jenkins/jobs/Java-EarlyAccess-JOSM-Plugins/workspace/jdk/JDK9/apache-commons/src/org/apache/commons/collections4/IterableUtils.java:429: error: incompatible types: Iterator<CAP#1> cannot be converted to Iterator<O>
    [javac]                 return IteratorUtils.transformedIterator(iterable.iterator(), transformer);
    [javac]                                                         ^
    [javac]   where O,I are type-variables:
    [javac]     O extends Object declared in method <I,O>transformedIterable(Iterable<I>,Transformer<? super I,? extends O>)
    [javac]     I extends Object declared in method <I,O>transformedIterable(Iterable<I>,Transformer<? super I,? extends O>)
    [javac]   where CAP#1 is a fresh type-variable:
    [javac]     CAP#1 extends O from capture of ? extends O
    [javac] /var/lib/jenkins/jobs/Java-EarlyAccess-JOSM-Plugins/workspace/jdk/JDK9/apache-commons/src/org/apache/commons/collections4/IterableUtils.java:833: error: no suitable method found for partition(Iterable<CAP#1>,Factory<List<O#1>>,Predicate<? super O#1>[])
    [javac]         return partition(iterable, factory, predicates);
    [javac]                ^
    [javac]     method IterableUtils.<O#1>partition(Iterable<? extends O#1>,Predicate<? super O#1>) is not applicable
    [javac]       (cannot infer type-variable(s) O#1
    [javac]         (actual and formal argument lists differ in length))
    [javac]     method IterableUtils.<O#2>partition(Iterable<? extends O#2>,Predicate<? super O#2>...) is not applicable
    [javac]       (cannot infer type-variable(s) O#2
    [javac]         (varargs mismatch; Factory<List<O#1>> cannot be converted to Predicate<? super O#2>))
    [javac]     method IterableUtils.<O#3,R>partition(Iterable<? extends O#3>,Factory<R>,Predicate<? super O#3>...) is not applicable
    [javac]       (cannot infer type-variable(s) O#3,R
    [javac]         (varargs mismatch; Predicate<? super O#1>[] cannot be converted to Predicate<? super O#3>))
    [javac]   where O#1,O#2,O#3,R are type-variables:
    [javac]     O#1 extends Object declared in method <O#1>partition(Iterable<? extends O#1>,Predicate<? super O#1>)
    [javac]     O#2 extends Object declared in method <O#2>partition(Iterable<? extends O#2>,Predicate<? super O#2>...)
    [javac]     O#3 extends Object declared in method <O#3,R>partition(Iterable<? extends O#3>,Factory<R>,Predicate<? super O#3>...)
    [javac]     R extends Collection<O#3> declared in method <O#3,R>partition(Iterable<? extends O#3>,Factory<R>,Predicate<? super O#3>...)
    [javac]   where CAP#1 is a fresh type-variable:
    [javac]     CAP#1 extends O#1 from capture of ? extends O#1
    [javac] /var/lib/jenkins/jobs/Java-EarlyAccess-JOSM-Plugins/workspace/jdk/JDK9/apache-commons/src/org/apache/commons/collections4/IterableUtils.java:873: error: no suitable method found for partition(Iterable<CAP#1>,Factory<List<O#1>>,Predicate<? super O#1>[])
    [javac]         return partition(iterable, factory, predicates);
    [javac]                ^
    [javac]     method IterableUtils.<O#2>partition(Iterable<? extends O#2>,Predicate<? super O#2>) is not applicable
    [javac]       (cannot infer type-variable(s) O#2
    [javac]         (actual and formal argument lists differ in length))
    [javac]     method IterableUtils.<O#1>partition(Iterable<? extends O#1>,Predicate<? super O#1>...) is not applicable
    [javac]       (cannot infer type-variable(s) O#1
    [javac]         (varargs mismatch; Factory<List<O#1>> cannot be converted to Predicate<? super O#1>))
    [javac]     method IterableUtils.<O#3,R>partition(Iterable<? extends O#3>,Factory<R>,Predicate<? super O#3>...) is not applicable
    [javac]       (cannot infer type-variable(s) O#3,R
    [javac]         (varargs mismatch; Predicate<? super O#1>[] cannot be converted to Predicate<? super O#3>))
    [javac]   where O#1,O#2,O#3,R are type-variables:
    [javac]     O#1 extends Object declared in method <O#1>partition(Iterable<? extends O#1>,Predicate<? super O#1>...)
    [javac]     O#2 extends Object declared in method <O#2>partition(Iterable<? extends O#2>,Predicate<? super O#2>)
    [javac]     O#3 extends Object declared in method <O#3,R>partition(Iterable<? extends O#3>,Factory<R>,Predicate<? super O#3>...)
    [javac]     R extends Collection<O#3> declared in method <O#3,R>partition(Iterable<? extends O#3>,Factory<R>,Predicate<? super O#3>...)
    [javac]   where CAP#1 is a fresh type-variable:
    [javac]     CAP#1 extends O#1 from capture of ? extends O#1
    [javac] /var/lib/jenkins/jobs/Java-EarlyAccess-JOSM-Plugins/workspace/jdk/JDK9/apache-commons/src/org/apache/commons/collections4/IteratorUtils.java:438: error: incompatible types: BoundedIterator<CAP#1> cannot be converted to BoundedIterator<E>
    [javac]         return boundedIterator(iterator, 0, max);
    [javac]                               ^
    [javac]   where E is a type-variable:
    [javac]     E extends Object declared in method <E>boundedIterator(Iterator<? extends E>,long)
    [javac]   where CAP#1 is a fresh type-variable:
    [javac]     CAP#1 extends E from capture of ? extends E
    [javac] /var/lib/jenkins/jobs/Java-EarlyAccess-JOSM-Plugins/workspace/jdk/JDK9/apache-commons/src/org/apache/commons/collections4/IteratorUtils.java:862: error: incompatible types: PeekingIterator<CAP#1> cannot be converted to Iterator<E>
    [javac]         return PeekingIterator.peekingIterator(iterator);
    [javac]                                               ^
    [javac]   where E is a type-variable:
    [javac]     E extends Object declared in method <E>peekingIterator(Iterator<? extends E>)
    [javac]   where CAP#1 is a fresh type-variable:
    [javac]     CAP#1 extends E from capture of ? extends E
    [javac] /var/lib/jenkins/jobs/Java-EarlyAccess-JOSM-Plugins/workspace/jdk/JDK9/apache-commons/src/org/apache/commons/collections4/IteratorUtils.java:878: error: incompatible types: PushbackIterator<CAP#1> cannot be converted to Iterator<E>
    [javac]         return PushbackIterator.pushbackIterator(iterator);
    [javac]                                                 ^
    [javac]   where E is a type-variable:
    [javac]     E extends Object declared in method <E>pushbackIterator(Iterator<? extends E>)
    [javac]   where CAP#1 is a fresh type-variable:
    [javac]     CAP#1 extends E from capture of ? extends E
    [javac] /var/lib/jenkins/jobs/Java-EarlyAccess-JOSM-Plugins/workspace/jdk/JDK9/apache-commons/src/org/apache/commons/collections4/IteratorUtils.java:1086: error: incompatible types: List<CAP#1> cannot be converted to List<E>
    [javac]         final List<E> list = toList(iterator, 100);
    [javac]                                    ^
    [javac]   where E is a type-variable:
    [javac]     E extends Object declared in method <E>toArray(Iterator<? extends E>,Class<E>)
    [javac]   where CAP#1 is a fresh type-variable:
    [javac]     CAP#1 extends E from capture of ? extends E
    [javac] /var/lib/jenkins/jobs/Java-EarlyAccess-JOSM-Plugins/workspace/jdk/JDK9/apache-commons/src/org/apache/commons/collections4/IteratorUtils.java:1104: error: incompatible types: List<CAP#1> cannot be converted to List<E>
    [javac]         return toList(iterator, 10);
    [javac]                      ^
    [javac]   where E is a type-variable:
    [javac]     E extends Object declared in method <E>toList(Iterator<? extends E>)
    [javac]   where CAP#1 is a fresh type-variable:
    [javac]     CAP#1 extends E from capture of ? extends E
    [javac] /var/lib/jenkins/jobs/Java-EarlyAccess-JOSM-Plugins/workspace/jdk/JDK9/apache-commons/src/org/apache/commons/collections4/ListUtils.java:394: error: incompatible types: List<CAP#1> cannot be converted to List<E>
    [javac]         return UnmodifiableList.unmodifiableList(list);
    [javac]                                                 ^
    [javac]   where E is a type-variable:
    [javac]     E extends Object declared in method <E>unmodifiableList(List<? extends E>)
    [javac]   where CAP#1 is a fresh type-variable:
    [javac]     CAP#1 extends E from capture of ? extends E
    [javac] /var/lib/jenkins/jobs/Java-EarlyAccess-JOSM-Plugins/workspace/jdk/JDK9/apache-commons/src/org/apache/commons/collections4/MapUtils.java:1272: error: incompatible types: Map<CAP#1,CAP#2> cannot be converted to Map<K,V>
    [javac]         return UnmodifiableMap.unmodifiableMap(map);
    [javac]                                               ^
    [javac]   where K,V are type-variables:
    [javac]     K extends Object declared in method <K,V>unmodifiableMap(Map<? extends K,? extends V>)
    [javac]     V extends Object declared in method <K,V>unmodifiableMap(Map<? extends K,? extends V>)
    [javac]   where CAP#1,CAP#2 are fresh type-variables:
    [javac]     CAP#1 extends K from capture of ? extends K
    [javac]     CAP#2 extends V from capture of ? extends V
    [javac] /var/lib/jenkins/jobs/Java-EarlyAccess-JOSM-Plugins/workspace/jdk/JDK9/apache-commons/src/org/apache/commons/collections4/MapUtils.java:1537: error: incompatible types: SortedMap<K,CAP#1> cannot be converted to SortedMap<K,V>
    [javac]         return UnmodifiableSortedMap.unmodifiableSortedMap(map);
    [javac]                                                           ^
    [javac]   where K,V are type-variables:
    [javac]     K extends Object declared in method <K,V>unmodifiableSortedMap(SortedMap<K,? extends V>)
    [javac]     V extends Object declared in method <K,V>unmodifiableSortedMap(SortedMap<K,? extends V>)
    [javac]   where CAP#1 is a fresh type-variable:
    [javac]     CAP#1 extends V from capture of ? extends V
    [javac] /var/lib/jenkins/jobs/Java-EarlyAccess-JOSM-Plugins/workspace/jdk/JDK9/apache-commons/src/org/apache/commons/collections4/MultiSetUtils.java:85: error: incompatible types: MultiSet<CAP#1> cannot be converted to MultiSet<E>
    [javac]         return UnmodifiableMultiSet.unmodifiableMultiSet(multiset);
    [javac]                                                         ^
    [javac]   where E is a type-variable:
    [javac]     E extends Object declared in method <E>unmodifiableMultiSet(MultiSet<? extends E>)
    [javac]   where CAP#1 is a fresh type-variable:
    [javac]     CAP#1 extends E from capture of ? extends E
    [javac] /var/lib/jenkins/jobs/Java-EarlyAccess-JOSM-Plugins/workspace/jdk/JDK9/apache-commons/src/org/apache/commons/collections4/PredicateUtils.java:537: error: incompatible types: Predicate<CAP#1> cannot be converted to Predicate<T>
    [javac]         return TransformedPredicate.transformedPredicate(transformer, predicate);
    [javac]                                                         ^
    [javac]   where T is a type-variable:
    [javac]     T extends Object declared in method <T>transformedPredicate(Transformer<? super T,? extends T>,Predicate<? super T>)
    [javac]   where CAP#1 is a fresh type-variable:
    [javac]     CAP#1 extends T from capture of ? extends T
    [javac] /var/lib/jenkins/jobs/Java-EarlyAccess-JOSM-Plugins/workspace/jdk/JDK9/apache-commons/src/org/apache/commons/collections4/QueueUtils.java:56: error: incompatible types: Queue<CAP#1> cannot be converted to Queue<E>
    [javac]         return UnmodifiableQueue.unmodifiableQueue(queue);
    [javac]                                                   ^
    [javac]   where E is a type-variable:
    [javac]     E extends Object declared in method <E>unmodifiableQueue(Queue<? extends E>)
    [javac]   where CAP#1 is a fresh type-variable:
    [javac]     CAP#1 extends E from capture of ? extends E
    [javac] /var/lib/jenkins/jobs/Java-EarlyAccess-JOSM-Plugins/workspace/jdk/JDK9/apache-commons/src/org/apache/commons/collections4/SetUtils.java:225: error: incompatible types: Set<CAP#1> cannot be converted to Set<E>
    [javac]         return UnmodifiableSet.unmodifiableSet(set);
    [javac]                                               ^
    [javac]   where E is a type-variable:
    [javac]     E extends Object declared in method <E>unmodifiableSet(Set<? extends E>)
    [javac]   where CAP#1 is a fresh type-variable:
    [javac]     CAP#1 extends E from capture of ? extends E
    [javac] /var/lib/jenkins/jobs/Java-EarlyAccess-JOSM-Plugins/workspace/jdk/JDK9/apache-commons/src/org/apache/commons/collections4/SetUtils.java:505: error: incompatible types: Iterator<CAP#1> cannot be converted to Iterator<E>
    [javac]                 return IteratorUtils.filteredIterator(a.iterator(), notContainedInB);
    [javac]                                                      ^
    [javac]   where E is a type-variable:
    [javac]     E extends Object declared in method <E>difference(Set<? extends E>,Set<? extends E>)
    [javac]   where CAP#1 is a fresh type-variable:
    [javac]     CAP#1 extends E from capture of ? extends E
    [javac] /var/lib/jenkins/jobs/Java-EarlyAccess-JOSM-Plugins/workspace/jdk/JDK9/apache-commons/src/org/apache/commons/collections4/SetUtils.java:543: error: incompatible types: Iterator<CAP#1> cannot be converted to Iterator<E>
    [javac]                 return IteratorUtils.filteredIterator(a.iterator(), containedInB);
    [javac]                                                      ^
    [javac]   where E is a type-variable:
    [javac]     E extends Object declared in method <E>intersection(Set<? extends E>,Set<? extends E>)
    [javac]   where CAP#1 is a fresh type-variable:
    [javac]     CAP#1 extends E from capture of ? extends E
    [javac] /var/lib/jenkins/jobs/Java-EarlyAccess-JOSM-Plugins/workspace/jdk/JDK9/apache-commons/src/org/apache/commons/collections4/TransformerUtils.java:187: error: incompatible types: no instance(s) of type variable(s) I#1 exist so that Transformer<I#1,CAP#1> conforms to Transformer<I#2,O#2>
    [javac]         return FactoryTransformer.factoryTransformer(factory);
    [javac]                                                     ^
    [javac]   where I#1,O#1,O#2,I#2 are type-variables:
    [javac]     I#1 extends Object declared in method <I#1,O#1>factoryTransformer(Factory<? extends O#1>)
    [javac]     O#1 extends Object declared in method <I#1,O#1>factoryTransformer(Factory<? extends O#1>)
    [javac]     O#2 extends Object declared in method <I#2,O#2>asTransformer(Factory<? extends O#2>)
    [javac]     I#2 extends Object declared in method <I#2,O#2>asTransformer(Factory<? extends O#2>)
    [javac]   where CAP#1 is a fresh type-variable:
    [javac]     CAP#1 extends O#2 from capture of ? extends O#2
    [javac] /var/lib/jenkins/jobs/Java-EarlyAccess-JOSM-Plugins/workspace/jdk/JDK9/apache-commons/src/org/apache/commons/collections4/TransformerUtils.java:235: error: incompatible types: Transformer<CAP#1,CAP#1> cannot be converted to Transformer<T,T>
    [javac]         return IfTransformer.ifTransformer(predicate, trueTransformer);
    [javac]                                           ^
    [javac]   where T is a type-variable:
    [javac]     T extends Object declared in method <T>ifTransformer(Predicate<? super T>,Transformer<? super T,? extends T>)
    [javac]   where CAP#1 is a fresh type-variable:
    [javac]     CAP#1 extends T from capture of ? extends T
    [javac] /var/lib/jenkins/jobs/Java-EarlyAccess-JOSM-Plugins/workspace/jdk/JDK9/apache-commons/src/org/apache/commons/collections4/TransformerUtils.java:428: error: incompatible types: no instance(s) of type variable(s) I#1 exist so that Transformer<I#1,CAP#1> conforms to Transformer<I#2,O#2>
    [javac]         return MapTransformer.mapTransformer(map);
    [javac]                                             ^
    [javac]   where I#1,O#1,O#2,I#2 are type-variables:
    [javac]     I#1 extends Object declared in method <I#1,O#1>mapTransformer(Map<? super I#1,? extends O#1>)
    [javac]     O#1 extends Object declared in method <I#1,O#1>mapTransformer(Map<? super I#1,? extends O#1>)
    [javac]     O#2 extends Object declared in method <I#2,O#2>mapTransformer(Map<? super I#2,? extends O#2>)
    [javac]     I#2 extends Object declared in method <I#2,O#2>mapTransformer(Map<? super I#2,? extends O#2>)
    [javac]   where CAP#1 is a fresh type-variable:
    [javac]     CAP#1 extends O#2 from capture of ? extends O#2
    [javac] /var/lib/jenkins/jobs/Java-EarlyAccess-JOSM-Plugins/workspace/jdk/JDK9/apache-commons/src/org/apache/commons/collections4/TrieUtils.java:46: error: incompatible types: Trie<K,CAP#1> cannot be converted to Trie<K,V>
    [javac]         return UnmodifiableTrie.unmodifiableTrie(trie);
    [javac]                                                 ^
    [javac]   where K,V are type-variables:
    [javac]     K extends Object declared in method <K,V>unmodifiableTrie(Trie<K,? extends V>)
    [javac]     V extends Object declared in method <K,V>unmodifiableTrie(Trie<K,? extends V>)
    [javac]   where CAP#1 is a fresh type-variable:
    [javac]     CAP#1 extends V from capture of ? extends V
    [javac] /var/lib/jenkins/jobs/Java-EarlyAccess-JOSM-Plugins/workspace/jdk/JDK9/apache-commons/src/org/apache/commons/collections4/iterators/IteratorIterable.java:118: error: incompatible types: Iterator<CAP#1> cannot be converted to Iterator<E>
    [javac]         this.typeSafeIterator = createTypesafeIterator(this.iterator);
    [javac]                                                       ^
    [javac]   where E is a type-variable:
    [javac]     E extends Object declared in class IteratorIterable
    [javac]   where CAP#1 is a fresh type-variable:
    [javac]     CAP#1 extends E from capture of ? extends E
    [javac] /var/lib/jenkins/jobs/Java-EarlyAccess-JOSM-Plugins/workspace/jdk/JDK9/apache-commons/src/org/apache/commons/collections4/multimap/TransformedMultiValuedMap.java:162: error: incompatible types: FluentIterable<CAP#1> cannot be converted to Iterable<V>
    [javac]         final Iterable<V> transformedValues = FluentIterable.of(values).transform(valueTransformer);
    [javac]                                                                                  ^
    [javac]   where V is a type-variable:
    [javac]     V extends Object declared in class TransformedMultiValuedMap
    [javac]   where CAP#1 is a fresh type-variable:
    [javac]     CAP#1 extends V from capture of ? extends V
    [javac] /var/lib/jenkins/jobs/Java-EarlyAccess-JOSM-Plugins/workspace/jdk/JDK9/apache-commons/src/org/apache/commons/imaging/util/Debug.java:125: error: incompatible types: ArrayList<CAP#1> cannot be converted to List<Object>
    [javac]         final List<Object> keys = new ArrayList<>(map.keySet());
    [javac]                                   ^
    [javac]   where CAP#1 is a fresh type-variable:
    [javac]     CAP#1 extends Object from capture of ?
    [javac] 28 errors
    [javac] 1 warning",Java 9b125,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2016-10-17 20:00:40.089,,,false,,,,,,,,,,,,,,9223372036854775807,,,Sun Jan 08 15:42:31 UTC 2017,,,,,,0|i30hcn:,9223372036854775807,,,,,,,,17/Oct/16 20:00;jglick@netbeans.org;[JDK-8075793|https://bugs.openjdk.java.net/browse/JDK-8075793] perhaps?,17/Oct/16 20:10;Don-vip;Indeed we were compiling with 1.7 option at this time. We now have switched to 1.8 option and don't have the error anymore.,21/Oct/16 05:57;garydgregory;Can this ticket be closed then?,08/Jan/17 15:42;Don-vip;yes sure!,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Deletions/insertions get lost in the ReplacementsFinder if they're at the end of the compared sequences,COLLECTIONS-592,12980680,Bug,Open,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Minor,,,Unda,Unda,19/Jun/16 22:19,20/Jun/16 07:31,07/Apr/19 20:37,,4.0,4.1,,,,,,,,,,,,,0,,,,"In the {{sequence}} package, when comparing 2 lists with a {{SequencesComparator}} and visiting the {{EditScript}} with a {{ReplacementsFinder}}, pending deletions and insertions get lost in the {{ReplacementsFinder}} when they're at the end of the sequences.

The {{ReplacementsFinder}} stores the deletions and insertions until it encounters a {{KeepCommand}}, when it flushes the pending commands by triggering the {{handleReplacement}} method of its {{ReplacementHandler}}.

The problem is, when edit commands are at the end of the sequences, the {{ReplacementsFinder}} will never encounter a {{KeepCommand}} to flush them, so they're stuck here and will never be handed over the {{ReplacementHandler}}.

To fix this behavior in client code, one can manually call {{ReplacementsFinder.visitKeepCommand(null)}} after the {{EditScript.visit()}} call.

I patched this bug in the library by adding a {{CommandVisitor.endOfVisit}} method and calling it at the end of the {{EditScript.visit}} method, so it allows to flush the pending deletions/insertions in the {{ReplacementsFinder}} when the end of the {{EditScript}} is reached.",,,,,,,,,,,,,,,,,,,19/Jun/16 22:20;Unda;ReplacementsFinder.patch;https://issues.apache.org/jira/secure/attachment/12811732/ReplacementsFinder.patch,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,Patch,,,,,,,,,9223372036854775807,,,2016-06-19 22:19:09.0,,,,,,0|i2zpnr:,9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Redundant computation in CollectionBag and CollectionSortedBag,COLLECTIONS-588,12964334,Bug,Open,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,,,monikadhok,monikadhok,02/May/16 16:18,02/May/16 16:20,07/Apr/19 20:37,,,,,,,,,,,,,,,,0,,,,"There appears to be redundant computations in ""CollectionBag.retainAll""
method in the version 4.4.1. I have attached a test and proposed a small 
patch which ensures that ""contains"" method is called on hashset of
input collection. This patch gives 892X speed up on my 
machine for the provided test.
Similar patches can be applied for, ""CollectionSortedBag.retainAll"".",,,,,,,,,,,,,,,,,,,02/May/16 16:20;monikadhok;Test1.java;https://issues.apache.org/jira/secure/attachment/12801768/Test1.java,02/May/16 16:20;monikadhok;file.patch;https://issues.apache.org/jira/secure/attachment/12801767/file.patch,,,,,,,,2.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,Patch,,,,,,,,,9223372036854775807,,,2016-05-02 16:18:51.0,,,,,,0|i2x1pz:,9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
commons-collections-3.2.2 does not compile under docker fedora21,COLLECTIONS-587,12962651,Bug,Resolved,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Won't Fix,,marcpawl@gmail.com,marcpawl@gmail.com,26/Apr/16 16:36,26/Apr/16 21:10,07/Apr/19 20:37,26/Apr/16 21:10,3.2,,,,,,,,,,,,,,0,,,,"In a clean environment using docker, compile errors

$cat Dockerfile 
FROM fedora:21 
RUN yum update -y 
RUN yum install -y java-1.8.0-openjdk unzip maven wget
RUN wget http://apache.mirror.rafal.ca//commons/collections/source/commons-collections-3.2.2-src.zip
RUN unzip commons-collections-3.2.2-src.zip
RUN cd commons-collections-3.2.2-src && mvn initialize
RUN cd commons-collections-3.2.2-src && mvn install
RUN chmod -R 755 /root
CMD /bin/bash
$docker build .
<snip/>
Downloaded: http://repo.maven.apache.org/maven2/commons-[INFO] Changes detected - recompiling the module!
[INFO] Compiling 273 source files to /commons-collections-3.2.2-src/target/classes
[INFO] -------------------------------------------------------------
[ERROR] COMPILATION ERROR : 
[INFO] -------------------------------------------------------------
[ERROR] /commons-collections-3.2.2-src/src/java/org/apache/commons/collections/MultiHashMap.java:[334,19] remove(java.lang.Object,java.lang.Object) in org.apache.commons.collections.MultiHashMap cannot implement remove(java.lang.Object,java.lang.Object) in java.util.Map
  return type java.lang.Object is not compatible with boolean
[ERROR] /commons-collections-3.2.2-src/src/java/org/apache/commons/collections/MultiMap.java:[69,19] remove(java.lang.Object,java.lang.Object) in org.apache.commons.collections.MultiMap clashes with remove(java.lang.Object,java.lang.Object) in java.util.Map
  return type java.lang.Object is not compatible with boolean
[ERROR] /commons-collections-3.2.2-src/src/java/org/apache/commons/collections/map/MultiValueMap.java:[156,19] remove(java.lang.Object,java.lang.Object) in org.apache.commons.collections.map.MultiValueMap cannot implement remove(java.lang.Object,java.lang.Object) in java.util.Map
  return type java.lang.Object is not compatible with boolean
[ERROR] /commons-collections-3.2.2-src/src/java/org/apache/commons/collections/map/MultiKeyMap.java:[200,19] remove(java.lang.Object,java.lang.Object) in org.apache.commons.collections.map.MultiKeyMap cannot implement remove(java.lang.Object,java.lang.Object) in java.util.Map
  return type java.lang.Object is not compatible with boolean
[INFO] 4 errors 
[INFO] -------------------------------------------------------------
[INFO] ------------------------------------------------------------------------
[INFO] BUILD FAILURE
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 19.104 s
[INFO] Finished at: 2016-04-26T12:35:24-04:00
[INFO] Final Memory: 19M/203M
[INFO] ------------------------------------------------------------------------
[ERROR] Failed to execute goal org.apache.maven.plugins:maven-compiler-plugin:3.3:compile (default-compile) on project commons-collections: Compilation failure: Compilation failure:
[ERROR] /commons-collections-3.2.2-src/src/java/org/apache/commons/collections/MultiHashMap.java:[334,19] remove(java.lang.Object,java.lang.Object) in org.apache.commons.collections.MultiHashMap cannot implement remove(java.lang.Object,java.lang.Object) in java.util.Map
[ERROR] return type java.lang.Object is not compatible with boolean
[ERROR] /commons-collections-3.2.2-src/src/java/org/apache/commons/collections/MultiMap.java:[69,19] remove(java.lang.Object,java.lang.Object) in org.apache.commons.collections.MultiMap clashes with remove(java.lang.Object,java.lang.Object) in java.util.Map
[ERROR] return type java.lang.Object is not compatible with boolean
[ERROR] /commons-collections-3.2.2-src/src/java/org/apache/commons/collections/map/MultiValueMap.java:[156,19] remove(java.lang.Object,java.lang.Object) in org.apache.commons.collections.map.MultiValueMap cannot implement remove(java.lang.Object,java.lang.Object) in java.util.Map
[ERROR] return type java.lang.Object is not compatible with boolean
[ERROR] /commons-collections-3.2.2-src/src/java/org/apache/commons/collections/map/MultiKeyMap.java:[200,19] remove(java.lang.Object,java.lang.Object) in org.apache.commons.collections.map.MultiKeyMap cannot implement remove(java.lang.Object,java.lang.Object) in java.util.Map
[ERROR] return type java.lang.Object is not compatible with boolean
[ERROR] -> [Help 1]
[ERROR] 
[ERROR] To see the full stack trace of the errors, re-run Maven with the -e switch.
[ERROR] Re-run Maven using the -X switch to enable full debug logging.
[ERROR] 
[ERROR] For more information about the errors and possible solutions, please read the following articles:
[ERROR] [Help 1] http://cwiki.apache.org/confluence/display/MAVEN/MojoFailureException
The command '/bin/sh -c cd commons-collections-3.2.2-src && mvn install' returned a non-zero code: 1
","docker, fedora21",,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2016-04-26 18:09:36.799,,,false,,,,,,,,,,,,,,9223372036854775807,,,Tue Apr 26 21:08:53 UTC 2016,,,,,,0|i2wrdr:,9223372036854775807,,,,,,,,"26/Apr/16 18:09;tn;Commons Collections 3.X can not be compiled with Java 8+ due to incompatible additions to the Map interface.

The conflicting methods have been renamed in Collections 4.X.","26/Apr/16 21:08;ebourg;This was fixed in Fedora 24. There is a patch available you could use to build with Java 8 in Fedora 21:

https://pkgs.fedoraproject.org/cgit/rpms/apache-commons-collections.git/tree/0001-Port-to-Java-8.patch
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
PatriciaTrie prefixMap clear throws NullPointerException,COLLECTIONS-586,12958267,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,shailender.bathula@tvnz.co.nz,shailender.bathula@tvnz.co.nz,12/Apr/16 21:59,18/Jul/17 18:56,07/Apr/19 20:37,04/Aug/16 17:33,4.1,,,,,,,,,,,,,,0,,,,"Clearing all entries of a prefixMap returned by PatriciaTrie using the {{clear}} method throws a NullPointerException. The workaround of removing each entry using the {{remove}} method seems to work.

Here are the test cases for the bug and the workaround:

{code:java}
public class PatriciaTrieTest {

    private Trie<String, Integer> trie;

    @Before
    public void setUp() {
        trie = new PatriciaTrie<Integer>();
        trie.put(""Anna"", 1);
        trie.put(""Anael"", 2);
        trie.put(""Analu"", 3);
        trie.put(""Andreas"", 4);
        trie.put(""Andrea"", 5);
        trie.put(""Andres"", 6);
        trie.put(""Anatole"", 7);
    }

    @Test
    public void testPrefixMapClear() {
        SortedMap<String, Integer> prefixMap = trie.prefixMap(""And"");
        assertEquals(new HashSet<>(Arrays.asList(""Andrea"", ""Andreas"", ""Andres"")), prefixMap.keySet());
        assertEquals(Arrays.asList(5, 4, 6), new ArrayList<>(prefixMap.values()));

        prefixMap.clear();
        assertTrue(prefixMap.keySet().isEmpty());
        assertTrue(prefixMap.values().isEmpty());
        assertEquals(new HashSet<>(Arrays.asList(""Anael"", ""Analu"", ""Anatole"", ""Anna"")), trie.keySet());
        assertEquals(Arrays.asList(2, 3, 7, 1), new ArrayList<>(trie.values()));
    }

    @Test
    public void testPrefixMapClearUsingRemove() {
        SortedMap<String, Integer> prefixMap = trie.prefixMap(""And"");
        assertEquals(new HashSet<>(Arrays.asList(""Andrea"", ""Andreas"", ""Andres"")), prefixMap.keySet());
        assertEquals(Arrays.asList(5, 4, 6), new ArrayList<>(prefixMap.values()));

        Set<String> keys = new HashSet<String>(prefixMap.keySet());
        for (final String key : keys) {
            prefixMap.remove(key);
        }
        assertTrue(prefixMap.keySet().isEmpty());
        assertTrue(prefixMap.values().isEmpty());
        assertEquals(new HashSet<>(Arrays.asList(""Anael"", ""Analu"", ""Anatole"", ""Anna"")), trie.keySet());
        assertEquals(Arrays.asList(2, 3, 7, 1), new ArrayList<>(trie.values()));
    }

}
{code}

The stacktrace of the NullPointerException thrown by the {{testPrefixMapClear}} test case is:
{noformat}
java.lang.NullPointerException
	at org.apache.commons.collections4.trie.AbstractPatriciaTrie$PrefixRangeEntrySet$EntryIterator.remove(AbstractPatriciaTrie.java:2370)
	at java.util.AbstractCollection.clear(AbstractCollection.java:432)
	at java.util.AbstractMap.clear(AbstractMap.java:288)
	at PatriciaTrieTest.testPrefixMapClear(PatriciaTrieTest.java:39)
{noformat}",,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2016-08-04 16:00:10.178,,,false,,,,,,,,,,,,,,9223372036854775807,,,Tue Jul 18 18:56:02 UTC 2017,,,,,,0|i2w0vz:,9223372036854775807,,,,,,,,"04/Aug/16 16:00;githubbot;GitHub user marko-bekhta opened a pull request:

    https://github.com/apache/commons-collections/pull/18

    COLLECTIONS-586 PatriciaTrie prefixMap clear throws NullPointerException

    added unit tests for the case mentioned in the issue and overrode clear method so it is not throwing exceptions

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/marko-bekhta/commons-collections trunk

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/commons-collections/pull/18.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #18
    
----
commit 3627b954830acbe45ea08e9e1be31738ee759422
Author: marko.bekhta <markob@prykladna.lviv.ua>
Date:   2016-08-04T15:58:18Z

    COLLECTIONS-586 PatriciaTrie prefixMap clear throws NullPointerException
    
    added unit tests for the case mentioned in the issue and overrode clear method so it is not throwing exceptions

----
",04/Aug/16 17:33;garydgregory;Please verify and close. This closes #18.,"05/Aug/16 00:29;shailender.bathula@tvnz.co.nz;Closing based on the unit tests passing in https://github.com/marko-bekhta/commons-collections 

Thanks","17/Jul/17 18:22;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/commons-collections/pull/18
","17/Jul/17 18:22;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/commons-collections/pull/18
","18/Jul/17 12:49;githubbot;Github user chtompki commented on the issue:

    https://github.com/apache/commons-collections/pull/18
  
    @marko-bekhta - Do you mind rebasing to the `master` branch, and re-opening this pull request?
","18/Jul/17 18:56;githubbot;Github user marko-bekhta commented on the issue:

    https://github.com/apache/commons-collections/pull/18
  
    Hi @chtompki there seems nothing to rebase now. The patch was copied and applied here 
    https://github.com/apache/commons-collections/commit/a270ff62852e62b5ac0f943a7e57292a72b77271
    let me know if anything else is needed. Thanks!
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"When use commons collection 3.2.2, show ""JavaSE not found""",COLLECTIONS-585,12934997,Bug,Open,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Minor,,,neal001,neal001,29/Jan/16 02:53,24/May/17 08:56,07/Apr/19 20:37,,3.2.2,,,,,,,,Collection,,,,,,0,,,,"Hi all, when i use commons-collections 3.2.2, and build my rcp application. it always show this error:
  [java] [eclipse.generateFeature] Some inter-plug-in dependencies have not been satisfied.
     [java] [eclipse.generateFeature] Bundle org.apache.commons.collections:
     [java] [eclipse.generateFeature] 	Host plug-in JavaSE_0.0.0 has not been found.

but for commons-collections 3.2.1.every thing is fine. 
and compared the 3.2.2 and 3.2.1 
Mainfest.mf file add this:
Require-Capability: osgi.ee;filter:=""(&(osgi.ee=JavaSE)(version=1.3))""
if remove it, i can build my application. 
i use jdk1.7 in my local(i also tested jdk1.8, same problem)
so i don't understand why show this problem.
i am new guy for this, if misunderstand this, sorry
",jdk1.7 commons-collections 3.2.2,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2017-05-24 08:56:09.799,,,false,,,,,,,,,,,,,,9223372036854775807,,,Wed May 24 08:56:09 UTC 2017,,,,,,0|i2s4lr:,9223372036854775807,,,,,,,,"24/May/17 08:56;kinow;Not sure how to replicate the problem. Could you test with the latest version of Commons Collections and let us know if that works, and maybe add a comment explaining how to replicate your issue? That way we might be able to help debugging the issue, though I suspect it could be an IDE or environment issue.

Thanks
Bruno",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Deserializing an AbstractHashedMap expands the hash table exponentially,COLLECTIONS-584,12921732,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Invalid,,orium,orium,14/Dec/15 18:08,14/Dec/15 22:49,07/Apr/19 20:37,14/Dec/15 18:51,4.1,,,,,,,,,,,,,,0,,,,"When deserializing an {{AbstractHashedMap}} the size of the hashtable will be doubled at each element inserted because {{threshold}} = 0, so this

{code}
protected void checkCapacity() {
        if(this.size >= this.threshold) {
            int newCapacity = this.data.length * 2;
            if(newCapacity <= 1073741824) {
                this.ensureCapacity(newCapacity);
            }
        }
    }
{code}

will always expand the hashtable.",,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2015-12-14 18:30:51.612,,,false,,,,,,,,,,,,,,9223372036854775807,,,Mon Dec 14 22:49:10 UTC 2015,,,,,,0|i2pvan:,9223372036854775807,,,,,,,,"14/Dec/15 18:30;sebb@apache.org;As far as I can tell, AbstractHashedMap does not support Serializable.

Seems to me that any serialise/deserialise code should save the map size as part of the serialisation data, in which case the map can be created with the correct size initially.

But perhaps I'm missing something here.",14/Dec/15 18:51;tn;The threshold is a transient field that is either provided or calculated from the intialCapacity. Concrete implementations of AbstractHashedMap are required to create a proper instance during de-serialization.,14/Dec/15 19:59;orium;In my scenario the problem is in the {{AbstractHashedMap}} itself: the {{calculateThreshold()}} can return 0 (I'm seeing a load factor of almost zero: 10⁻⁴¹).,14/Dec/15 20:15;tn;The AbstractHashedMap class is not serializable. Could you please provide a test case illustrating the problem you are facing?,"14/Dec/15 20:20;tn;the load factor is a *parameter* provided to the AbstractHashedMap. If you see a value like this, your de-serialization code in the derived class is broken.","14/Dec/15 22:48;orium;This was after all a bug in RuedigerMoeller/fast-serialization, where a float was incorrectly serialized, making the load factor ~= 0, leading to a threshould of zero.
",14/Dec/15 22:49;orium;See comment.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"JAVA serialization vulnerability ""CVE-2015-4852"" in commons-collections*.jar",COLLECTIONS-583,12921576,Bug,Resolved,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Duplicate,,arnoj2010,arnoj2010,14/Dec/15 07:02,14/Dec/15 07:47,07/Apr/19 20:37,14/Dec/15 07:47,,,,,,3.2.2,4.1,,,,,,,,0,,,,"The vulnerability we are talking about is known under number CVE-2015-4852. As far as we know this is only related to the 

file commons-collections*.jar. In this jar file is a class that takes care of the deserialization. 

Currently we are using commons-collections-3.2.1.jar.
Is there a version of this jar that does not have this vulnerability?",,,,,,,,,,,,,,COLLECTIONS-580,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,9223372036854775807,,,2015-12-14 07:02:15.0,,,,,,0|i2pucf:,9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maven repository metadata of Commons Collections in bad condition,COLLECTIONS-582,12914030,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Won't Fix,,veita,veita,18/Nov/15 08:00,27/Nov/15 21:47,07/Apr/19 20:37,18/Nov/15 08:05,3.2.2,,,,,,,,Core,,,,,,0,,,,"The metadata located at

https://repo1.maven.org/maven2/commons-collections/commons-collections/maven-metadata.xml

are in a bad condition.

It states that latest version and release version is 20040616. Moreover, the list of versions does not reflect the actual release order.

This makes it difficult to automatically check for new versions in our QA processes.",,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2015-11-18 08:05:53.991,,,false,,,,,,,,,,,,,,9223372036854775807,,,Wed Nov 18 10:04:38 UTC 2015,,,,,,0|i2okcf:,9223372036854775807,,,,,,,,"18/Nov/15 08:05;tn;This is unfortunate, but a mistake from the past which can not be corrected afaict.

The collections4 release has different maven coordinates, so for the newer version this should have been fixed.","18/Nov/15 09:26;ebourg;Would it be possible to ask for a modification of the metadata file? The versions deployed would remain, but maven-metadata.xml could at least point to 3.2.2 as the latest release. This happens automatically with every new release, so it's legitimate to expect that for commons-collections 3.2.2.","18/Nov/15 10:04;joehni;Not possible, it's auto-generated at central.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Deserialization and Apache Commons Collection,COLLECTIONS-581,12911814,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Invalid,markt,deepeshkapoor,deepeshkapoor,10/Nov/15 09:55,27/Nov/15 21:47,07/Apr/19 20:37,10/Nov/15 10:00,3.0,3.1,3.2.1,,,,,,Functor,,,,,,0,patch,,,"Hi Team,

This is regarding “commons-collections Java library”. In our applications we are widely using this library and hence looking to urgently patch the fix for vulnerability issue if it is available.
Searching on internet we found one patch released on Sunday 08th Nov http://svn.apache.org/viewvc?view=revision&revision=1713307

Just wanted to check with you if there is any updated / complied version of commons-collections jar available or going to be released soon which we can directly replace with our existing jar file that provides the fix for the vulnerability issue.

Thanks in advance!
",,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2015-11-10 10:00:04.388,,,false,,,,,Important,Patch,,,,,,,,9223372036854775807,,,Tue Nov 10 10:06:38 UTC 2015,,,,,,0|i2o6qn:,9223372036854775807,,,,,,,,10/Nov/15 10:00;markt;Jira is not the place to ask support questions. Please use the mailing list.,"10/Nov/15 10:06;deepeshkapoor;Thanks Mark, i have dropped an email to 'dev@commons.apache.org' and  'security@apache.org'. Kindly let me know if this is fine.


",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Arbitrary remote code execution with InvokerTransformer,COLLECTIONS-580,12911300,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,marschall,marschall,07/Nov/15 13:28,12/Jan/16 08:07,07/Apr/19 20:37,21/Nov/15 10:02,3.0,4.0,,,,3.2.2,4.1,,,,,,,,66,,,,"With {{InvokerTransformer}} serializable collections can be build that execute arbitrary Java code. {{sun.reflect.annotation.AnnotationInvocationHandler#readObject}} invokes {{#entrySet}} and {{#get}} on a deserialized collection. If you have an endpoint that accepts serialized Java objects (JMX, RMI, remote EJB, ...) you can combine the two to create arbitrary remote code execution vulnerability.

I don't know of a good fix short of removing {{InvokerTransformer}} or making it not Serializable. Both probably break existing applications.

This is not my research, but has been discovered by other people.

https://github.com/frohoff/ysoserial

http://foxglovesecurity.com/2015/11/06/what-do-weblogic-websphere-jboss-jenkins-opennms-and-your-application-have-in-common-this-vulnerability/
",,,,,,,,,,,,,,,,IO-487,KARAF-4135,,10/Nov/15 09:33;jochen@apache.org;COLLECTIONS-580.patch;https://issues.apache.org/jira/secure/attachment/12771520/COLLECTIONS-580.patch,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2015-11-08 16:55:57.872,,,false,,,,,,,,,,,,,,9223372036854775807,,,Tue Dec 08 09:14:01 UTC 2015,,,,,,0|i2o3kf:,9223372036854775807,,,,,,,,"08/Nov/15 16:55;ddossot;This vulnerability puts the whole library at risk of being vetoed in places where security is tight. If InvokerTransformer has to be kept, can it be moved to a different artifacts? Or could we have a build that doesn't contain it (like with a ""secure"" qualifier).","08/Nov/15 17:08;tn;We are currently working on a new release to address the issue.

As a solution, we prefer to introduce a new system property that controls whether the InvokerTransformer can be serialized or not. The default would be false, thus using the new version of the library will mean that any attempt to de-serialize an InvokerTransformer will result in an exception.","08/Nov/15 21:00;ddossot;This sounds great [~tn], thank you!","08/Nov/15 22:20;tn;Proposed fix committed in r1713307 for the 3.2.X branch, see here: http://svn.apache.org/viewvc?view=revision&revision=1713307","09/Nov/15 00:55;paul;Re ""r1713307 for the 3.2.X branch"" ... can the same change be cherry-picked back other major/minor branches and those re-released to 'central' too please?","09/Nov/15 08:44;joehni;Hi Paul,

we do not re-release, Thomas intends to release new version 3.2.2 only (with some additional cheep bug fixes). I don't know if we gain a lot if we also make releases for older code lines (e.g. release new 3.1.1, 3.0.1, 2.1.2 , 2.0.1 and/or 1.0.1) with this cherry-pick only. The line is supposed to be binary compatible anyway. If someone does not want to upgrade to 3.2.2, why should he consider to upgrade to one of the other ""new"" releases?

Cheers,
Jörg","09/Nov/15 08:52;tn;We will at least make also a release for the 4.x branch.

The problematic class was introduced in 3.0, so in theory we could also make a 3.0.1 and 3.1.1 bugfix release, but as Joerg pointed out users should be able to upgrade to 3.2.2.
Could you point out cases where this might not be possible?",09/Nov/15 09:01;ebourg;I think we should release the fix for COLLECTIONS-580 alone with no other modification. Otherwise people may hesitate to upgrade in fear of a regression. The other changes can be released later.,"09/Nov/15 09:08;tn;This should please be discussed on the mailinglist.
I hand-picked the bugfixes that have been backported from the 4.0 release and they only include things that are clearly wrong, and anybody using this functionality must have a broken application.","09/Nov/15 09:25;ebourg;I don't doubt you've done the things properly Thomas and I'm glad you're there to do that. My point is that from a user perspective, an update that just contains a security fix is likely to be a no-brainer, but a security update combined with other changes may trigger a full QA cycle in some development teams.
","10/Nov/15 09:25;jochen@apache.org;Alothough deserialization is the actual problem, I do thing that we should handle serialization, and deserialization in the same manner. I am attaching a suggested patch.
","10/Nov/15 09:48;ebourg;Serialization isn't an issue, I don't see the point of changing that.","10/Nov/15 09:52;jochen@apache.org;We are introducing an incompatible change. The more people know about it, the better.
","10/Nov/15 10:00;tn;Indeed, I was thinking about that as well. The point is that within the same application it does not make sense to allow serialization when de-serialization will certainly fail.
This will allow people to spot regressions earlier when using the updated jar with serialization disabled.

Furthermore, as mentioned by Chris Frohoff on the mailinglist, the following classes might be unsecure as well:

 * InstantiateFactory
 * InstantiateTransformer
 * PrototypeFactory

I think PrototypeFactory is safe: it calls clone on an object that has been de-serialized already, but for the other 2 I am not sure. Basically they allow an attacker to call an arbitrary public constructor of any class in the application's classpath. There might be a possible attack vector for it, although none is known atm.

If we add the same fix there as well, I would also suggest to change the property to enable the serialization to that: ""org.apache.commons.collections.enableUnsafeSerialization""",10/Nov/15 16:08;jglick@netbeans.org;FWIW the Jenkins project has been assuming that the whole {{org.apache.commons.collections.functors}} package is vulnerable and should be blocked from deserialization.,"10/Nov/15 19:27;drosenbauer;I think that whatever is done with InvokerTransformer should also be done with InstantiationTransformer (and the various related Factories and Closures and such). There are classes that do unsafe things in their constructors. For that matter, there may be classes that do unsafe things in their toStrings.","11/Nov/15 13:07;tn;There are also other vulnerable classes that allow an attacker to create a quite simple DOS attack.
A gadget like that will result in an infinite loop:
{code}
final Transformer[] transformers = new Transformer[] {
	new ConstantTransformer(Runtime.class),
	new ClosureTransformer(
	        new WhileClosure(TruePredicate.INSTANCE,
                new TransformerClosure(CloneTransformer.INSTANCE), false)),
{code}","13/Nov/15 12:13;karsten.klein@gmail.com;We (not having seen the attached patch before) have come up with the following solution:

{code}
    /**
     * Transforms the input to result by invoking a method on the input.
     * 
     * @param input  the input object to transform
     * @return the transformed result, null if null input
     */
    public Object transform(Object input) {
        if (input == null) {
            return null;
        }
        
        if (deserialized) {
            throw new IllegalStateException(""Transformation on deserialized object not supported. ""
                    + ""Using this function may indicate an attempted SECURITY BREACH."");
        }
        
        try {
            Class cls = input.getClass();
            Method method = cls.getMethod(iMethodName, iParamTypes);
            return method.invoke(input, iArgs);
                
        } catch (NoSuchMethodException ex) {
            throw new FunctorException(""InvokerTransformer: The method '"" + iMethodName + ""' on '"" + input.getClass() + ""' does not exist"");
        } catch (IllegalAccessException ex) {
            throw new FunctorException(""InvokerTransformer: The method '"" + iMethodName + ""' on '"" + input.getClass() + ""' cannot be accessed"");
        } catch (InvocationTargetException ex) {
            throw new FunctorException(""InvokerTransformer: The method '"" + iMethodName + ""' on '"" + input.getClass() + ""' threw an exception"", ex);
        }
    }
    
    private transient boolean deserialized = false;

    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
        in.defaultReadObject();
        deserialized = true;
    }
{code}

This approach is a little more 'compatible' and less invasive. It will only fail if transform is invoked on a deserialized object. In particular it does not fail at deserialization time. Only when the transform method is invoked. This may reduce the effects of the change.
","13/Nov/15 12:24;tn;I prefer a fail-fast approach.

btw. a successful attack will call the transform as part of the call to readObject, thus it will fail during de-serialization.","13/Nov/15 12:35;karsten.klein@gmail.com;Not sure I fully understand. The critical piece of code is always executed on a fully deserialized object. So the approach should work (or I apologize for not having understood the subject matter).

However, awareness is required on how people have to deal with this finding. The lib is very wide-spread. Thus a minimum behavior change in the software stack is preferred.

For newer versions (major/minor) I would agree to your fail-fast approach. Here I would also suggest to remove the complete Serialization feature.","13/Nov/15 13:25;tn;{quote}
Not sure I fully understand. The critical piece of code is always executed on a fully deserialized object. So the approach should work (or I apologize for not having understood the subject matter).
{quote}

I did not question your approach, I wanted to point out that in the attack vector, i.e. InvokerTransformer#transform will already be called during de-serialization (of another object).

{quote}
However, awareness is required on how people have to deal with this finding. The lib is very wide-spread. Thus a minimum behavior change in the software stack is preferred.
{quote}

We are trying to do this, but the rationale is as follows: if an application uses the unsafe classes in a legit way, i.e. will de-serialize them from a trusted source, the application will most likely also *use* these objects in a way or another. It means that the application will fail in any way, but it will be easier to spot/fix if it happens already during the de-serialization, but please correct me if you have a use-case where your approach would be more suitable.

{quote}
For newer versions (major/minor) I would agree to your fail-fast approach. Here I would also suggest to remove the complete Serialization feature.
{quote}

This is indeed the plan, for the 4.1 release we will hopefully remove the Serializable interface from the unsafe classes.",13/Nov/15 20:10;tn;Committed in r1714262 for collections4: unsafe classes do not implement the Serializable interface anymore.,13/Nov/15 21:03;tn;The new MultiValuedMap in collections4 uses internally an InstantiateFactory which is serialized. Need to find a better solution for this before we can resolve the issue.,14/Nov/15 09:56;tn;In collections4 there is also an inner factory class in MultiValueMap that is serializable. This can be solved with a readObject method that checks whether the de-serialized class extends Collection.,14/Nov/15 20:25;tn;Fixed MultiValueMap issue in r1714360.,"16/Nov/15 10:22;rchamarthy;Hi,

Would be interested to know an estimated data on the availability the commons collections with the fix.

Advance Thanks,
Ravi Chamarthy","16/Nov/15 10:42;tn;collections 3.2.2 has been released yesterday.

A new release for collections4 will be done this week hopefully.",16/Nov/15 11:38;rchamarthy;Thanks Thomas for the confirmation.,16/Nov/15 12:39;schudel;Thanks Thomas for the quick fix,16/Nov/15 21:56;yoderme;Let me also extend my thanks for the fix. Question: is there an assigned CVE number for this? I couldn't find one after a quick search.,"17/Nov/15 14:48;Stevie Beck;+1 (thanks for the fix!)
Regarding CVE number: Mitre did not (yet?) assign one, and there has been a controversial discussion in the OSS Security list around it, see: http://seclists.org/oss-sec/2015/q4/280
CVE-2015-4852 was assigned by Oracle and is started to be used by other vendors, whose products are impacted by the issue.","18/Nov/15 14:50;tdaitx;According to CVE assignment team [1] no CVE ID will be allocated for this issue and:

""The CVE-2015-4852 ID came from Oracle and must remain associated only with Oracle's own software (WebLogic Server is the product they've named).""

but then Oracle's Thomas Keefe reply [1] to that thread stated:

""We do not have a problem with this use of the CVE# we registered (CVE-2015-4852).""

[1] http://www.openwall.com/lists/oss-security/2015/11/17/19
[2] http://www.openwall.com/lists/oss-security/2015/11/18/1","19/Nov/15 06:22;taromaru;I used commons-collections-3.2.2.

ForClosure and WhileClosure can not deserialize.
But, ChainedTransformer can deserialize.
A DoS attack similar to an infinite loop becomes possible by the following way.

{code:java}
	HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();
	for (int i = Integer.MIN_VALUE + 1; i <= Integer.MIN_VALUE + 10; i++) {
		map.put(i, i);
	}
	Transformer constantTransformer = ConstantTransformer.getInstance(map);
	Transformer stringValueTransformer = StringValueTransformer.getInstance();
	Transformer transformerChain = ChainedTransformer.getInstance(constantTransformer, stringValueTransformer);
	for (int i = 0; i < 10; i++) {
		Transformer[] transformers = new Transformer[10];
		Arrays.fill(transformers, transformerChain);
		transformerChain = ChainedTransformer.getInstance(transformers);
	}
{code}

This serialized file size is less than 2KB.
But it takes 6~7 hours for deserialize. (Core i5 CPU)

I think the similar way is also possible in ChainedClosure, AllPredicate, AnyPredicate.

When other class of org.apache.commons.collections.functors package was used,
it was possible to make OutOfMemoryError occur.

I think all classes of org.apache.commons.collections.functors package should call FunctorUtils#checkUnsafeSerialization.
","19/Nov/15 08:03;tn;Hmm I feared that it would be too easy to create other, similar exploits with still serializable classes.

btw. for the same DOS attack, the guava lib might be exploitable as well. The lib also provides predicates and functions that can be chained in a way or another and are serializable.","19/Nov/15 10:58;Stevie Beck;This reminds me of the the general ""SerialDoS"" code, published here: https://gist.github.com/coekie/a27cc406fc9f3dc7a70d
I am not THAT Java expert, so I just assume, that any application that allows deserialization from untrusted input, can be DoS'ed - regardless what libraries are included in the classpath.
Just creation of code execution needs more investigation and creativity and the need to find suitable gadgets...","19/Nov/15 23:09;tn;In the collections4 branch, the MultiValuedMap implementations do not use the InstantiateFactory anymore.
Committed in r1715302. This required a huge refactoring effort, but should definitely be safer as no reflection is used anymore.","21/Nov/15 00:19;yoderme;""No reflection is used anymore"" sounds like a really good thing. Might I ask when you expect a release of collecions4 to be out?  Thanks!",21/Nov/15 06:16;tn;in the next days hopefully.,21/Nov/15 10:02;tn;Closing this issue as it is fixed in both branches.,24/Nov/15 13:49;schudel;Any info on when commons-collections 4.1 will be released?,"24/Nov/15 16:07;tn;the release has been prepared, currently the vote is ongoing.","02/Dec/15 14:45;mceli;[~tn] Is this issue also present in Apache Commons Collection v3.1? I see that the affected versions listed on the details as 3.0, 4.0.
","02/Dec/15 15:51;tn;All 3.X releases and the 4.0 release are affected.

For the 3.X branch we have released 3.2.2 to which all users of the 3.X branch are encouraged to upgrade.
For the 4.X branch we have released 4.1 (same as above applies).",02/Dec/15 15:58;mceli;Thank you for your prompt response!,08/Dec/15 06:07;sunnykumar;[~tn] Is commons-collections 2.x library affected by this vulnerability ?. I can see there is no functions package inside the 2.x jar.,"08/Dec/15 07:58;tn;The collections 2.x branch is not affected.

@all the issue tracker is no discussion forum, please use the user/dev mailinglist for questions. Furthermore this issue is closed, I will not answer anything here anymore.","08/Dec/15 09:14;joehni;THIS IS NOT A HELP FORUM! If you have questions, go ask on the user's list!

(Note, this was a reply to a comment that has been deleted afterwards by its original author)."
PassiveExpiringMap doesn't work when the key is a byte array,COLLECTIONS-579,12910338,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Invalid,,rabit,rabit,04/Nov/15 12:48,27/Nov/15 21:47,07/Apr/19 20:37,04/Nov/15 13:19,4.0,,,,,,,,Map,,,,,,0,,,,"When you put a (key,value) pair in a PassiveExpiringMap and the key is byte[] you can't retrieve it.

Code to reproduce the problem:

byte[] key = {0,0,0,1};
PassiveExpiringMap<byte[],byte[]> map = new PassiveExpiringMap<byte[],byte[]> ();
map.put(key,key);

byte[] queryKey = {0,0,0,1};
//this should be true
map.containsKey(queryKey) == false

","GNU/Linux Ubuntu 15.10 64 bits, OpenJDK 1.8.0_65",,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2015-11-04 13:19:47.903,,,false,,,,,Important,,,,,,,,,9223372036854775807,,,Thu Nov 05 15:26:58 UTC 2015,,,,,,0|i2nxsf:,9223372036854775807,,,,,,,,"04/Nov/15 13:19;tn;A plain array can not be used as-is in collection-like classes.

The reason for this is that an Array will use the default hashCode implementation from Object which means its hashcode depends on its reference. You can test the same example and replace the PassiveExpiringMap with a normal HashMap and you will get the same behavior just because the hashCode for key and queryKey will be different.

In order to use arrays in a Map you will need a wrapper that properly implements hashCode and equals by using e.g. the functions available in the Arrays class.","05/Nov/15 15:26;rabit;Yes, thank you for pointing this out. I don't know how it's never bitten me before. Sorry for the trouble. Here is the code I should have used first:

{code:title=ByteArray.java|borderStyle=solid}
public class ByteArray {
	private volatile int hashCode = 0;
	private byte[] bytes = null;
	private final Object lock = new Object();

	public ByteArray(byte[] bytes) {
		 this.bytes = bytes;
 	}

        /**
       * Redefine the backing array
       * @param bytes original array
       */
       public void set(byte[] bytes) {
	 synchronized (lock) {
  	 this.bytes = bytes;
	 hashCode = 0;
       }
	}
	
	/**
	 * @return original backing array
	 */
	public byte[] get(){
		return bytes;
	}

	@Override
	public int hashCode() {
   		synchronized (lock) {
			if (hashCode == 0) {
				int hash = 11;
				hashCode = 29 * hash + Arrays.hashCode(this.bytes);
			}
		}
		return hashCode;
	}

	@Override
	public boolean equals(Object obj) {
		if (obj == null) {
			return false;
		}
		if (getClass() != obj.getClass()) {
			return false;
		}
		final ByteArray other = (ByteArray) obj;
		if (!Arrays.equals(this.bytes, other.bytes)) {
			return false;
		}
		return true;
	}
}
{code}",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
PatriciaTrie bugs when only a few bits change,COLLECTIONS-577,12896510,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Critical,Duplicate,,veqryn,veqryn,25/Sep/15 22:27,27/Nov/15 21:47,07/Apr/19 20:37,28/Sep/15 09:45,4.0,,,,,4.1,,,Map,,,,,,0,,,,"I have a bug report for you, for the class AbstractPatriciaTrie.  
It has to do with how you handle bits when they are very close to each other.  
For example, some of your methods seem to think that if the only difference between a prefix and a longer string, is a single additional bit, then they are actually the same data.  Or if the only difference is some number of zero bits, then it also thinks they are the same data.  
There are also MANY situations where the prefixMap does not return all the strings that start with the prefix.

Can you also make AbstractPatriciaTrie public, and your other package level methods into protected level, that way I don't have to copy the entire class and subclasse's code out into another class just to extend it?

thank you,
Chris Duncan (github user: VEQRYN)
",,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2015-09-25 22:47:30.632,,,false,,,,,,,,,,,,,,9223372036854775807,,,Mon Sep 28 09:45:19 UTC 2015,,,,,,0|i2ll0f:,9223372036854775807,,,,,,,,"25/Sep/15 22:47;adrianc@hlmksw.com;Please don't put pages of text in the issue description. It uses a lot of bandwith and makes reading email notifications difficult. The description should contain a brief description of the problem, and code examples should go in the comments.","25/Sep/15 22:51;veqryn;Sorry, didn't know that. Should I move the code to comments now, or would that be worse since it would just make a new email?","25/Sep/15 22:53;adrianc@hlmksw.com;That would be helpful, thanks. I tried doing that myself, but I don't have permission to edit the description.","25/Sep/15 22:56;veqryn;Take the following code for example, which shows the bugs happening in a very simple context.
I create two strings.  The first string is always a prefix of the second string.  Here are the characters I am using:
{code}
    final char u0000 = Character.toChars(0)[0]; // U+0000 (0000000000000000)
    final char u0001 = Character.toChars(1)[0]; // U+0001 (0000000000000001)
    final char u8000 = Character.toChars(32768)[0]; // U+8000 (1000000000000000)
    final char uffff = Character.toChars(65535)[0]; // U+FFFF (1111111111111111)
    final char char_b = 'b'; // 1100010
    final char char_c = 'c'; // 1100011
    final PatriciaTrie<String> trie = new PatriciaTrie<>();
{code}

And here is a quick example of the trie working correctly, showing how it should work:
{code}
    final String prefixString = """" + char_b;
    final String longerString = prefixString + char_c;
    System.out.println(trie.prefixMap(prefixString)); // {b=prefixString, bc=longerString} // correct!
{code}

In the first example, I show that a character who's bits are all zeros is always mishandled:
{code}
    final String prefixString = """" + char_b;
    final String longerString = prefixString + u0000;

    System.out.println(prefixString);
    System.out.println(prefixString.length()); // 1

    System.out.println(longerString);
    System.out.println(longerString.length()); // 2

    System.out.println(longerString.startsWith(prefixString)); // true

    trie.put(prefixString, ""prefixString"");
    System.out.println(trie); // prefixString is in

    trie.put(longerString, ""longerString"");
    System.out.println(trie); // only longerString shown... prefixString has disappeared

    System.out.println(trie.prefixMap(prefixString).size()); // prints 1, but should be 2
    System.out.println(trie.prefixMap(prefixString)); // {b =longerString} // prefixString should be here, but isn't

    trie.put(prefixString, ""prefixString"");
    System.out.println(trie); // prefixString is in again, but longerString has now disappeared

    System.out.println(trie.prefixMap(prefixString).size()); // prints 1, but should be 2
    System.out.println(trie.prefixMap(prefixString)); // {b=prefixString} // longerString should be here, but isn't
{code}

Next, I show that if the longer string is only 1 bit longer (ignoring zeros) than the prefix string, then the PatriciaTree fails to include it in the prefix map.
Here the string would look like: 0000000001100011 1000000000000000
{code}
    final String prefixString = """" + char_c;  // you can use any character for the prefix, same results
    final String longerString = prefixString + u8000;

    System.out.println(prefixString);
    System.out.println(prefixString.length()); // 1

    System.out.println(longerString);
    System.out.println(longerString.length()); // 2

    System.out.println(longerString.startsWith(prefixString)); // true

    trie.put(prefixString, ""prefixString"");
    System.out.println(trie); // prefixString is in

    trie.put(longerString, ""longerString"");
    System.out.println(trie); // both are in

    System.out.println(trie.prefixMap(prefixString).size()); // prints 1, but should be 2
    System.out.println(trie.prefixMap(prefixString)); // {c=prefixString} // longerString should be here, but isn't
{code}

And again, except flipping it so that the prefix ends with a 1, and the longer string starts with 1's:
{code}
    final String prefixString = """" + u0003;
    final String longerString = prefixString + u8000; // can also use uffff here, same result

    System.out.println(prefixString);
    System.out.println(prefixString.length()); // 1

    System.out.println(longerString);
    System.out.println(longerString.length()); // 2

    System.out.println(longerString.startsWith(prefixString)); // true

    trie.put(prefixString, ""prefixString"");
    System.out.println(trie); // prefixString is in

    trie.put(longerString, ""longerString"");
    System.out.println(trie); // both are in

    System.out.println(trie.prefixMap(prefixString).size()); // prints 1, but should be 2
    System.out.println(trie.prefixMap(prefixString)); // {c=prefixString} // longerString should be here, but isn't
{code}

The class is honestly pretty complex and I wasn't able to completely debug why this is behaving badly, but I believe it is because of how you are handling the ""bitIndex"" and ""bitLength"".
For example, in the method AbstractPatriciaTrie .subtree(), my comments in bold (this definitely isn't the only place with weird handling of bitIndex and lengthInBits):
{code}
    TrieEntry<K, V> subtree(final K prefix, final int offsetInBits, final int lengthInBits) {
        TrieEntry<K, V> current = root.left;
        TrieEntry<K, V> path = root;
        while(true) {
// If our bit index has only increased by 1, then our bitIndex will never get to be greater than lengthInBits, we could still start with the prefix, yet we have no way to break out of here with current being set to the longer string.
            if (current.bitIndex <= path.bitIndex || lengthInBits < current.bitIndex) {
                break;
            }
            path = current;
            if (!isBitSet(prefix, offsetInBits + current.bitIndex, offsetInBits + lengthInBits)) {
                current = current.left;
            } else {
                current = current.right;
            }
        }
      ...
{code}","26/Sep/15 10:56;tn;I just quickly tested your code snippets, but this problem should already be fixed in trunk.

The problems with truncated output is most likely related to adding u0000 to the string which is a native string terminator in c.","28/Sep/15 09:45;tn;In r1705637, I have added additional testcases for a Trie.

The problem has already been fixed by COLLECTIONS-525.

Thanks for the report and tests!",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
MultiKey subclassing has deserialization problem since COLLECTIONS-266: either declare protected readResolve() or MultiKey must be final,COLLECTIONS-576,12861500,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,stephanroch,stephanroch,03/Sep/15 08:44,27/Nov/15 21:11,07/Apr/19 20:37,28/Sep/15 08:54,4.0,,,,,4.1,,,KeyValue,,,,,,0,,,,"MultiKey from collections 4 provides a transient hashCode and a *private* readResolve to resolve COLLECTIONS-266: Issue with MultiKey when serialized/deserialized via RMI.

Unfortunately the solution does not work in case of *subclassing*: readResolve in MultiKey should be declared *protected* readResolve() to be called during deserialization of the subclass. Otherwise MultiKey must be final to avoid such subclassing.

*Testcase*:
{code:java|title=MultiKeySerializationTest.java}
package de.ivu.test.common.collections4;

import static org.junit.Assert.assertEquals;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;

import org.apache.commons.collections4.keyvalue.MultiKey;
import org.junit.Test;

public class MultiKeySerializationTest {

    @Test
    @SuppressWarnings(""unchecked"")
    public void testReadResolveEqualHashCode()
            throws IOException, ClassNotFoundException {
        class MultiKey2<A, B>
                extends MultiKey {

            private static final long serialVersionUID = 1928896152249821416L;

            public MultiKey2(A key1, B key2) {
                super(key1, key2);
            }

            public A getFirst() {
                return (A) getKey(0);
            }

            public B getSecond() {
                return (B) getKey(1);
            }
            
            // FIXME: MultiKey should either declare protected readResolve() or must be final.
        }
        MultiKey2<String, String> one = new MultiKey2<>(""bla"", ""blub"");
        System.out.println(one.hashCode());
        ByteArrayOutputStream byteOut = new ByteArrayOutputStream();
        ObjectOutputStream out = new ObjectOutputStream(byteOut);
        out.writeObject(one);
        out.close();
        byte[] serialized = byteOut.toByteArray();
        ByteArrayInputStream byteIn = new ByteArrayInputStream(serialized);
        ObjectInputStream in = new ObjectInputStream(byteIn);
        MultiKey2<String, String> two = (MultiKey2<String, String>) in.readObject();
        System.out.println(two.hashCode());
        assertEquals(""hashCode must be equal - please check for protected readResolve in MultiKey*"", one.hashCode(),
            two.hashCode());
    }
}
{code}

*Fix:*
{code:java|title=MultiKey.java}
@@ -274,7 +274,7 @@
      * only stable for the same process).
      * @return the instance with recalculated hash code
      */
-    private Object readResolve() {
+    protected Object readResolve() {
         calculateHashCode(keys);
         return this;
     }
{code}",,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2015-09-28 08:54:20.421,,,false,,,,,,,,,,,,,,9223372036854775807,,,Mon Sep 28 08:54:20 UTC 2015,,,,,,0|i2jqh3:,9223372036854775807,,,,,,,,"28/Sep/15 08:54;tn;Fixed in r1705620.

Thanks for the report and testcase.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
All decorators shall throw a NullPointerException if the decorated argument is null,COLLECTIONS-570,12839496,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Minor,Fixed,,tn,tn,22/Jun/15 09:50,27/Nov/15 21:11,07/Apr/19 20:37,22/Jun/15 13:02,4.0,,,,,4.1,,,,,,,,,0,,,,"To be consistent, the constructor shall throw a NullPointerException instead of a IllegalArgumentException if the argument is null.",,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,9223372036854775807,,,Mon Jun 22 13:02:48 UTC 2015,,,,,,0|i2gbtb:,9223372036854775807,,,,,,,,22/Jun/15 13:02;tn;Fixed in r1686855.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
IteratorUtils.collatedIterator do not use natural ordering if no comparator was provided,COLLECTIONS-566,12835517,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,tn,tn,04/Jun/15 20:19,27/Nov/15 21:11,07/Apr/19 20:37,04/Jun/15 20:36,4.0,,,,,4.1,,,,,,,,,0,,,,"In case a null comparator was provided natural ordering should be used, as stated in the javadoc.

In fact an exception is thrown the first time the returned iterator is used.",,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,9223372036854775807,,,Thu Jun 04 20:36:34 UTC 2015,,,,,,0|i2fnj3:,9223372036854775807,,,,,,,,04/Jun/15 20:36;tn;Fixed in r1683631.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"Objects which are not of type V can be placed in a MultiValueMap<K,V>.",COLLECTIONS-559,12787445,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Invalid,,peturingi,peturingi,01/Apr/15 19:26,01/Apr/15 19:41,07/Apr/19 20:37,01/Apr/15 19:41,4.0,,,,,,,,KeyValue,,,,,,0,,,,"I declared a MultiValueMap as this:
{code}
MultiValueMap<Integer, Path> duplicates = new MultiValueMap<Integer, Path>();
{code}

Elsewhere in code I doing (by accident) something in this direction
{code}
duplicates.put(number, new LinkedList<Path>());
{code}

Exceptions were being thrown when values returned from the list could not be assigned to variables of type Path.

{code:title=org.apache.commons.collections4.map.MultiValueMap.java}
public Object put(final K key, final Object value) {
...
{code}
I propose that Object in the above decleration is changed to T.","java version ""1.8.0_25""
Java(TM) SE Runtime Environment (build 1.8.0_25-b17)
Java HotSpot(TM) 64-Bit Server VM (build 25.25-b02, mixed mode)
OS X 10.10",,,,600,600,,0%,600,600,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,9223372036854775807,,,2015-04-01 19:26:34.0,,,,,,0|i27nsv:,9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
ListOrderedSet#remove(int) should return E instead of Object,COLLECTIONS-558,12785536,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,frabe,frabe,25/Mar/15 14:46,27/Nov/15 21:11,07/Apr/19 20:37,25/Mar/15 16:03,4.0,,,,,4.1,,,Set,,,,,,0,,,,"Since {{List#remove(int)}} returns {{E}} the implementation in {{ListOrderedSet}} should also return {{E}}.

Minimal example that fails to compile:
{code:java}
ListOrderedSet<String> los = new ListOrderedSet<String>();
los.add(""foo"");
String s = los.remove(0);
{code}",,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2015-03-25 16:03:04.611,,,false,,,,,,,,,,,,,,9223372036854775807,,,Wed Mar 25 21:40:16 UTC 2015,,,,,,0|i27c8f:,9223372036854775807,,,,,,,,"25/Mar/15 16:03;tn;Fixed in r1669140.

Thanks for the report!","25/Mar/15 21:40;frabe;Well, thank you for your work and thanks for the Apache Commons Collections :)",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Undefined NullPointerException in TreeBag.java,COLLECTIONS-555,12775413,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Minor,Fixed,,mjkim0324,mjkim0324,16/Feb/15 17:03,27/Nov/15 21:11,07/Apr/19 20:37,17/Feb/15 22:03,4.1,,,,,4.1,,,Bag,,,,,,0,,,,"In add(final E object) method of TreeBag.java, the parameter object is not null-checked in throw IlligalArgumentException statement. Thus, it crashes with an inappropriate type of exceptions when the parameter, object is null. object can be null from the argument, transform(object) in TransformedCollection.add(final E object).
I think object ==null should be added in the predicate of the throw IlligalArgumentException statement like below.

{code}
    public boolean add(final E object) {
        if((object==null) || (comparator() == null && !(object instanceof Comparable))) {
            throw new IllegalArgumentException(""Objects of type "" + object.getClass() + "" cannot be added to "" +
                                               ""a naturally ordered TreeBag as it does not implement Comparable"");
        }
        return super.add(object);
    }
{code}",,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2015-02-17 22:03:17.244,,,false,,,,,,,,,,,,,,9223372036854775807,,,Tue Feb 17 22:03:17 UTC 2015,,,,,,0|i25oqv:,9223372036854775807,,,,,,,,"17/Feb/15 22:03;tn;Updated javadoc in r1660515.

Thanks for the report!",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
NullPointerException in CollectionUtils.partition,COLLECTIONS-554,12775406,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Minor,Invalid,,mjkim0324,mjkim0324,16/Feb/15 16:33,27/Nov/15 21:47,07/Apr/19 20:37,07/Apr/15 12:41,4.1,,,,,,,,Collection,,,,,,0,,,,"NullPointerException (NPE) is not suitably handled in CollectionUtils.partition. With a nullFactory, partitions.get(numberOfPredicates) can be null at line partitions.get(numberOfPredicates).add(element);.

Stack trace:
{code}
test(Test)java.lang.NullPointerException
        at org.apache.commons.collections4.CollectionUtils.partition(CollectionUtils.java:1187)
        at Test.test(Test.java:18)
{code}

Test case:
{code}
public void test() {
  Collection input = CollectionUtils.permutations((java.util.Collection)new CircularFifoQueue(10));
  Factory factory = FactoryUtils.nullFactory();
  NullIsFalsePredicate p = new NullIsFalsePredicate(NullPredicate.nullPredicate());
  Predicate[] predicates = p.getPredicates();
  CollectionUtils.<java.lang.Object,java.util.Collection>partition((java.lang.Iterable)input, factory, predicates);
}


{code}",,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2015-02-16 18:56:58.284,,,false,,,,,,,,,,,,,,9223372036854775807,,,Tue Apr 07 12:41:10 UTC 2015,,,,,,0|i25opb:,9223372036854775807,,,,,,,,"16/Feb/15 18:56;tn;It is mandatory that the provided factory create non-null collections, anything else is not meaningful.

Would do you suggest shall happen in this case other than a NullPointerException?","17/Feb/15 14:42;mjkim0324;Yes, when I call 
CollectionUtils.<java.util.Collection>partition((java.lang.Iterable)input, predicates); without a factory argument,
I get a ClassCastException: org.apache.commons.collections4.multimap.MultiValuedHashMap cannot be cast to java.util.Collection with the same arguments.
","07/Apr/15 12:41;tn;Providing a factory that returns null objects does not make sense, and throwing a NPE in this case is reasonable imho.

The second comment: a MultiValuedHashMap is *not* a java.util.Collection, thus can not be used for the partition method.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
TransformedMultiValuedMap.equals() fails when comparing the value with itself,COLLECTIONS-553,12775398,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,mjkim0324,mjkim0324,16/Feb/15 16:09,27/Nov/15 21:11,07/Apr/19 20:37,07/Apr/15 11:41,4.0,,,,,4.1,,,Map,,,,,,0,,,,"TransformedMultiValuedMap.equals() does not return true when comparing a value of a Collection key with itself. Is it allowed to put Collection as a key in TransformedMultiValuedMap at all? If not, I think it should be specified in the document. Or, equals() should be fixed accordingly. 

Reproduce step
{code:title=Test.java|borderStyle=solid}
public void test()
{
  TransformedMultiValuedMap map = TransformedMultiValuedMap.transformingMap((MultiValuedMap)new MultiValuedHashMap(),TransformerUtils.stringValueTransformer(),  TransformerUtils.stringValueTransformer());
  
  MultiValuedHashMap helperMap = new MultiValuedHashMap();
  helperMap.put(""KEY"", ""Value"");
  Collection key = helperMap.keySet();
  map.put(key, ""Hi"");
  Collection value = map.get(key);
  assertTrue(""Contract failed: value.equals(value)"", value.equals(value));
}
{code}",,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2015-04-07 11:41:46.44,,,false,,,,,,,,,,,,,,9223372036854775807,,,Tue Apr 07 11:41:46 UTC 2015,,,,,,0|i25onj:,9223372036854775807,,,,,,,,07/Apr/15 11:41;tn;Problem solved after fixing COLLECTIONS-543.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Performance issue in CompositeCollection::retainAll,COLLECTIONS-548,12769127,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Minor,Won't Fix,,oswaldo_o,oswaldo_o,21/Jan/15 21:50,27/Nov/15 21:47,07/Apr/19 20:37,24/Jan/15 12:59,4.0,,,,,,,,Collection,,,,,,0,performance,,,"There seems to be a performance problem with the function retainAll of 
CompositeCollection. This is analogous to https://issues.apache.org/jira/browse/COLLECTIONS-534 .

The following is the code of the function:

{code}
 
    /**
     * Retains all the elements in the specified collection in this composite collection,
     * removing all others.
     * <p>
     * This implementation calls <code>retainAll()</code> on each collection.
     *
     * @param coll  the collection to remove
     * @return true if the collection was modified
     * @throws UnsupportedOperationException if retainAll is unsupported
     */
    public boolean retainAll(final Collection<?> coll) {
        boolean changed = false;
        for (final Collection<E> item : all) {
            changed |= item.retainAll(coll);
        }
        return changed;
    }


{code}

The performance problem occurs when the underlying collections in the current collection have a slow retainAll method. Whenever we're relying on Collection::retainAll, slow cases tend to occur when the parameter collection has a slow contains method.

The following test harness shows the performance degradation between 
using a list and using a set as a parameter, across different collection sizes.

{code}
 public static void 	compositeCollectionRetainAllTest(boolean original) {

	int N=500000;

	ArrayList<Integer> firstArrayList=new ArrayList<Integer>();
	ArrayList<Integer> secondArrayList=new ArrayList<Integer>();

	for(int i=0;i<N;++i) {

	    firstArrayList.add(new Integer(i));
	    secondArrayList.add(new Integer(N-1-i));
	    
	}
	CompositeCollection col = new CompositeCollection(firstArrayList);

	col.retainAll(original ? secondArrayList : (new HashSet<Integer>(secondArrayList)));
	

    }


{code}

In the following table ""Original"" corresponds to the time taken by 
the existing implementation of CompositeCollection::retainAll, ""Repaired"" to the time taken by the function invoked with the parameter converted into a set, and ""Speed-up"" to the speed-up obtained after the repair.

N		Original(s)	Repaired(s)	Speed-up(X)

10	         1.04		1.04		        1.00
100	         1.04		1.05		        0.99
1000	1.06		        1.06		        1.00
10000	1.12		        1.10		        1.01
100000	9.34		        1.15		        8.12
500000	> 300		1.29		        > 232.55


If it's unacceptable to convert the parameter into a set before calling 
retainsAll, a solution would be to include a warning to the user in the documentation that the parameter should have a fast contains method when possible.
",Ubuntu 14.04,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2015-01-24 12:59:07.43,,,false,,,,,,,,,,,,,,9223372036854775807,,,Sat Jan 24 15:48:02 UTC 2015,,,,,,0|i24n0n:,9223372036854775807,,,,,,,,"22/Jan/15 00:04;oswaldo_o;Here's another potential fix by using a more efficient retainAll method in the spirit of CollectionUtils::containsAll


{code}
------------------------------------------------------------

    // Eliminates from coll1 all elements that are not in coll2.
    // It runs in O(m+n) size, requiring additional O(m) space.
    public static boolean efficientRetainAll(final Collection<?> coll1,final Collection<?> coll2) {

	// If coll2 is empty there are no elements to retain.
	if(coll2.isEmpty()) {
	    return coll1.removeAll(coll1);
	}

	// Simple case when we're supposed to retain all elements
	// in the first collection.
	if(coll1==coll2)
	    return false;
	
	// it1 iterates over coll1 and it2 iterares over coll2,
	// and seen contains all the elements before it2, allowing 
	// us to never revisit previous elements.
	// The algorithm iterates through it1, checks to see if we've 
	// already seen the current element of it1 via a Hashset 
	// efficient check, or traverses elements of it2 until we find 
	// it or it2 ends. At each iteration over it2 we add the
	// elements to seen to avoid revisiting items.
	Iterator<?> it1 = coll1.iterator();
	Iterator<?> it2 = coll2.iterator();
	HashSet<Object> seen = new HashSet<Object>();
	boolean changed=false;
	// Traverse all the elements in coll1.
	while(it1.hasNext()) {
	    final Object o=it1.next();
	    // If we've seen this element in coll2, keep it.
	    if(seen.contains(o))
		continue;
	    // Otherwise, check for its containment in coll2, while
	    // adding the elements to seen.
	    boolean contained=false;
	    while(it2.hasNext()) {
		final Object o2=it2.next();
		seen.add(o2);
		// Found the element in coll2.
		if(o2.equals(o)) {
		    contained=true;
		    break;
		}
	    }
	    // If the element was not found in coll2, remove it from it1.
	    if(!contained) {
		changed=true;
		it1.remove();
	    }

	}
	

	return changed;
    }
{code}
----------------------


And the harness:

-----------------------
{code}

    public static void 	compositeCollectionRetainAllTest(boolean original) {

	int N=500000;

	ArrayList<Integer> firstArrayList=new ArrayList<Integer>();
	ArrayList<Integer> secondArrayList=new ArrayList<Integer>();

	for(int i=0;i<N;++i) {

	    firstArrayList.add(new Integer(i));
	    secondArrayList.add(new Integer(N-1-i));
	    
	}
	CompositeCollection col = new CompositeCollection(firstArrayList);

	if(original)
	    col.retainAll(secondArrayList);
	else 
	    efficientRetainAll(col,secondArrayList);



    }
{code}

------------------------------

The results are:

N		Original(s)	Repaired(s)	Speed-up(X)

10	         1.04		1.05		        0.99
100	         1.04		1.05		        0.99
1000		 1.06		1.06		        1.00
10000		 1.12		1.10		        1.01
100000		 9.34		1.15		        8.12
500000		 > 300		1.34		        > 223.88
","24/Jan/15 12:59;tn;Close as won't fix, similar to other issues.

The implementation of CompositeCollection delegates the call of retainAll to the composited collections. Thus its performance is dependent on the implementation of the relevant collections.

Instead of pre-optimizing methods, users should use appropriate collection types for their need, but I am in favor of adding a dedicated CollectionUtils.retainAll method that provides a linear-time implementation.","24/Jan/15 15:38;oswaldo_o;Hi Thomas,

It's understandable that changing the code might be undesirable.

But shouldn't there be a warning to the user in the documentation about the pathological cases in the invoked function (contains in other cases, retainAll in this one) ? 

In the case of AbstracLinkedList::retainAll, you would need to peek at the contains method implementation to see the performance impact, but in CompositeCollection::retainAll you would probably need to look at the implementation of retainAll of the underlying collections, and then the contains of these collections. 
More layers of function invocations w.r.t. the problematic method are more likely to obscure the performance bottleneck, making a stronger case to document the  higher level functions.","24/Jan/15 15:48;tn;The documentation clearly states what the method is doing:

{noformat}
     * This implementation calls <code>retainAll()</code> on each collection.
{noformat}

The retainAll() method of the Collection interface is also well-known and by default (see AbstractCollection) calls contains() on the provided collection. Thus users should be aware of this by now (2015). If a user is really calling retainAll() with a huge list, it's probably better to put the elements in a set and provide this as an argument to retainAll().

My whole point is that there's no use in providing uber-collection types that have an optimal runtime-complexity in all cases but with the trade-off of additional memory requirements. Users have to chose and use proper collection types for their use case.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Performance issue in SetUtils::isEqualSet,COLLECTIONS-547,12769111,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Minor,Not A Problem,,oswaldo_o,oswaldo_o,21/Jan/15 21:10,27/Nov/15 21:47,07/Apr/19 20:37,22/Jan/15 09:18,4.0,,,,,,,,Set,,,,,,0,perfomance,,,"There seems to be a performance problem with the function isEqualSet of 
SetUtils when the first parameter is of a collection type that has a slow containsAll/contains method.

The following is the code of the function:

{code}
    /**
     * Tests two sets for equality as per the <code>equals()</code> contract
     * in {@link java.util.Set#equals(java.lang.Object)}.
     * <p>
     * This method is useful for implementing <code>Set</code> when you cannot
     * extend AbstractSet. The method takes Collection instances to enable other
     * collection types to use the Set implementation algorithm.
     * <p>
     * The relevant text (slightly paraphrased as this is a static method) is:
     * <blockquote>
     * <p>Two sets are considered equal if they have
     * the same size, and every member of the first set is contained in
     * the second. This ensures that the <tt>equals</tt> method works
     * properly across different implementations of the <tt>Set</tt>
     * interface.</p>
     *
     * <p>
     * This implementation first checks if the two sets are the same object:
     * if so it returns <tt>true</tt>.  Then, it checks if the two sets are
     * identical in size; if not, it returns false. If so, it returns
     * <tt>a.containsAll((Collection) b)</tt>.</p>
     * </blockquote>
     *
     * @see java.util.Set
     * @param set1  the first set, may be null
     * @param set2  the second set, may be null
     * @return whether the sets are equal by value comparison
     */
    public static boolean isEqualSet(final Collection<?> set1, final Collection<?> set2) {
        if (set1 == set2) {
            return true;
        }
        if (set1 == null || set2 == null || set1.size() != set2.size()) {
            return false;
        }

        return set1.containsAll(set2);
    }

{code}

The problem is that in the last return statement, the function relies on the 
containsAll method of the class of the set1, which can be any type of collection.

The following test harness shows the performance degradation between 
using a list and using a set as a first parameter, across different collection sizes.

{code}
    public static void 	setUtilsisEqualSetTest(boolean original) {

	int N=500000;
	ArrayList<Integer> firstArrayList=new ArrayList<Integer>();
	ArrayList<Integer> secondArrayList=new ArrayList<Integer>();
	for(int i=0;i<N;++i) {

	    firstArrayList.add(new Integer(i));
	    secondArrayList.add(new Integer((N-1)-i));
	    
	}

	SetUtils.isEqualSet(original?firstArrayList:(new HashSet<Integer>(firstArrayList)),secondArrayList);
	
{code}

In the following table ""Original"" corresponds to the time taken by 
the existing implementation of SetUtils::isEqualSet, ""Repaired"" to the time 
taken by the function invoked with the first parameter converted into a 
set, and ""Speed-up"" to the speed-up obtained after the repair.


       N	Original(s)	Repaired(s)	Speed-up(X)

      10	          1.01		    1.02		     0.99
     100	          1.02		    1.02		     1
    1000	          1.04		    1.04		     1
   10000	          1.15		    1.09		     1.05
  100000	          9.33		    1.11		     8.40
  500000	        > 300	            1.26		     > 238.09


One way to deal with this would be to call the CollectionUtils::containsAll method instead of Collection::containsAll, since it has a linear time implementation instead of quadratic, and can handle the types of isEqualSet.

Another solution would be to include a warning to the user in the documentation that the first parameter should have a fast containment method when possible.

 
",Ubuntu 14.04,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2015-01-22 09:18:20.552,,,false,,,,,,,,,,,,,,9223372036854775807,,,Thu Jan 22 09:18:20 UTC 2015,,,,,,0|i24mx3:,9223372036854775807,,,,,,,,"22/Jan/15 09:18;tn;The javadoc of the method clearly states the purpose and function of this method.

It should only be used when the first parameter is a Set or set-like data structure with a fast contains implementation. In other cases this method should not be used.

Delegating this method to CollectionUtils.containsAll() is no good as it has an additional memory overhead which is not needed when used properly.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Undocumented performance issue in the removeAll method in CollectionUtils,COLLECTIONS-545,12766770,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Trivial,Fixed,,oswaldo_o,oswaldo_o,12/Jan/15 06:04,27/Nov/15 21:11,07/Apr/19 20:37,23/Jan/15 09:34,4.0,,,,,4.1,,,Collection,,,,,,0,Collections,documentaion,performance,"This bug is analogous to https://issues.apache.org/jira/browse/COLLECTIONS-544

The method removeAll in CollectionUtils is inefficient when the second parameter collection has a slow containment method.

The following is the current implementation with its documentation:
============================
     /**
     * Removes the elements in <code>remove</code> from <code>collection</code>. That is, this
     * method returns a collection containing all the elements in <code>c</code>
     * that are not in <code>remove</code>. The cardinality of an element <code>e</code>
     * in the returned collection is the same as the cardinality of <code>e</code>
     * in <code>collection</code> unless <code>remove</code> contains <code>e</code>, in which
     * case the cardinality is zero. This method is useful if you do not wish to modify
     * the collection <code>c</code> and thus cannot call <code>collection.removeAll(remove);</code>.
     *
     * @param <E>  the type of object the {@link Collection} contains
     * @param collection  the collection from which items are removed (in the returned collection)
     * @param remove  the items to be removed from the returned <code>collection</code>
     * @return a <code>Collection</code> containing all the elements of <code>collection</code> except
     * any elements that also occur in <code>remove</code>.
     * @throws NullPointerException if either parameter is null
     * @since 4.0 (method existed in 3.2 but was completely broken)
     */
    public static <E> Collection<E> removeAll(final Collection<E> collection, final Collection<?> remove) {
        return ListUtils.removeAll(collection, remove);
    }


=======================================

We can notice the inefficiency by looking at the removeAll method in ListUtils.
The removeAll method from ListUtils is implemented and documented as follows:

=======================================

     /**
     * Removes the elements in <code>remove</code> from <code>collection</code>. That is, this
     * method returns a list containing all the elements in <code>collection</code>
     * that are not in <code>remove</code>. The cardinality of an element <code>e</code>
     * in the returned collection is the same as the cardinality of <code>e</code>
     * in <code>collection</code> unless <code>remove</code> contains <code>e</code>, in which
     * case the cardinality is zero. This method is useful if you do not wish to modify
     * <code>collection</code> and thus cannot call <code>collection.removeAll(remove);</code>.
     * <p>
     * This implementation iterates over <code>collection</code>, checking each element in
     * turn to see if it's contained in <code>remove</code>. If it's not contained, it's added
     * to the returned list. As a consequence, it is advised to use a collection type for
     * <code>remove</code> that provides a fast (e.g. O(1)) implementation of
     * {@link Collection#contains(Object)}.
     *
     * @param <E>  the element type
     * @param collection  the collection from which items are removed (in the returned collection)
     * @param remove  the items to be removed from the returned <code>collection</code>
     * @return a <code>List</code> containing all the elements of <code>c</code> except
     * any elements that also occur in <code>remove</code>.
     * @throws NullPointerException if either parameter is null
     * @since 3.2
     */
    public static <E> List<E> removeAll(final Collection<E> collection, final Collection<?> remove) {
        final List<E> list = new ArrayList<E>();
        for (final E obj : collection) {
            if (!remove.contains(obj)) {
                list.add(obj);
            }
        }
        return list;
    }

=======================================

In the case of ListUtils:removeAll, the inefficiency is properly documented.

Perhaps the disclaimer about potential inefficiencies depending on the type 
of the parameter collection in ListUtils:removeAll should also be included in CollectionUtils:removeAll.",Ubuntu 14.04,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2015-01-23 09:34:34.74,,,false,,,,,,,,,,,,,,9223372036854775807,,,Fri Jan 23 09:34:34 UTC 2015,,,,,,0|i248xr:,9223372036854775807,,,,,,,,"23/Jan/15 09:34;tn;Fixed in r1654156.

Thanks for the report!",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Undocumented performance issue in the retainAll method in CollectionUtils ,COLLECTIONS-544,12766767,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Trivial,Fixed,,oswaldo_o,oswaldo_o,12/Jan/15 05:55,27/Nov/15 21:11,07/Apr/19 20:37,12/Jan/15 14:06,4.1,,,,,4.1,,,Collection,,,,,,0,Collections,documentaion,performance,"The method {{retainAll}} in {{CollectionUtils}} is inefficient when the parameter collection has a slow containment method.

The following is the current implementation with its documentation:

{noformat}
 /**
     * Returns a collection containing all the elements in <code>collection</code>
     * that are also in <code>retain</code>. The cardinality of an element <code>e</code>
     * in the returned collection is the same as the cardinality of <code>e</code>
     * in <code>collection</code> unless <code>retain</code> does not contain <code>e</code>, in which
     * case the cardinality is zero. This method is useful if you do not wish to modify
     * the collection <code>c</code> and thus cannot call <code>c.retainAll(retain);</code>.
     *
     * @param <C>  the type of object the {@link Collection} contains
     * @param collection  the collection whose contents are the target of the #retailAll operation
     * @param retain  the collection containing the elements to be retained in the returned collection
     * @return a <code>Collection</code> containing all the elements of <code>collection</code>
     * that occur at least once in <code>retain</code>.
     * @throws NullPointerException if either parameter is null
     * @since 3.2
     */
    public static <C> Collection<C> retainAll(final Collection<C> collection, final Collection<?> retain) {
        return ListUtils.retainAll(collection, retain);
    }
{noformat}

We can notice the inefficiency by looking at the {{retainAll}} method in {{ListUtils}}.

The {{retainAll}} method from {{ListUtils}} is implemented and documented as follows:

{noformat}
  /**
     * Returns a List containing all the elements in <code>collection</code>
     * that are also in <code>retain</code>. The cardinality of an element <code>e</code>
     * in the returned list is the same as the cardinality of <code>e</code>
     * in <code>collection</code> unless <code>retain</code> does not contain <code>e</code>, in which
     * case the cardinality is zero. This method is useful if you do not wish to modify
     * the collection <code>c</code> and thus cannot call <code>collection.retainAll(retain);</code>.
     * <p>
     * This implementation iterates over <code>collection</code>, checking each element in
     * turn to see if it's contained in <code>retain</code>. If it's contained, it's added
     * to the returned list. As a consequence, it is advised to use a collection type for
     * <code>retain</code> that provides a fast (e.g. O(1)) implementation of
     * {@link Collection#contains(Object)}.
     *
     * @param <E>  the element type
     * @param collection  the collection whose contents are the target of the #retailAll operation
     * @param retain  the collection containing the elements to be retained in the returned collection
     * @return a <code>List</code> containing all the elements of <code>c</code>
     * that occur at least once in <code>retain</code>.
     * @throws NullPointerException if either parameter is null
     * @since 3.2
     */
    public static <E> List<E> retainAll(final Collection<E> collection, final Collection<?> retain) {
        final List<E> list = new ArrayList<E>(Math.min(collection.size(), retain.size()));

        for (final E obj : collection) {
            if (retain.contains(obj)) {
                list.add(obj);
            }
        }
        return list;
    }
{noformat}

In the case of {{ListUtils#retainAll}}, the inefficiency is properly documented.

Perhaps the disclaimer about potential inefficiencies depending on the type 
of the parameter collection in ListUtils:retainAll should also be included in {{CollectionUtils#retainAll}}.",Ubuntu 14.04,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2015-01-12 12:02:05.299,,,false,,,,,,,,,,,,,,9223372036854775807,,,Mon Jan 12 14:06:25 UTC 2015,,,,,,0|i248x3:,9223372036854775807,,,,,,,,12/Jan/15 12:02;kinow;Updated the issue formatting code.,"12/Jan/15 14:06;tn;Documented in r1651098.

Thanks for the report!",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
AbstractCollectionDecorator should not delegate equals and hashcode,COLLECTIONS-543,12765478,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,tn,tn,07/Jan/15 22:05,27/Nov/15 21:11,07/Apr/19 20:37,12/Jan/15 15:21,4.0,,,,,4.1,,,,,,,,,0,,,,"In order to preserve the symmetry of equals the AbstractCollectionDecorator shall not forward calls to equals and hashcode to the decorated collection.

The test for equality usually also includes a test for the specific interface, e.g. List, which the collection decorator does not implement.

The relevant sub-classes like AbstractListDecorator can delegate the calls to safely fulfill the Collections contract.",,,,,,,,,,,,,,,COLLECTIONS-553,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,9223372036854775807,,,Mon Jan 12 15:21:31 UTC 2015,,,,,,0|i241uf:,9223372036854775807,,,,,,,,12/Jan/15 15:21;tn;Fixed in r1651115.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
ExtendedProperties causes AccessControlException when framework is called from a script,COLLECTIONS-538,12759317,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,trejkaz,trejkaz,03/Dec/14 23:58,27/Nov/15 21:11,07/Apr/19 20:37,08/Nov/15 15:08,3.2.1,,,,,3.2.2,,,Collection,,,,,,0,,,,"We're using Velocity 1.7, which depends upon Commons Collections 3.x series' ExtendedProperties class.

ExtendedProperties has these constructors where it looks up the file separator using the least convenient means possible:

{code}
    public ExtendedProperties() {
        this.fileSeparator = System.getProperty(""file.separator"");
        // ...
    }
{code}

For us, this is all being called from untrusted code, so this fails with AccessControlException.

I think that instead of using the system property here, it is customary to use the File.separator constant.

If you absolutely _must_ use System.getProperty() to fetch this value, it should at least be done from a doPrivileged() block.

Also I had a quick check of Commons Collections 4 to see if this issue had been fixed, but couldn't immediately see what happened to this class. If it did turn out to have been fixed in v4, maybe Velocity could be encouraged to update to v4, but I haven't seen any updates from them in 4 years, so it's probably not a good sign.

",Java security manager enabled,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2014-12-04 09:33:41.625,,,false,,,,,,,,,,,,,,9223372036854775807,,,Sun Nov 08 15:08:07 UTC 2015,,,,,,0|i231d3:,9223372036854775807,,,,,,,,"04/Dec/14 09:33;tn;Is it possible for you to do the relevant call to velocity within a privileged block?

Currently, it is very unlikely that the 3.x branch will see a new release. The respective class (ExtendedProperties) has been removed from collections 4.0 (see the release notes for alternatives).","15/Dec/14 05:31;trejkaz;We use templates as something the user can customise. Users can therefore pass templates around to other users, and a particularly malicious user might find a way to have the template write to arbitrary files or something.

Velocity may not be lowering privileges when calling methods on template objects either. I don't know either way, but I figure it's better not to trust it unless someone shows that it's doing things safely.

If we called Velocity in a privileged block, we might be opening up the final link in that attack vector, so I'm not exactly keen, no.

","17/Dec/14 14:22;tn;And giving the permission to read system properties to the commons-collections lib is not an option in your case?

I understand it is annoying, but as I said, it is very unlikely that we will release a new 3.x lib, at least in the near future.","17/Dec/14 22:53;trejkaz;I think the situation is that the application has permission to read system properties anyway, but it's evaluating some JavaScript at some point.

The script being down somewhere in the stack means that the entire stack is treated as unprivileged. I don't know if there is a way around that... I couldn't immediately see any APIs around ScriptEngine or ScriptContext which allowed me to set the privileges for the script. The script itself is running is from the same directory as the rest of our code, so it should presumably have had the same privileges as everything else, but for whatever reason, I guess script engines don't work like that.

What I might do is fork the project into our local repo and make the change just for our copy.
","26/Dec/14 13:30;tn;Ok, I will then mark it as to be fixed for 3.2.2 in case somebody is really willing to make a new point release for the 3.x branch.","08/Nov/15 15:08;tn;Fixed in commit r1713233.

The system property is now accessed via a call to doPrivileged. If the call fails with a SecurityException, File#separator is used instead.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
PredicateUtils (all|any)Predicate type misbehaviour Array vs. Collection,COLLECTIONS-537,12755049,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,fj,fj,13/Nov/14 12:47,27/Nov/15 21:11,07/Apr/19 20:37,30/Dec/14 18:25,4.0,,,,,4.1,,,Functor,,,,,,0,,,,"Migrating from collections-generic to collections4 we encountered a type problem with PredicateUtils. When you look at the method anyPredicate(), the signature with array is typed with ""Predicate<? super T>"" whereas the signature with Collection is typed ""? extends Predicate<T>"", so the both methods are not equivalent.
We think both methods should have the same types, so it would not break compatibility with a lot of legacy code.",,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2014-12-26 13:29:22.68,,,false,,,,,,,,,,,,,,9223372036854775807,,,Tue Dec 30 18:25:09 UTC 2014,,,,,,0|i22bvr:,9223372036854775807,,,,,,,,"26/Dec/14 13:29;tn;Yes indeed, the correct signature should be:

{code}
    Predicate<T> anyPredicate(final Collection<? extends Predicate<? super T>> predicates)
{code}

This change will require some more changes in other places too for sake of consistency.
The test case to demonstrate the change:

{code}
import java.util.ArrayList;
import java.util.List;

import org.apache.commons.collections4.Predicate;
import org.apache.commons.collections4.PredicateUtils;

public class MyTest {


    public static class A {
        int val;
        
        public A(int val) {
            this.val = val;
        }
        
        public String toString() {
            return ""A"";
        }
    }
    
    public static class B extends A {
        
        public B(int val) {
            super(val);
        }
        
        public String toString() {
            return ""B"";
        }
    }
    
    public static class MyPredicate implements Predicate<A> {

        private int eval;
        
        public MyPredicate(int eval) {
            this.eval = eval;
        }

        @Override
        public boolean evaluate(A object) {
            return object.val < eval;
        }
        
    }

    public static void main(String[] args) {
        MyPredicate p1 = new MyPredicate(10);
        MyPredicate p2 = new MyPredicate(20);

        Predicate<B> anyPredicate = PredicateUtils.anyPredicate(p1, p2);
        
        System.out.println(anyPredicate.evaluate(new B(10)));
        
        List<Predicate<A>> list = new ArrayList<Predicate<A>>();
        list.add(p1);
        list.add(p2);
        
        Predicate<B> anyPredicate2 = PredicateUtils.anyPredicate(list);
        
        System.out.println(anyPredicate2.evaluate(new B(10)));
    }
}
{code}","30/Dec/14 18:25;tn;Fixed in r1648561 for the following classes:

 * AllPredicate
 * AnyPredicate
 * NonePredicate
 * OnePredicate
 * ChainedTransformer
 * ChainedClosure

Thanks for the report!",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
(Code style) map.size() call in MapUtils.putAll(),COLLECTIONS-536,12751294,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Trivial,Fixed,,lany,lany,29/Oct/14 02:58,27/Nov/15 21:11,07/Apr/19 20:37,29/Oct/14 21:05,3.2.1,4.0,,,,4.1,,,Map,,,,,,0,performance,,,"In class org.apache.commons.collections(4).MapUtils there's a method putAll(final Map<K, V> map, final Object[] array) which starts with 
{noformat}
map.size();  // force NPE
{noformat}

Actually map.size() is not that harmless call for any map. For example, consider java.util.concurrent.ConcurrentHashMap size() implementation: depending on the circumstances it may take even more time than the rest of the putAll method (at least prior to JDK 8). Things are even worse for ConcurrentSkipListMap: its size() method iterates over all the map elements. Thus I'd suggest to replace this call with more conventional check like:
{noformat}
if(map == null) {
    throw new NullPointerException();
}
{noformat}

If you still want to save bytes, you may use {{map.getClass()}}. It's final, so it will never be overridden to do something strange and it's even used by JavaC for the same purpose (to trigger NPE). For example, if you compile and disassemble this code:
{noformat}
public class Outer {
    public class Inner {}
    public void test(Outer n) { n.new Inner(); }
}
{noformat}
You will see a getClass() call which is used to trigger NPE.",Any,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2014-10-29 21:05:23.417,,,false,,,,,,,,,,,,,,9223372036854775807,,,Wed Oct 29 21:05:23 UTC 2014,,,,,,0|i21pc7:,9223372036854775807,,,,,,,,"29/Oct/14 21:05;tn;Fixed in r1635303.

Thanks for the report!",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Performance bug in CollectionBag::retainAll,COLLECTIONS-534,12748417,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,oswaldo_o,oswaldo_o,15/Oct/14 21:01,27/Nov/15 21:11,07/Apr/19 20:37,19/Oct/14 12:44,4.0,,,,,4.1,,,Bag,Collection,,,,,0,perfomance,,,"Hi,
There seems to be a performance bug in the method retainAll in the CollectionBag class.
The problem is that the code is checking containment over the parameter collection, which could be expensive for some types of collections like ArrayLists.
One solution could be to convert the Collection into a HashSet and check containment in the HashSet.
 If this is done, then running retainAll on a 1,000,000 collection would take less than 2 seconds instead of 27 mins, according to my experiments.

____________________________________________
Here's a function to expose the bug:

 public static void collectionBagRetainAllTest() {

	ArrayList<Integer> coll=new ArrayList<Integer>();
	for(int i=0;i<=1000000;++i)
	    coll.add(new Integer(i));

	TreeBag<Integer> treeBag=new TreeBag<Integer>(coll);

	CollectionBag<Integer> bag = new CollectionBag<Integer>(treeBag);

	bag.retainAll(coll);
     }
_____________________________________

Here's a proposed patch:

  public boolean retainAll(final Collection<?> coll) {
        if (coll != null) {
            boolean modified = false;
            final Iterator<E> e = iterator();
	    HashSet<Object> set=new HashSet<Object>(coll);
            while (e.hasNext()) {
                if (!set.contains(e.next())) {
                    e.remove();
                    modified = true;
                }
            }
            return modified;
        } else {
            // let the decorated bag handle the case of null argument
            return decorated().retainAll(null);
        }
    }
_____________________________________",Ubuntu 12.04,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2014-10-15 21:12:21.374,,,false,,,,,,,,,,,,,,9223372036854775807,,,Sun Oct 19 12:44:59 UTC 2014,,,,,,0|i217vb:,9223372036854775807,,,,,,,,"15/Oct/14 21:12;sebb@apache.org;However for smaller data sets, adding the extra conversion would probably reduce performance.
Have you tested that?","15/Oct/14 21:40;oswaldo_o;Hi Sebb,
Here are some results I've gathered for different sizes:

     Size         Fixed           Original

     1000000  0m1.696s    27m35.343s
      500000   0m1.392s    11m22.767s
      100000   0m1.172s      0m1.136s
       10000    0m1.068s      0m1.132s
        1000     0m0.972s      0m0.988s
         100      0m0.968s      0m0.936s
          10       0m0.948s      0m0.908s","16/Oct/14 19:39;tn;If we can update the algorithm to get a better performance I am very much in favor of it, but just copying the input arguments to a different collection to improve the runtime performance is not what we should do imho.

In similar cases we added something like that to the javadoc:

{noformat}
         * This implementation iterates over the elements of this collection, checking each element in
         * turn to see if it's contained in <code>coll</code>. If it's not contained, it's removed
         * from this collection. As a consequence, it is advised to use a collection type for
         * <code>coll</code> that provides a fast (e.g. O(1)) implementation of
         * {@link Collection#contains(Object)}.
{noformat}

The rationale behind it is that we can not be sure about the runtime complexity of the provided collection and just copying it to another collection seems to be a waste if the user already uses something like a set or another collection that supports O(1) for contains.",16/Oct/14 19:42;tn;btw. our implementation is more or less equivalent to the one of the default collections in the jdk.,"19/Oct/14 12:44;tn;Added comment in r1632904.

Thanks for the report.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"Generic Wildcards specified in CollectionUtils#isEqualCollection(Collection, Collection, Equator) may throw ClassCastException in certain cases",COLLECTIONS-531,12716766,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Minor,Fixed,,dipanjan21,dipanjan21,27/May/14 10:13,27/Nov/15 21:11,07/Apr/19 20:37,29/May/14 18:34,4.0,,,,,4.1,,,Collection,,,,,,0,,,,"CollectionUtils#isEqualCollection(Collection, Collection, Equator) is defined as
{code}
public static boolean isEqualCollection(final Collection<?> a, final Collection<?> b, final Equator<?> equator) {
...
}
{code}

This makes it possible to invoke it with a code like
{code}
public static class IntegerEquator implements Equator<Integer> {
        public boolean equate(Integer o1, Integer o2) {
            return o1.intValue() == o2.intValue();
        }
        public int hash(Integer o) {
            return o.intValue();
        }
    }

    @Test
    public void test() {
        List<Long> longList = Arrays.asList(1L, 2L);
        List<Integer> intList = Arrays.asList(1, 2);
        assertTrue(CollectionUtils.isEqualCollection(longList, intList, new IntegerEquator()));

    }
{code}
which compiles perfectly but throws a ClassCastException as Long cannot be cast to an Integer. However, the generics should be defined such that this is stopped at compile time itself.

If we modify the method to something like
{code}
public static <E> boolean isEqualCollection(final Collection<? extends E> a, final Collection<? extends E> b, final Equator<? super E> equator) {
...
}
{code}
the above example would give a compile time error. imho we should modify this method with bounded wildcards. I don't think this change would break any existing binaries if the method is being used correctly, otherwise it is probably throwing ClassCastExceptions anyway.

Test case attached",,,,,,,,,,,,,,,,,,,27/May/14 10:13;dipanjan21;IsEqualCollectionTest.java;https://issues.apache.org/jira/secure/attachment/12646885/IsEqualCollectionTest.java,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2014-05-29 18:34:28.247,,,false,,,,,,,,,,,,,,394974,,,Thu May 29 18:34:28 UTC 2014,,,,,,0|i1w06v:,395109,,,,,,,,"29/May/14 18:34;tn;Committed in r1598357.

I have verified that the change does not break b/c and it should be fine.

Additionally added a note to the javadoc that providing incompatible types, e.g. by casting, will result in a ClassCastException at runtime. This is probably a worthwhile distinction to the isEqualCollection(C, C) method which does support incompatible types (although will always return false for non-empty collections in such a case).

Thanks for the report!",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Please create a version commons-collections 3.x for jdk 8 compatibility,COLLECTIONS-527,12714435,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Blocker,Won't Fix,,ignatalexeyenko,ignatalexeyenko,15/May/14 10:12,27/Nov/15 21:47,07/Apr/19 20:37,16/May/14 23:00,,,,,,,,,,,,,,,0,java8,jdk8,,"Could you make a 3.x or 3.2.x release compatible with JDK8 ?
{code}
org.apache.commons.collections.MultiMap {
   public Object remove(Object key, Object item);
}
{code}

is not compatible with JDK's 8 Map

{code}
java.util.Map {
   boolean remove(Object key, Object value);
}
{code}

This causes bugs in projects, who run jdk8 and even compilation failures - for these, who implement common's MultiMap.

*Compilation Error*
If anyone implement MultiMap in their code, compilation fails with the error:
{code}
MyMultiHashMap.java:[11,7] error: remove(Object,Object) in MultiHashMap cannot implement remove(Object,Object) in Map
[ERROR] return type Object is not compatible with boolean
{code}

*Reasoning*
JDK 8 is here and being adopted. collection-commons are not yet compatible with Java 8. For many big project switch to commons-collections 4.x is not an option - some transitional release version needs to be required.

Alternative would be for companies to fork commons-collections and create their internal artifact. Why do it if the official compatibility version can be created?

Thanks!",,,,,,,,,,,,,,,,,,,15/May/14 12:39;ignatalexeyenko;COLLECTIONS_3_2_BRANCH_COLLECTIONS_527.patch;https://issues.apache.org/jira/secure/attachment/12645006/COLLECTIONS_3_2_BRANCH_COLLECTIONS_527.patch,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2014-05-16 15:15:12.882,,,false,,,,,,,,,,,,,,392748,,,Fri May 16 23:57:49 UTC 2014,,,,,,0|i1vmtr:,392924,,,,,,,,"15/May/14 12:39;ignatalexeyenko;Attached patch, method remove in MultiMap was renamed to removeCompat, all implementations and tests were updated. 
Patch was created based on sources of SVN repository, branch COLLECTIONS_3_2_BRANCH.

mvn package is green with JDK 8 (/).","15/May/14 12:49;ignatalexeyenko;[~tn], could you have a look on this one please?","16/May/14 15:15;joehni;Ignat, I understand the problem, but it does not make sense. If we modify this method in the interface, commons-collections 3.x is no longer compatible with any previous 3.x release and can break *any* jar that depends on cc-3.x (at least on MultiMap) unles it is *modified* itself and rebuilt. Sorry, this situation would be even worse.","16/May/14 15:50;ignatalexeyenko;[~joehni], thanks for your reply.

It's a breaking change indeed, but workaround is to publish a new major version (e.g. 3.3.0).

Regarding making the situation even worse - why? 
For people who need to migrate to JDK 8 and use collections 3.x, they need to:
# Fork the library
# Update their codebase (e.g. places, where MultiMap is implemented or remove(Object, Object) is used).

Instead, if they do have a version which is Java 8 compatible - they need to go with *2* and only update their codebase.


There might be other libraries that depends on commons-collections, but they will not target compatibility with some fork. It's more realistic other libraries will publish their compat-changes with respect to commons-collections _only_ when original commons-collections publish a Java 8 compat changes.

Thanks!","16/May/14 16:48;joehni;No, you don't understand the problem. If you depend directly on cc-3, you may adjust your source code, but if you're depending on another 3rd party dependency that also uses cc-3, you will break that one! This is exactly why *any* 3.x version is binary compatible. To support both versions at once, you have to change package names ... and that's why cc-4 exists.","16/May/14 21:45;ignatalexeyenko;In Maven world one probably gets something like:
{code}
Project
   `-- dependency A
      `-- commons-collection-3.2.1
   `--dependency B
      `--commons-collections-3.3.0
{code}
Where Maven resolves version of 3.3.0 and if *dependency A* uses some of commons-collection's remove(Object, Object) values they must receive runtime exceptions. This situation can be solved either by:
* using patched version of dependency A, that is compatible with commons-collections 3.3.0
* loading dependencies in different class loaders

Consider the other case, there's only commons-collection 3.2.1 in project:
{code}
Project
   `-- dependency A
      `-- commons-collection-3.2.1
   `--dependency B
      `--commons-collections-3.2.1
{code}
The same *dependency A* still uses some of commons-collection's remove(Object, Object) and we run Java 8. Again, they must receive same runtime exceptions - even without single change in commons-collection 3.2.1.

*Adopting Java 8*
So projects are already doomed if they need to run Java 8 with commons-collections 3.2.1. Transition to commons-collections4 might not be an option, as there are too much code changes required in projects. Even more code changes in other libraries (like *dependency A*)!

*More options*
Finally, developers aren't forced to upgrade to commons-collections 3.3. Developers may be happy with older Java or they're fortunate to avoid exceptions in remove(Object, Object) invocations on MultiMaps.

In any case, having a new compatibility release leaves more options for other projects and developers to react, then having no compatibility release at all. As mentioned earlier, this must have a coherent impact on other libraries (like *dependency A*) - much better then just a custom project fork.

Thanks [~joehni] for your time.","16/May/14 22:59;sebb@apache.org;If any dependency actually uses the current remove() method, removing it will break the application.
As this is a public method we cannot be sure that it is not being used anywhere, so dropping the method is not an option if we are to retain binary compatibility.
It's not possible to have two different versions of the same class in the same class-loader, which is why API breaks need a new package name (and new Maven coordinates).",16/May/14 23:00;sebb@apache.org;It's not possible to fix this,"16/May/14 23:08;tn;We could release a commons-collections 3.x version with different maven coordinates and package name for java 8 compatibility.
But in any case, projects would have to adopt and I doubt that there are so many changes required to upgrade to collections 4 as claimed.

Edit: a drop-in replacement as requested by the OP is simply impossible as sebb and Joerg have pointed out.","16/May/14 23:57;joehni;And let's come back to the facts. cc-3 *runs* on Java 8, you simply cannot compile with it (or against its runtime). And since anything that uses MultiMap.remove must have been compiled with an earlier runtime too, binary runtime compatibility stays fine.

Only people are affected that try to compile with Java 8 against cc-3. However, since they will have to adjust their source code, they can do directly the proper way. Most of the stuff will simply compile by replacing the import statements with the new package of cc-4 (actually for minimal changes it is enough to upgrade the code using MultiMap and depend on both cc versions). And if the source has been upgraded, the dependencies that still use cc-3 are completely happy and the new code running with cc-4 is also. And we, too, since we did not introduce an incompatible version into the cc-3.x namespace.

I know very well that that some Linux distros try to use that patch (actually I am using Gentoo for more than a decade), because they tend to build anything on their own, but if they insist on creating a version hell with their distro, they may do so - unless they do not blame us later on for incompatibilities.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
PatriciaTrie,COLLECTIONS-526,12713014,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Critical,Duplicate,,zigler,zigler,08/May/14 04:38,08/May/14 06:04,07/Apr/19 20:37,08/May/14 06:04,4.0,,,,,,,,Collection,,,,,,0,,,,"the result of trie tree prefixMap function is inconsistent. it would contain a key but the size is 0;
some unittest codes as below: 

  PatriciaTrie<String> aTree =
        new PatriciaTrie<String> ();
    aTree.put(""点评"", ""测试"");
    aTree.put(""书评"", ""测试"");
    assertTrue(aTree.prefixMap(""点"").containsKey(""点评"")); //pass
    assertEquals(""测试"", aTree.prefixMap(""点"").get(""点评"")); //pass
    assertFalse(aTree.prefixMap(""点"").isEmpty());                 //fail
    assertEquals(1, aTree.prefixMap(""点"").size());                 //fail
    assertEquals(1, aTree.prefixMap(""点"").keySet().size());   //fail
    assertEquals(1, aTree.prefixMap(""点"").entrySet().size()); //fail
    assertEquals(1, aTree.prefixMap(""点评"").values().size()); //fail",android,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,391330,,,2014-05-08 04:38:52.0,,,,,,0|i1vedz:,391550,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
PatriciaTrie,COLLECTIONS-525,12713013,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Critical,Fixed,,zigler,zigler,08/May/14 04:38,27/Nov/15 21:11,07/Apr/19 20:37,01/Jan/15 21:11,4.0,,,,,4.1,,,Collection,,,,,,0,,,," the result of trie tree prefixMap function is inconsistent. it would contain a key but the size is 0;
some unittest codes as below: 

  PatriciaTrie<String> aTree =
        new PatriciaTrie<String> ();
    aTree.put(""点评"", ""测试"");
    aTree.put(""书评"", ""测试"");
    assertTrue(aTree.prefixMap(""点"").containsKey(""点评"")); //pass
    assertEquals(""测试"", aTree.prefixMap(""点"").get(""点评"")); //pass
    assertFalse(aTree.prefixMap(""点"").isEmpty());                 //fail
    assertEquals(1, aTree.prefixMap(""点"").size());                 //fail actural 0
    assertEquals(1, aTree.prefixMap(""点"").keySet().size());   //fail actural 0
    assertEquals(1, aTree.prefixMap(""点"").entrySet().size()); //fail actural 0
    assertEquals(1, aTree.prefixMap(""点评"").values().size()); //fail actural 0",android,,,,,,,,,,,,COLLECTIONS-526,,,,,,09/May/14 16:55;zigler;525.patch;https://issues.apache.org/jira/secure/attachment/12644130/525.patch,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2014-05-14 13:30:58.869,,,false,,,,,,,,,,,,,,391329,,,Thu Jan 01 21:11:08 UTC 2015,,,,,,0|i1vedr:,391549,,,,,,,,"09/May/14 07:53;zigler;take some time to investigate, I found this line:

       if (isBitSet(prefix, endIndexInBits, endIndexInBits)
                != isBitSet(entry.key, lengthInBits, lengthInBits(entry.key))) {
            return null;
        }

in subtree functions.

It simply check the last bits of the prefix and the entry.key, however, as we use string as key, the endIndexInBits would be set the character length, 
and it would make the codes check the next character of the prefix and the entry.key instead as expected.  Then for the character of the low region(which the highest bit is always 0) this judgment is always return true. But for other characters this would not return as expected.

In other worlds, it use a open boundary as an close one.

 if (isBitSet(prefix, endIndexInBits-1, endIndexInBits)
                != isBitSet(entry.key, lengthInBits-1, lengthInBits(entry.key)))
would fix it. 
","09/May/14 11:17;zigler;I'm afraid there are two other places make the same mistake:
the test code as below:
		PatriciaTrie<String> aTree2 = new PatriciaTrie<String> ();
		aTree2.put(""点评"", ""联盟"");
		aTree2.put(""点版"", ""定向"");
		System.out.println(aTree2.prefixMap(""点"").values());
",09/May/14 16:55;zigler;I hope the patch could make some sense,"14/May/14 13:30;tn;Thanks for the report and patch.
It seems to fix the problem, but needs more investigation to make sure the problem is fully resolved by this change.","01/Jan/15 21:11;tn;Fixed in r1648941.

Thanks for the report and patch!",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
ListOrderedSet can have duplicates,COLLECTIONS-524,12712470,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,jggoodfe,jggoodfe,06/May/14 00:58,27/Nov/15 21:11,07/Apr/19 20:37,06/May/14 22:14,3.2.1,4.0,,,,4.1,,,,,,,,,0,,,,"The static method, org.apache.commons.collections.set.ListOrderedSet.decorate(List list), has a comment ""If the list contains duplicates, the duplicates are removed"".  It does not remove duplicates and will leave you in an inconsistent state if your list has duplicates.  (i.e. the .size() result is smaller than the number of iterations from the iterator)","tomcat 7, linux",,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2014-05-06 22:13:14.51,,,false,,,,,,,,,,,,,,390786,,,Tue May 06 22:13:14 UTC 2014,,,,,,0|i1vb5z:,391026,,,,,,,,"06/May/14 22:13;tn;Fixed in r1592910.

The method will now correctly remove duplicates.
Thanks for the report!",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"Typo in MultiMapKey's isEqualKey(entry, key1, key2)",COLLECTIONS-521,12711792,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,Maxime Nay,Maxime Nay,01/May/14 20:51,27/Nov/15 21:11,07/Apr/19 20:37,06/May/14 21:38,,,,,,4.1,,,,,,,,,0,,,,"I believe there is a typo line 252 in MultiKeyMap.
        return
            multi.size() == 2 &&
            (key1 == multi.getKey(0) || key1 != null && key1.equals(multi.getKey(0))) &&
            (key2 == multi.getKey(1) || key1 != null && key2.equals(multi.getKey(1)));

should be:
        return
            multi.size() == 2 &&
            (key1 == multi.getKey(0) || key1 != null && key1.equals(multi.getKey(0))) &&
            (key2 == multi.getKey(1) || key2 != null && key2.equals(multi.getKey(1)));
",,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2014-05-01 21:01:04.413,,,false,,,,,,,,,,,,,,390113,,,Sun May 18 22:40:32 UTC 2014,,,,,,0|i1v71r:,390350,,,,,,,,"01/May/14 21:01;githubbot;GitHub user maximenay opened a pull request:

    https://github.com/apache/commons-collections/pull/1

    COLLECTIONS-521 Typo in MultiMapKey's isEqualKey(entry, key1, key2)

    https://issues.apache.org/jira/browse/COLLECTIONS-521

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/maximenay/commons-collections trunk

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/commons-collections/pull/1.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #1
    
----
commit 2992bbb3d7e772a43ab5e819bd73dd211fcf7681
Author: maxime nay <maxime.nay@gmail.com>
Date:   2014-05-01T20:59:34Z

    COLLECTIONS-521 Typo in MultiMapKey's isEqualKey(entry, key1, key2)

----
","03/May/14 09:23;sebb@apache.org;Thanks for the patch. Looks good to me, but ideally there should first be a test case that exposes the bug.
If key2 == null then presumably the current code will throw NPE.","05/May/14 18:03;Maxime Nay;MultiKeyMap<String, Long> map = new MultiKeyMap<String, Long>();
map.put(""test"", null, 2L) is indeed throwing NPE:

java.lang.NullPointerException
	at org.apache.commons.collections4.map.MultiKeyMap.isEqualKey(MultiKeyMap.java:249)
	at org.apache.commons.collections4.map.MultiKeyMap.put(MultiKeyMap.java:180)","06/May/14 21:38;tn;Fixed in r1592893.

Thanks for the report and patch!","18/May/14 22:40;githubbot;Github user maximenay closed the pull request at:

    https://github.com/apache/commons-collections/pull/1
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
private constructors in utility classes break existing code,COLLECTIONS-519,12709731,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Won't Fix,,radopas,radopas,22/Apr/14 10:05,27/Nov/15 21:47,07/Apr/19 20:37,02/May/14 09:00,4.x,,,,,,,,,,,,,,1,,,,"Hello,

In collections version 4.x all utility classes (example ListUtils, MapUtils, PredicateUtils....) have private constructors. I consider this to be a serious bug, as it breaks any possibility the classes to be extended by the users.  The javadoc says that constructors are private in order to prevent class instantiation but this object instantiation is not really problem and i think it is more important to allow classes to be extended. The possibility to extend utility classes was one of the major selling points of commons.lang and commons.collections projects. In the latest commons.lang project the utility classes still have public constructors.


Best Regards",,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2014-04-22 15:03:03.012,,,false,,,,,,,,,,,,,,388053,,,Fri May 02 09:00:12 UTC 2014,,,,,,0|i1uui7:,388311,,,,,,,,"22/Apr/14 15:03;sebb@apache.org;Not sure I follow the use case for this.

The utility classes only have static methods which cannot be overridden.
How would it help if the ctors were not private?
","23/Apr/14 07:03;radopas;Hello,
A class with static methods can be extended to hide the underlying library implementation, to add more functions and to decorate existing functions. Unfortunately, with the private constructor, the only way to do any of this is by embedding the utility class and writing wrapper methods for every utility method that needs to be exported. This is possible to do, but for simple use cases, where we need to add just one or two custom functions, this approach creates a lot of additional error prone work.

Best Regards","23/Apr/14 10:31;sebb@apache.org;Sorry, but I still don't follow - AFAICT it's not possible to hide base class static methods.

Can you provide a simple example?","30/Apr/14 11:57;dipanjan21;It is possible to hide (not override) base class static methods. The following code snippet
{code}
public class StaticInheritence {

    public static void main(String[] args) {
        Child.someMethod();
        Base.someMethod();
    }

    public static class Base {

        public static void someMethod() {
            System.out.println(""Base"");
        }
    }

    public static class Child extends Base {

        public static void someMethod() {
            System.out.println(""Child"");
        }
    }
}
{code}
would output
{code}
Child
Base
{code}

However, I am not sure if this is a valid use case. imho having a custom util class with the required functions and calling collection's utils methods wherever necessary is a much better solution. Static inheritance never overrides a method but only hides it, so technically you cannot decorate a static functions.","30/Apr/14 13:20;radopas;Exactly, thanks:) 

Here is what i mean by decorate or extend the utility functions:
{code} public class ListUtils extends org.apache.commons.collections.ListUtils{
    public static boolean isEqualList(final Collection list1, final Collection list2){
    //do something 
    boolean res = org.apache.commons.collections.ListUtils.isEqualList(list1, list2);
    //do something 
    return res;
  }
}{code}

When i can extend the base class, i can quickly add more functions to ListUtils:
{code} public class ListUtils extends org.apache.commons.collections.ListUtils{
    public static List asList(String s1){
      List list = new ArrayList();
      list.add(s1);
      return list;
    }
}{code}

And by hide the library implementation i mean that i can hide the fact that we are using an external library because we import and work only with the ListUtils from my package. Then when we have to update the external library or to replace it - i only need to change my custom ListUtils class.
","01/May/14 10:28;dfeist;This is a major issue for us with Mule use of commons-collections too as we plan to upgrade from to version 4 with generics :-(

We extend commons collections utility clases and add a few extras with the goal that everywhere in our code base we just use a single utility class that provides all commons-collections methods plus our own.  See: https://raw.githubusercontent.com/mulesoft/mule/477feb5e0c5df246865501eb995cf0b2e7e07bc2/core/src/main/java/org/mule/util/MapUtils.java

While i agree the *constructor shouldn't be public*, it *should at least be protected though to allow extension*, else you may as well make the class final because the effect is the same.  To goal of this change was (based on the javadoc) to prevent instantiation, not to prevent extension.","01/May/14 11:08;tn;In r1591602, I have changed all constructors of *Utils classes from private to protected to allow sub-classing.

Commons is a community project, thus we need feedback from our users to further improve the components.

Thanks for the use-cases that you presented here, probably not something that lots of people do, but certainly valid and useful.","01/May/14 11:21;dfeist;Thanks for the speedy response and code change! (BTW, I'd have sent a PR if commons was using github)

Out of interest do you have any rough plans regarding when 4.1 might be released?",01/May/14 11:33;tn;The plan is to release 4.1 once COLLECTIONS-464 and COLLECTIONS-508 are resolved which should not take too long anymore.,"01/May/14 12:23;radopas;Hello Thomas,

Thank you for the quick reaction. This solution looks perfect to me.","01/May/14 13:00;sebb@apache.org;I still think it would have been better to extend the existing utility class by composition rather than sub-classing.

1) the sub-class does not prevent access to the underlying static methods. It would be easy to accidentally invoke the wrong method.

2) If a new method is added to the Collections class, it will be automatically made available to the derived class. This can cause problems if the derived class happens to have chosen the same method signature for different functionality.
It can also cause issues if the new method is a sibling to an existing method that is deliberately hidden in the derived class; the user would then be able to bypass the local class.

Allowing subclassing of utuility classes does make life simpler for the developer, but only initially.
However, it does not provide safety for the user of the subclass, and I suspect it will cause additional headaches for the developer in the long term.

I agree with @Dipanjan Laha that this is not a valid use case for extension; so yes the utilty class should be regarded as final","01/May/14 13:45;dfeist;Sebb,  You comments are valid, and in fact java takes this exact same approach with Collections, Arrays to ensure they cannot be instantiated or extended.  I also agree that composition/delegation is an valid alternative (albeit more verbose) way of extending these Util classes to achieve the use case described above.
 
What I don't like about using this In this particular case, is that it's completely inconsistent with rest of commons i.e. IOUtils, BooleanUtils etc.","01/May/14 14:00;sebb@apache.org;In which case, we should look at fixing the rest of Commons rather than re-instating the bad practise in Collections 4.

Commons components have been around a long time, and Java best practise has evolved.

AFAICT the only downside of not allowing subclassing is that the replacement class is a bit more tedious to create and maintain - though maybe there are IDE helpers that can automate most of the work. However the upside is more flexibility.","01/May/14 14:10;dfeist;> we should look at fixing the rest of Commons rather than re-instating the bad practise in Collections 3.
Can't disagree with that.

Agree on downside, not sure how it provides more flexibly though?  It does eliminate risks due to accidental hiding etc. in subclass as you described though.
",01/May/14 14:23;sebb@apache.org;As to flexibility: the new class can be rewritten to use a different external utility class - or use its own implementation - without affecting end-users.,"01/May/14 20:11;radopas;Hello,
I'm sorry but i don't agree with you. You already said that composition/delegating are tedious and hard to maintain - this means useless work initially AND afterwards. If someone is afraid that extending the Utiliy classes could create the problems you are listing - he is free to use composition the way he likes. As for me - i don't need this added complexity in 90% of my work.","02/May/14 08:07;britter;Guys I really don't understand what you're talking about here. Subclassing a static util class makes no sense at all. Let's revisit the example given above (I've added a package declaration) :

{code:java}
package com.myapp.utils

 public class ListUtils extends org.apache.commons.collections.ListUtils{
    public static boolean isEqualList(final Collection list1, final Collection list2){
    //do something 
    boolean res = org.apache.commons.collections.ListUtils.isEqualList(list1, list2);
    //do something 
    return res;
  }
}
{code}

What is the difference compared to the following:
{code:java}
package com.myapp.utils

 public class ListUtils {
    public static boolean isEqualList(final Collection list1, final Collection list2){
    //do something 
    boolean res = org.apache.commons.collections.ListUtils.isEqualList(list1, list2);
    //do something 
    return res;
  }
}
{code}

There is no difference at all! Subclassing simply makes no sense, since you can't use polymorphism with static methods. So calling {{org.apache.commons.collections.ListUtils.isEqualList(list1, list2)}} will still use the commons implementation and not you're custom implementation. To use you're custom implementation you have to use the fully qualified class name of your custom class: {{com.myapp.utils.ListUtils.isEqualList(list1, list2)}}.",02/May/14 09:00;tn;Reverted commit after veto in r1591832.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
AbstractIterableGetMapDecorator should be abstract,COLLECTIONS-518,12708186,Bug,Reopened,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Minor,,,dipanjan21,dipanjan21,14/Apr/14 05:36,31/May/15 18:52,07/Apr/19 20:37,,4.0,,,,,5.0,,,Map,,,,,,0,,,,"AbstractIterableGetMapDecorator should be abstract, but is not",,,,,,,,,,,,,,,,,,,14/Apr/14 05:37;dipanjan21;AbstractIterableGetMapDecorator.patch;https://issues.apache.org/jira/secure/attachment/12640027/AbstractIterableGetMapDecorator.patch,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2014-05-06 21:01:43.958,,,false,,,,,,,,,,,,,,386509,,,Sun May 31 18:52:05 UTC 2015,,,,,,0|i1ul0n:,386773,,,,,,,,14/Apr/14 05:37;dipanjan21;Patch to make it abstract,"06/May/14 21:01;tn;This change will break binary compatibility.

Would be acceptable in this case imho, but needs to be clearly documented in the release notes.
","07/May/14 11:37;dipanjan21;@Binary Compatibility: True it would break it, but as you said, this should be acceptable 

So maybe you can commit it and keep the issue open till we document it in the release notes.","29/Oct/14 21:19;tn;Fixed in r1635305.

Added a todo entry to mention it in the release notes.","31/May/15 18:52;tn;Reverted the change in r1682770.

It is not really important and can be postponed to 5.0, as I want to avoid introducing a potential problem wrt binary compatibility.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
NullPointerException in MapUtils.toProperties,COLLECTIONS-516,12707638,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,Telcontar,Telcontar,10/Apr/14 04:39,27/Nov/15 21:11,07/Apr/19 20:37,19/May/14 20:38,4.0,,,,,4.1,,,Collection,,,,,,0,,,,"calling MapUtils.toProperties with a map having null entries results in a NullPointerException. In this case the Map has only entry <null, null>.

However, javadoc states ""A null input will return an empty
properties object."" so (1) this should be clarified as it would
only apply to the map reference itself, not its contents, or (2)
an empty property object should be generated for null entries in
the map as well.","Mac OS 10.9, Java 6",,,,,,,,,,,,,,,,,,10/Apr/14 04:39;Telcontar;Report4.java;https://issues.apache.org/jira/secure/attachment/12639533/Report4.java,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2014-04-10 20:38:41.329,,,false,,,,,,,,,,,,,,385961,,,Mon May 19 20:38:20 UTC 2014,,,,,,0|i1uhnb:,386225,,,,,,,,10/Apr/14 04:39;Telcontar;A JUnit test to reproduce the issue.,"10/Apr/14 20:38;tn;The javadoc comment refers to the case when the provided map is null, not individual entries within the map.

We could add a check to prevent adding null keys to the Properties object, but I think this would just hide wrong usage, so I would prefer to add additional clarification to the javadoc that null keys / values will result in a NullPointerException.","10/Apr/14 23:08;Telcontar;Thank you for commenting on this. Based on your opinion, I agree that a minor change in the javadoc comment is probably best. Maybe:
""Entries in the map must be non-null. If a null reference is given for the map, this method will return an empty properties object.""","19/May/14 20:38;tn;Added javadoc clarification in r1596050.

Thanks for the report!",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
ClassCastException in LazySortedMap when used with equals/transformers,COLLECTIONS-515,12707637,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Invalid,,Telcontar,Telcontar,10/Apr/14 04:36,27/Nov/15 21:47,07/Apr/19 20:37,10/Apr/14 20:46,4.0,,,,,,,,Collection,Map,,,,,0,,,,"When LazySortedMap is used by equals, the result is
java.lang.ClassCastException: org.apache.commons.collections4.map.LazySortedMap cannot be cast to java.lang.String

This seems to be odd, as the use of the different transformations should not result in internal casting to String. See the attached unit test to reproduce.","Mac OS 10.9, Java 6",,,,,,,,,,,,,,,,,,10/Apr/14 04:36;Telcontar;Report3.java;https://issues.apache.org/jira/secure/attachment/12639532/Report3.java,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2014-04-10 20:46:41.875,,,false,,,,,,,,,,,,,,385960,,,Thu Apr 10 20:46:41 UTC 2014,,,,,,0|i1uhn3:,386224,,,,,,,,10/Apr/14 04:36;Telcontar;A JUnit test that results in a ClassCastException even though no explicit cast to String is made.,"10/Apr/14 20:46;tn;There is no surprise here to get a ClassCastException as you provide a wrong key to the tailMap() method.

{noformat}
      org.apache.commons.collections4.trie.PatriciaTrie var0 = new org.apache.commons.collections4.trie.PatriciaTrie();
      org.apache.commons.collections4.Transformer var1 = org.apache.commons.collections4.functors.ExceptionTransformer.exceptionTransformer();
      java.util.SortedMap var2 = org.apache.commons.collections4.MapUtils.lazySortedMap((java.util.SortedMap)var0, (org.apache.commons.collections4.Transformer)var1);
      java.util.SortedMap var3 = var2.tailMap((java.lang.Object)var2);
{noformat}

So var2 is a PatriciaTrie, and you try to construct a tailMap with the trie itself as key. Of course this will result in a ClassCastException, the only surprise here is that it is not thrown immediately.

Trying the same with a java.util.TreeMap will throw the ClassCastException immediately during the call to tailMap.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
NullPointerException in MapBackedSet.mapBackedSet,COLLECTIONS-514,12707636,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Invalid,,Telcontar,Telcontar,10/Apr/14 04:31,27/Nov/15 21:47,07/Apr/19 20:37,10/Apr/14 20:59,4.0,,,,,,,,Bag,Collection,Set,,,,0,,,,"It seems that addAll has issues with adding a set that is backed by a singleton map with entry null -> null. However, the javadoc of the involved classes does not state that null entries are disallowed.
Either the code should allow adding a null entry to a bag, or the documentation should state that null entries are not allowed.

See the attached unit test in JUnit format to reproduce the problem.","MacOS 10.9, Java 6",,,,,,,,,,,,,,,,,,10/Apr/14 04:33;Telcontar;Report2.java;https://issues.apache.org/jira/secure/attachment/12639530/Report2.java,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2014-04-10 20:59:08.83,,,false,,,,,,,,,,,,,,385959,,,Thu Apr 10 20:59:08 UTC 2014,,,,,,0|i1uhmv:,386223,,,,,,,,10/Apr/14 04:33;Telcontar;JUnit test that produces a NullPointerException.,"10/Apr/14 20:59;tn;The use TreeBag states that it uses a TreeMap as underlying data structure, this the same limitations apply as for a TreeMap.

In fact I consider this even a bug in the jdk, as the TreeMap states that adding a mapping with a null key and natural ordering will result in a NullPointerException, although it does not immediately, only when you try to get the entry with a null key:

{noformat}
        SortedMap<String, String> map = new TreeMap<String, String>();
        map.put(null, null);
        System.out.println(map.get(null));
{noformat}

The NullPointerException is only thrown in the call to get().",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
NullPointerException in SwitchTransformer.transform,COLLECTIONS-513,12707623,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Invalid,,Telcontar,Telcontar,10/Apr/14 02:00,27/Nov/15 21:47,07/Apr/19 20:37,10/Apr/14 20:28,4.0,,,,,,,,Functor,,,,,,0,,,,"A relatively complex test case generated by Randoop results in a NullPointerException in SwitchTransformer.transform.

I'm not sure if this is an incorrect usage of the method, or if it is a real bug.","Mac OS 10.9, Java 6 and Java 7",,,,,,,,,,,,,,,,,,10/Apr/14 02:00;Telcontar;BugReport2.java;https://issues.apache.org/jira/secure/attachment/12639514/BugReport2.java,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2014-04-10 20:28:21.882,,,false,,,,,,,,,,,,,,385946,,,Thu Apr 10 23:18:06 UTC 2014,,,,,,0|i1uhjz:,386210,,,,,,,,10/Apr/14 02:00;Telcontar;A unit test in JUnit format to reproduce the problem. The last line results in a NullPointerException.,"10/Apr/14 04:44;Telcontar;According to the documentation in Transformer.transform (the interface that is implemented), the exception should probably be IllegalArgumentException, if any.
The javadoc of related classes suggests this as well.","10/Apr/14 20:28;tn;This is not a bug.

The constructor of SwitchTransformer states that the array of predicates must not contain null values:

{noformat}
     * @param predicates  array of predicates, cloned, no nulls
{noformat}

but the provided array of predicates is an array with one null value.

I think the way these tests are created are flawed:

{noformat}
        org.apache.commons.collections4.set.CompositeSet var1 = new org.apache.commons.collections4.set.CompositeSet(
                var0);
        org.apache.commons.collections4.functors.UniquePredicate var2 = new org.apache.commons.collections4.functors.UniquePredicate();
        org.apache.commons.collections4.Predicate[] var3 = new org.apache.commons.collections4.Predicate[] { var2 };
        java.lang.Object[] var4 = var1.toArray((java.lang.Object[]) var3);
{noformat}

Here var1 is an empty set, whose contents are copied into an object array var4. But the toArray() method is called with an non-empty array, which will be modified by the toArray() call and result in this 1-element array with a null value.

I fail to see what this tries to test, as the result of this operation will be in any case wrong","10/Apr/14 23:18;Telcontar;Thank you for confirming this as a false positive.
Basically the tool we use generates random sequences of method calls. Parameters have valid types but may not always fulfill other requirements (entries being non-null, for example). We have filtered out other (simpler) cases ourselves from the bug reports, but we were not sure about this one.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
equals/hashCode mismatch,COLLECTIONS-512,12707621,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,Telcontar,Telcontar,10/Apr/14 01:56,27/Nov/15 21:11,07/Apr/19 20:37,02/Jan/15 13:03,4.0,,,,,4.1,,,Collection,Comparator,,,,,0,,,,"We used Randoop on the collection classes, which found several test cases where two objects are equal but their hash code differs.

I will attach a file containing two test cases that are different; the other tests seem to be longer versions showing the same issue.","Mac OS 10.9, Java 6 and Java 7",,,,,,,,,,,,,,,COLLECTIONS-543,,,10/Apr/14 01:57;Telcontar;BugReport1.java;https://issues.apache.org/jira/secure/attachment/12639513/BugReport1.java,10/Apr/14 04:26;Telcontar;BugReport1_1.java;https://issues.apache.org/jira/secure/attachment/12639528/BugReport1_1.java,,,,,,,,2.0,,,,,,,,,,,,,,,,,,,2014-04-10 21:55:57.03,,,false,,,,,,,,,,,,,,385944,,,Fri Jan 02 13:03:08 UTC 2015,,,,,,0|i1uhjj:,386208,,,,,,,,10/Apr/14 01:57;Telcontar;This file contains two unit tests (for JUnit) to reproduce the problems.,10/Apr/14 04:26;Telcontar;We found another test case that does not seem to overlap with the existing tests. It shows the same issue but uses a different sequence with (mostly) different classes.,10/Apr/14 21:55;tn;Fixed the issue with the TransformingComparator in r1586477.,"10/Apr/14 22:12;tn;The same wrong statement is also used in FixedOrderComparator, so this might be affected too.",06/May/14 20:42;tn;Fixed FixedOrderComparator in r1592874.,26/Jun/14 12:03;brentworden;[~tn] Can this be marked as resolved?,"26/Jun/14 12:26;tn;Not yet, as discussed here: http://markmail.org/message/n5hmqap7z3ftv7jw we should document the behavior of equals for the decorators in collections.",02/Jan/15 13:03;tn;Added note to AbstractCollectionDecorator#equals in r1649014.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Clarify javadoc of CollectionBag,COLLECTIONS-509,12699628,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,tn,tn,08/Mar/14 18:45,27/Nov/15 21:11,07/Apr/19 20:37,08/Mar/14 18:47,4.0,,,,,4.1,,,,,,,,,0,,,,The javadoc of CollectionBag should clarify which methods have changed wrt the original Bag interface.,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,377975,,,Sat Mar 08 18:47:22 UTC 2014,,,,,,0|i1t4of:,378267,,,,,,,,08/Mar/14 18:47;tn;Done in r1575586.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
ComparatorUtils.chainedComparator(..) should not force the objects to implement Comparable,COLLECTIONS-507,12694830,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,gersonk,gersonk,12/Feb/14 20:29,27/Nov/15 21:11,07/Apr/19 20:37,12/Feb/14 21:18,4.0,,,,,4.1,,,Comparator,,,,,,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2014-02-12 21:18:17.379,,,false,,,,,,,,,,,,,,373338,,,Wed Feb 12 21:18:17 UTC 2014,,,,,,0|i1sc6n:,373639,,,,,,,,"12/Feb/14 21:18;tn;That is quite a stupid mistake, fixed in r1567759.
Thanks for spotting and reporting this!",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Result of CollectionUtils are different between version 3.2.1 and version 4.0,COLLECTIONS-506,12686070,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,anthonyC,anthonyC,22/Dec/13 19:13,27/Nov/15 21:11,07/Apr/19 20:37,31/Dec/13 16:25,4.0,,,,,4.1,,,,,,,,,0,,,,"CollectionUtils V3 uses equals to compute results but not CollectionUtils v4 (it seems to use ==)

The following exemple with subtract method :

 List<ObjectTest> listA = new ArrayList<ObjectTest>();
        List<ObjectTest> listB = new ArrayList<ObjectTest>();

        listA.add(new ObjectTest(""Test1""));
        listA.add(new ObjectTest(""Test2""));
        listA.add(new ObjectTest(""Test3""));

        listB.add(new ObjectTest(""Test1""));
        listB.add(new ObjectTest(""Test2""));


        Collection<?> res1 = org.apache.commons.collections.CollectionUtils.subtract(listA, listB);
        System.out.println(""Res1 size = "" +res1.size());
        Collection<?> res2 =  org.apache.commons.collections4.CollectionUtils.subtract(listA, listB);
        System.out.println(""Res2 size = "" +res2.size());


Produces this : 
Res1 size = 1
Res2 size = 3

The new behaviour is not useful. It would be better to have the V3 behaviour

",,,,,,,,,,,,,,,,,,,22/Dec/13 19:14;anthonyC;test-common-collection.zip;https://issues.apache.org/jira/secure/attachment/12620095/test-common-collection.zip,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2013-12-22 20:04:50.793,,,false,,,,,,,,,,,,,,365027,,,Thu Jan 02 11:34:45 UTC 2014,,,,,,0|i1qx3b:,365335,,,,,,,,22/Dec/13 19:14;anthonyC;This is the example,"22/Dec/13 20:04;tn;I could not yet test your example but looking at the source of ObjectTest it looks like you did not implement hashCode properly.

As the subtract method puts the items in a HashBag it is absolutely necessary that you follow the contract for Object#equals (see http://docs.oracle.com/javase/7/docs/api/java/lang/Object.html#equals%28java.lang.Object%29) for more details.","22/Dec/13 20:47;anthonyC;You're right, it works well when hashCode is implemented properly.  Thank you.

It would be nice to have a remark in javadoc to know the requirement in order to make CollectionUtils methods working. It could be a class or method comment or something like a migration guide or a warning.

Thank you for those useful methods.

Best regards",31/Dec/13 16:25;tn;Added clarification to the class javadoc of CollectionUtils in r1554554.,02/Jan/14 11:34;anthonyC;Thank you !,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
CompositeMap should support compositing of maps of derived types,COLLECTIONS-504,12682510,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Minor,Invalid,,petercooperjr-efi,petercooperjr-efi,03/Dec/13 20:33,04/Dec/13 15:32,07/Apr/19 20:37,04/Dec/13 12:56,4.0,,,,,,,,Map,,,,,,0,,,,"I'm attempting to composite two maps, one of which is a {{Map<String, String>}} and the other of which is a {{Map<String, Object>}}. I would have expected that I could composite them into a {{CompositeMap<String, Object>}}, but the constructors of CompositeMap expect all of the maps being composited to have exactly the same type arguments.

That is, I think the constructors should take arguments of {{Map<? extends K, ? extends V>}} instead of what they currently have of {{Map<K, V>}}, much like most collection methods, since there shouldn't be a problem accepting type arguments that are subtypes of the composite map types.

Thanks!",,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2013-12-03 22:07:56.236,,,false,,,,,,,,,,,,,,361767,,,Wed Dec 04 15:32:10 UTC 2013,,,,,,0|i1qczz:,362064,,,,,,,,"03/Dec/13 22:07;tn;Unfortunately this would only be possible for an immutable CompositeMap. If there is a mutator defined, it would be possible that an unexpected type may appear in a composited map, e.g.

{noformat}
        Map<String, String> map1 = new HashMap<String, String>();
        Map<String, Object> map2 = new HashMap<String, Object>();
        
        map1.put(""key1"", ""value1"");
        map2.put(""key2"", Integer.valueOf(1));
        
        CompositeMap<String, Object> composite =
                new CompositeMap<String, Object>(map1, map2, new CompositeMap.MapMutator<String, Object>() {

                    public Object put(CompositeMap<String, Object> map, Map<String, Object>[] composited, String key,
                            Object value) {
                        return composited[1].put(key, value);
                    }
        });

        composite.put(""key3"", Integer.valueOf(2));
        
        for (Map.Entry<String, String> entry : map1.entrySet()) {
            System.out.println(entry.getValue());
        }
{noformat}

will result in

{noformat}
Exception in thread ""main"" java.lang.ClassCastException: java.lang.Integer
{noformat}

So I do not think that this is a good idea unless we add Immutable versions of various collection types similar to what guava does.","04/Dec/13 12:54;petercooperjr-efi;Oh, of course. The maps I was trying to use were in fact immutable, which is why I didn't think of that, though it's obvious in retrospect. Thank you for your time.","04/Dec/13 15:32;tn;What you proposed makes sense, but is not possible atm.

In case you would like to see Immutable collections also in Apache Commons Collections you could already create a feature request.
I think there are surely use-cases for them and the memory savings can be crucial in various applications.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"Rename MultiKeyMap.remove(K key1, K key2) to avoid clashes with newly introduced default methods in Java 8",COLLECTIONS-501,12679637,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,tn,tn,17/Nov/13 16:04,09/Nov/14 14:31,07/Apr/19 20:37,17/Nov/13 18:31,4.0-alpha1,,,,,4.0,,,,,,,,,0,,,,"Java 8 will introduce new default methods for the Map interface which clash with the existing method ""V remove(K key1, K key2)"" in our MultiKeyMap interface.

To avoid future problems rename the method (and other similar methods with more multi key arguments) to a more specific version:

 * V removeMultiKey(K key1, K key2, ...)
 * V removeKey(K key1, K key2, ...)",,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,358997,,,Sun Nov 17 18:31:09 UTC 2013,,,,,,0|i1pvwf:,359287,,,,,,,,17/Nov/13 18:31;tn;Renamed method to removeMultiKey in r1542782.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"Rename MultiMap.remove(K, V) to avoid clashes with newly introduced default methods in Java 8",COLLECTIONS-500,12679636,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,tn,tn,17/Nov/13 16:02,09/Nov/14 14:31,07/Apr/19 20:37,17/Nov/13 17:10,4.0-alpha1,,,,,4.0,,,,,,,,,0,,,,"Java 8 will introduce new default methods for the Map interface which clash with the existing method ""V remove(K key, V value)"" in our MultiMap interface.

To avoid future problems rename the method to a more specific version and change the return type to be more logical. Brief discussion on the ml favored either:

 * boolean removeMapping(K key, V value)
 * boolean removeValue(K key, V value)",,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,358996,,,Sun Nov 17 17:10:53 UTC 2013,,,,,,0|i1pvw7:,359286,,,,,,,,"17/Nov/13 17:10;tn;Changed to boolean removeMapping(K, V) in r1542763.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
CollectionBag should respect removeAll / retainAll contract of decorated bags,COLLECTIONS-498,12678650,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,tn,tn,11/Nov/13 19:46,09/Nov/14 14:31,07/Apr/19 20:37,11/Nov/13 20:29,4.0-alpha1,,,,,4.0,,,,,,,,,0,,,,"In case the decorated collection does not support removal, i.e. throws an UnsupportedOperationException, CollectionBag does not respect this in case a null argument was specified.

To be consistent with the testing framework, CollectionBag shall delegate the call to the decorated collection in such cases.
",,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,358017,,,Mon Nov 11 20:29:27 UTC 2013,,,,,,0|i1ppuv:,358307,,,,,,,,11/Nov/13 20:29;tn;Fixed in r1540833.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
UnmodifiableBoundedCollection does not implement Unmodifiable marker interface,COLLECTIONS-496,12678602,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,tn,tn,11/Nov/13 16:42,09/Nov/14 14:31,07/Apr/19 20:37,11/Nov/13 16:47,4.0-alpha1,,,,,4.0,,,,,,,,,0,,,,The UnmodifiableBoundedCollection does not implement the Unmodifiable interface.,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,357969,,,Mon Nov 11 16:47:32 UTC 2013,,,,,,0|i1ppk7:,358259,,,,,,,,11/Nov/13 16:47;tn;Done in r1540766.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
UnmodifiableTrie should not decorate an already unmodifiable Trie,COLLECTIONS-495,12678600,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Minor,Fixed,,tn,tn,11/Nov/13 16:25,09/Nov/14 14:31,07/Apr/19 20:37,11/Nov/13 16:30,4.0-alpha1,,,,,4.0,,,,,,,,,0,,,,"An already unmodifiable trie was decorated again.
To be consistent with the other Unmodifiable wrappers, in this case the object itself shall be returned.

Also the return type shall be changed to Trie.",,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,357967,,,Mon Nov 11 16:30:27 UTC 2013,,,,,,0|i1ppjr:,358257,,,,,,,,11/Nov/13 16:30;tn;Fixed in r1540763.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
CollectionUtils.removeAll is not work as expected,COLLECTIONS-487,12674741,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Blocker,Duplicate,,xcooper,xcooper,21/Oct/13 07:48,09/Nov/14 14:31,07/Apr/19 20:37,21/Oct/13 07:56,3.2.1,,,,,4.0,,,Collection,List,,,,,0,,,,"http://svn.apache.org/viewvc/commons/proper/collections/tags/COLLECTIONS_3_2_1/src/java/org/apache/commons/collections/CollectionUtils.java?revision=1211567&view=markup

Line: 1122
Problem:
The method called ""removeAll"", but call ""retainAll"" internally.",JDK 1.6,,,,360,360,,0%,360,360,,,,COLLECTIONS-219,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2013-10-21 07:55:51.13,,,false,,,,,,,,,,,,,,354363,,,Mon Oct 21 07:55:51 UTC 2013,,,,,,0|i1p3cf:,354653,,,,,,,,"21/Oct/13 07:55;tn;You have found the most prominent bug in collections-3.2.1, which has been fixed for the upcoming 4.0 release.

Although this bug alone would be enough to justify a 3.2.2 release ;-).",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Transformed* classes require double the number of generic qualifiers,COLLECTIONS-482,12667863,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Duplicate,,hwaite,hwaite,10/Sep/13 18:16,27/Nov/15 21:47,07/Apr/19 20:37,10/Sep/13 19:55,4.0-alpha1,,,,,,,,Bag,Collection,List,Map,Set,,0,,,,"Transformed* classes currently have the same number of generic qualifiers as their parent interfaces (e.g. one for TransformedList and two for TransformedMap). In order to handle transformations between different types, transforming collections should specify both input and output classes.",,,,,,,,,,,,,,COLLECTIONS-333,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2013-09-10 19:55:16.902,,,false,,,,,,,,,,,,,,347799,,,Tue Sep 10 19:55:16 UTC 2013,,,,,,0|i1nz13:,348098,,,,,,,,"10/Sep/13 19:55;tn;This would be a great thing to have, but unfortunately it would break the Collection contract, see also the referenced issue.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Wrong timeout handling in expiration policies of PassiveExpiringMap,COLLECTIONS-475,12655845,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Minor,Fixed,,tn,tn,02/Jul/13 21:04,09/Nov/14 14:31,07/Apr/19 20:37,14/Jul/13 19:09,4.0-alpha1,,,,,4.0,,,,,,,,,0,,,,"The timeunit parameter in the ctor of ConstantTimeToLiveExpirationPolicy is not used.

Additionally, the validateAndConvertToMillis method is wrong, it should be changed like this:

{noformat}
    private static long validateAndConvertToMillis(final long timeToLive,
                                                   final TimeUnit timeUnit) {
  if (timeUnit == null) {
    throw new IllegalArgumentException(""Time unit must not be null"");
  }
  return TimeUnit.MILLISECONDS.convert(timeToLive, timeUnit);
}
{noformat}",,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,336120,,,Sun Jul 14 19:09:39 UTC 2013,,,,,,0|i1lz7z:,336444,,,,,,,,14/Jul/13 19:09;tn;Fixed in r1503029.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Exception in ListOrderedMap#putAll if map contains null values,COLLECTIONS-474,12654559,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,cning,cning,24/Jun/13 18:22,09/Nov/14 14:31,07/Apr/19 20:37,30/Jun/13 20:10,4.0,,,,,4.0,4.0-alpha1,,Map,,,,,,0,,,,"Dear apache developers, thanks for the great project. Recently, I encountered an IndexOutOfBoundsException in ListOrderedMap in the latest revision (r1495998) with the crash stack trace: 
Exception in thread ""main"" java.lang.IndexOutOfBoundsException: Index: 2, Size: 1
	at java.util.ArrayList.add(ArrayList.java:367)
	at org.apache.commons.collections4.map.ListOrderedMap.put(ListOrderedMap.java:448)
	at org.apache.commons.collections4.map.ListOrderedMap.putAll(ListOrderedMap.java:246)
	at Test.main(Test.java:15)

I've also attached a test case that can reproduce this crash.

I think this test case actually reveals the bug reported in COLLECTIONS-411 (https://issues.apache.org/jira/browse/COLLECTIONS-411). However, it seems that the original patch for COLLECTIONS-411 missed a corner case.

Could you please check if this is indeed a bug? Thanks!",java 1.7.0_09,,,,,,,,,,,,,,,,,,24/Jun/13 18:23;cning;Test.java;https://issues.apache.org/jira/secure/attachment/12589457/Test.java,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2013-06-24 18:55:12.1,,,false,,,,,,,,,,,,,,334836,,,Sun Jun 30 20:10:32 UTC 2013,,,,,,0|i1lrbb:,335160,,,,,,,,"24/Jun/13 18:55;tn;Thanks for the report.

The putAll javadoc does not mention it explicitly, but the provided index has to be in range (see javadoc for put(int, Object, Object)) otherwise an IndexOutOfBoundsException will be thrown. So the behavior is actually correct, but the javadoc should be updated.","24/Jun/13 18:59;sebb@apache.org;Looks like a bug to me, because the size() is 2 just before the putAll().

The problem is that the code assumes that the put method will only return null if the key was not replaced; however that is only true if the original value was not null. For maps that allow null, the return value of put cannot be used to determine if the key was replaced.","24/Jun/13 19:06;tn;Inserting with an index >= size() usually does not work in list-based collections, so I think the behavior is correct.
What worries me more is that the exception in put is thrown *after* the collection has been modified, leaving it in an inconsistent state.

We should check the index first and throw the exception if it is out-of-range.","24/Jun/13 19:20;sebb@apache.org;I've just added two tests - one uses null values (as per the issue description) and the other uses non-null values.

Only the null value test fails, so I think there is a bug; easy to fix.
Just replace

{code}
final V old = put(index, entry.getKey(), entry.getValue());
if (old == null) {
{code}

with

{code}
final boolean contains = containsKey(entry.getKey());
put(index, entry.getKey(), entry.getValue());
if (!contains) {
{code}
","24/Jun/13 19:32;tn;Ok agree, we can fix this in the next RC if one is needed, or for alpha2.","24/Jun/13 19:39;cning;Wow! Thanks for the quick responses! 

Just to make sure, after applying the patch, is the ""index == size"" case considered in-range (no exception raised)? 

FYI, it is also possible to reproduce the exception even when ""index < size"": 
    Object key1 = new Object();
    Object key2 = new Object();
    Object key3 = new Object();
    HashMap<Object, Object> map = new HashMap<Object, Object>();
    map.put(key1, null);
    map.put(key2, null);
    map.put(key3, null);

    ListOrderedMap<Object, Object> listMap = new ListOrderedMap<Object, Object>();
    listMap.put(key1, null);
    listMap.put(key2, null);
    listMap.put(key3, null);
    listMap.putAll(2, map);","24/Jun/13 19:42;tn;Looking at List.add(int, Object), the supported range is index >= 0 && index <= size(), so I guess we should do the same here.","24/Jun/13 19:53;sebb@apache.org;URL: http://svn.apache.org/r1496182
Log:
COLLECTIONS-474 Exception in ListOrderedMap#putAll if map contains null values

Modified:
    commons/proper/collections/trunk/src/changes/changes.xml
    commons/proper/collections/trunk/src/main/java/org/apache/commons/collections4/map/ListOrderedMap.java
","24/Jun/13 19:58;sebb@apache.org;putAll calls put before it changes anything, so I think we can leave the index check to the put method.",30/Jun/13 20:10;tn;Will be part of 4.0-alpha1 RC2.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
AbstractCollectionDecorator.decorated() should not be used internally,COLLECTIONS-473,12653286,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,sebb@apache.org,sebb@apache.org,17/Jun/13 22:17,09/Nov/14 14:31,07/Apr/19 20:37,18/Jun/13 20:29,,,,,,4.0,4.0-alpha1,,,,,,,,0,,,,"AbstractCollectionDecorator.decorated() is used internally to access the collection.
However, the method is not final, so subclasses could override it.

Yet the field is also exposed (protected).

This is inconsistent.

Is there any use-case for overriding the collection to use a different one?
If so, having direct access as well is likely to cause problems.

I think it would be better to use the field directly internally.
The class Javadoc says the calls are forwarded to the underlying collection, but that is not strictly true if decorated() is overridden.

If it is intended to allow this to be overridden, then the field needs to be protected against arbitrary read/write access.

The field should probably be made private with a setter for use by deserialization only.",,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2013-06-18 08:28:30.194,,,false,,,,,,,,,,,,,,333609,,,Tue Jun 18 20:22:36 UTC 2013,,,,,,0|i1ljsn:,333937,,,,,,,,"18/Jun/13 08:28;tn;Subclasses do override it to return the actual collection type they are decorating, look at AbstractBagDecorator for example, it returns a Bag instead of a Collection. Otherwise you would have to cast every result of decorated().

Also I do not think this classifies as a bug, the purpose of the abstract classes is to simplify the implementation of various decorators and not to safe-guard for anything another developer could do with them. In fact somebody could also alter the fields via reflection.","18/Jun/13 10:04;sebb@apache.org;Replacing ""collection"" with ""decorated()"" in sub-classes does not affect the casting issue as they are both of type Collection<E>.

The problem with allowing direct access is that a grand-child sub-class can accidentally subvert a child sub-class.

For example, if one wanted to create a logging layer, it could not guarantee that all sub-class accesses were logged.

It would also potentially allow the field to be made final later, by suitable changes to the deserialisation.

Exposing the field now means it *cannot later be hidden* whilst maintaining compatibility.

Hiding the field provides several benefits; any down-sides seem to me to be very minor in comparison.

It will still be possible to deliberately subvert the class via reflection, but at least casual misuse is avoided.","18/Jun/13 18:30;tn;As decorated() is not final, sub-classes can alter the return type as in AbstractBagDecorator, thus avoiding the necessity to cast. Changing this does not make sense imho.

Hiding the collection field and creating a protected setter for de-serialization support would be ok, but would require the effort to change of course.","18/Jun/13 20:05;sebb@apache.org;Yes, classes could override decorated() to change the return type; that's exactly what the AbstractBagDecorator and AbstractSortedBagDecorator sub-classes do; they don't access collection directly at all. I'm just suggesting that the rest of the classes behave the same way, at least as far as not accessing collections directly.

Since the overload decorated() method should make it easier for subclasses, that seems like a good idea.

I'm happy to make the changes, but I don't want to do it if they will then need to be reverted.

==

What about the main point of this JIRA, i.e. using collection internally rather than decorated()?
Is that OK to change?
","18/Jun/13 20:11;tn;I have already done the changes in r1494280:

 * made the collection field private
 * added a protected setter with javadoc stating that it should only be used for de-serialization
 * updated all other decorators to the the getters/setters instead of the plain field.

Is it ok like that?","18/Jun/13 20:22;sebb@apache.org;Yes, thanks; that makes it more future proof.

I think it's odd that the class uses decorated() internally, but the Javadoc does say so, so I guess it needs to remain the way it is.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
wasted work in AbstractMapBag.containsAll(),COLLECTIONS-472,12650761,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,adriannistor,adriannistor,03/Jun/13 22:59,09/Nov/14 14:31,07/Apr/19 20:37,09/Jun/13 18:35,3.2.1,,,,,4.0,4.0-alpha1,,Bag,,,,,,0,"patch,",performance,,"The problem appears in version 3.2.1 and in revision 1489197.  I
attached a one-line patch that fixes it.

In method ""AbstractMapBag.containsAll"", the loop over
""other.uniqueSet()"" should return immediately after ""result"" becomes
""false"", because ""result = result && contains;"" can never become
""true"" again.  All the iterations after ""result"" becomes ""false"" do
not perform any useful work, at best they just set ""result"" again to
""false"".",any,,,,,,,,,,,,,,,,,,03/Jun/13 22:59;adriannistor;patch.diff;https://issues.apache.org/jira/secure/attachment/12585980/patch.diff,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2013-06-09 18:35:43.028,,,false,,,,,,,,,,,,,,331088,,,Sun Jun 09 18:35:43 UTC 2013,,,,,,0|i1l4an:,331421,,,,,,,,09/Jun/13 18:35;tn;Applied in r1491258. Thanks for the patch!,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
TransformedMap class exists in two packages,COLLECTIONS-470,12647520,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,sebb@apache.org,sebb@apache.org,14/May/13 15:15,09/Nov/14 14:31,07/Apr/19 20:37,11/Jun/13 20:29,4.x,,,,,4.0,4.0-alpha1,,,,,,,,0,,,,"It's very confusing to have two different TransformedMap classes in different packages: map, splitmap.
Indeed the Test class has to take special care with the serialised file name to avoid a clash.

Since we can break binary compat in v4, now is the time to rename one of the classes.

Perhaps rename as follows:
splitmap/TransformedMap => splitmap/TransformedGetPutMap",,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2013-05-14 18:38:40.407,,,false,,,,,,,,,,,,,,327876,,,Tue Jun 11 20:29:41 UTC 2013,,,,,,0|i1kkkf:,328220,,,,,,,,"14/May/13 18:38;tn;Its in the splitmap package, so why not calling it TransformedSplitMap ?","11/Jun/13 20:29;tn;In r1491944, renamed to TransformedSplitMap.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Change Bag interface and implementations to conform to Collection interface,COLLECTIONS-468,12647374,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,tn,tn,13/May/13 20:57,09/Nov/14 14:31,07/Apr/19 20:37,17/Jun/13 21:06,,,,,,4.0,4.0-alpha1,,,,,,,,0,,,,"Several methods of the Bag interface do not conform to the Collection interface (e.g. add, remove, containsAll, removeAll, retainAll).
This should be fixed for 4.0.",,,,,,,,,,,,,,,,,,,09/Jun/13 18:18;tn;BagAdapter.java;https://issues.apache.org/jira/secure/attachment/12586961/BagAdapter.java,13/May/13 22:16;tn;COLLECTIONS-468.patch;https://issues.apache.org/jira/secure/attachment/12583016/COLLECTIONS-468.patch,09/Jun/13 18:25;tn;Multiset.java;https://issues.apache.org/jira/secure/attachment/12586962/Multiset.java,,,,,,,3.0,,,,,,,,,,,,,,,,,,,2013-05-13 22:39:31.929,,,false,,,,,,,,,,,,,,327730,,,Fri Jul 05 20:22:30 UTC 2013,,,,,,0|i1kjnz:,328074,,,,,,,,"13/May/13 22:16;tn;Attached patch with the proposed changes:

 * update Bag interface to conform to Collection contract
 * update AbstractMapBag
 * update unit tests to inherit from AbstractCollectionTest",13/May/13 22:39;ebourg;The change of return value on the add method bothers me. I have code that relies on this behavior and I think that's an important feature of the Bag interface.,"13/May/13 22:53;tn;We obviously do not want to copy guava, but their MultiSet does conform to the Collection contract.",14/May/13 05:31;tn;Another thing: we could also add a decorator which mimics the old behavior?,14/May/13 06:20;ebourg;Or a decorator that mimics a real collection?,"09/Jun/13 18:18;tn;Attached a working example of a BagAdapter which provides an adapter of the Bag interface to the newly proposed Multiset interface.

The Multiset interface is identical to the Bag interface with the difference that it conforms to the Collection super-interface.",17/Jun/13 21:06;tn;In r1493938 I have added a CompliantBag decorator which makes the decorated bag to comply with the Collection contract.,05/Jul/13 20:22;tn;Renamed to CollectionBag after discussion on ml (done in r1500007).,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
splitmap.TransformedMap is not really a Map,COLLECTIONS-461,12646188,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,sebb@apache.org,sebb@apache.org,06/May/13 10:16,09/Nov/14 14:31,07/Apr/19 20:37,14/May/13 20:02,,,,,,4.0,4.0-alpha1,,,,,,,,0,,,,"splitmap.TransformedMap is part of the Get/Put hierarchy, but it does not behave like a proper Java Map. 

In particular, java.util.Map.put(K, V) returns V.
However the collections Put interface returns Object.
As far as I can tell, this was done in order to be able to include TransformedMap in the hiearchy. But the side effect is to break the generics for all the non-transformer maps in the hierarchy.

Maybe there should be a separate PutTransformed interface which has the appropriate generic types, i.e.

public T put(K key, V value)

",,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2013-05-13 22:39:01.406,,,false,,,,,,,,,,,,,,326546,,,Tue May 14 20:02:40 UTC 2013,,,,,,0|i1kc3b:,326891,,,,,,,,13/May/13 22:39;mbenson;What value would one return?,"13/May/13 22:45;tn;I just tried it out myself, and it seems to work as expected:

{noformat}
        Map<Integer, String> map = new HashMap<Integer, String>();
        TransformedMap<Integer, Integer, String, String> mp = TransformedMap.transformingMap(map,
                new Transformer<Integer, Integer>() {

                    public Integer transform(Integer input) {
                        return input + 1;
                    }
            
                }, new Transformer<String, String>() {
                    
                    public String transform(String input) {
                        return ""value:"" + input;
                    }
                    
                });

        String old = mp.put(1, ""1"");
        System.out.println(old);
        Put<Integer, String> put = mp;
        System.out.println(put);
{noformat}","13/May/13 22:52;mbenson;Yes, but you didn't transform the keys and/or values to different *types*.  ;)","13/May/13 22:59;tn;well right, but this does not change anything:

{noformat}
        Map<String, String> map = new HashMap<String, String>();
        TransformedMap<Integer, String, Integer, String> mp = TransformedMap.transformingMap(map,
                new Transformer<Integer, String>() {

                    public String transform(Integer input) {
                        return String.valueOf(input + 1);
                    }
            
                }, new Transformer<Integer, String>() {
                    
                    public String transform(Integer input) {
                        return ""value:"" + input;
                    }
                    
                });

        String old = mp.put(1, 1);
        System.out.println(old);
        Put<Integer, Integer> put = mp;
        System.out.println(put);
{noformat}

What I wanted to test is whether the put returns Object or the given type V, which it does ;-)","13/May/13 23:17;mbenson;Riight... I hadn't looked at this stuff in years.  {{TransformedMap}} narrows the RT from {{Object}} to return {{V}} from {{#put(J, U)}} and in that sense will never behave like a regular {{Map}}--my point being that we don't know how to ""untransform"" the value back to the {{U}} type.  Returning the value actually contained in the target map is the best we can do.  The proposed {{#putTransformed()}} method would still suffer the same problem:  no way to get back to a {{U}} type from the {{V}} contained in the decorated {{Map}}.  Is the issue that {{TransformedMap}} is still named \*Map?  It was my intent that placing it in the {{splitmap}} subpackage would, along with [http://svn.apache.org/viewvc/commons/proper/collections/trunk/src/main/java/org/apache/commons/collections4/splitmap/package-info.java?view=markup], make the intent clear: namely, that a ""split map"" is like a ""map"" but is really a combination of {{Get}}/{{Put}} with no guarantees as to the type assignability between the two.  This was the only approach I found at the time to allow the preservation of the functionality of {{TransformedMap}} while also permitting it to be fully genericized.","13/May/13 23:42;sebb@apache.org;bq.  Is the issue that TransformedMap is still named *Map?

No, the problem here is that the ""real"" Map classes are compromised because Put#put(K, V) returns Object rather than V.
The Put interface is not exactly the same as the ""write"" subset of java.util.Map.","13/May/13 23:51;mbenson;I'm still not connecting the dots as to how the ""real"" Maps are compromised.  {{TransformedMap}} isn't a {{Map}}.  It's not intended to be plugged in as one.  Rather, if you need to be agnostic to whether you have a {{Map}} or a {{Put}} and a {{Get}}, you can program to the {{Put}}/{{Get}} APIs and use any of the {{IterableMap}} impls provided by {{\[collections\]}} to implement these as well.  By extending {{Map}} and {{Put}}, {{IterableMap}} forces the RT of {{#put()}} to be narrowed to {{V}}.","14/May/13 15:08;sebb@apache.org;Sorry, I cannot seem to find the problem myself either now. Not sure what triggered the original issue anymore.
As you write above, the fact that IterableMap extends Map as well as Put solves the problem of the return type (RT) from put().

However, it is still the case that Put is not exactly a subset of Map. 
Using Put rather than Map means that the RT of put() is Object and may have to be cast. 
It would be better if this could be avoided.

If Put cannot be fixed, then I think the Put#put() Javadoc needs to make this difference clear.
[Maybe the best would be to fix the Javadoc now, and adjust as necessary later.]","14/May/13 18:49;tn;Ok to add the following note to the javadoc of Put:

{noformat}
 * NOTE: the ""write"" interface of a {@link Map} may have different types
 * compared to the ""read"" part, thus {@link #put(Object, Object)} must return
 * {@link Object} as the actual value type can not be determined.
{noformat}","14/May/13 19:20;mbenson;Hrm... close, what about:
{noformat}
 * NOTE: in the original {@link Map} interface, {@link Map#put(Object, Object)} is known to have the same
 * return type as {@link Map#get(Object)}, namely {@code V}.  {@link Put} makes no assumptions in this
 * regard (there is no association with, nor even knowledge of, a ""reading"" interface) and thus defines
 * {@link #put(Object, Object)} as returning {@link Object}.
{noformat}","14/May/13 19:38;tn;yes, much better, thanks!",14/May/13 20:02;tn;Applied in r1482544.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
ArrayIterator & ObjectArrayIterator - do they need setters?`,COLLECTIONS-459,12645419,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,sebb@apache.org,sebb@apache.org,30/Apr/13 12:15,09/Nov/14 14:31,07/Apr/19 20:37,18/Jun/13 19:35,,,,,,4.0,4.0-alpha1,,,,,,,,0,,,,"ArrayIterator & ObjectArrayIterator both have methods to set the array separately from the ctor.

However the method does not allow the same flexibility as the ctor, as it does not allow the start or end indexes to be set.

Is there really a use-case for these setters? If not, all the fields apart from index could be made final, which would make thread safety (and testing) easier.",,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2013-04-30 13:43:29.592,,,false,,,,,,,,,,,,,,325781,,,Tue Jun 18 19:35:51 UTC 2013,,,,,,0|i1k7dj:,326126,,,,,,,,30/Apr/13 13:43;tn;I would be +1 to remove the setArray method in these two classes.,"14/May/13 20:25;tn;The respective *ListIterator classes seem to have been copied as they contain default constructors with the same javadoc, i.e. refer to a setArray method, although there is no such method.

I am going to remove the default constructors as they render these classes useless (they act as an empty iterator that can not be changed).","14/May/13 20:32;tn;Ah stupid me, the *ListIterator classes inherit from *Iterator ...","14/May/13 20:35;tn;I still think the setArray method should go away. Maybe they have been introduced to be able to reset the iterator, but this is now already supported via the ResettableIterator interface.","17/Jun/13 20:26;tn;In r1493922, I have removed the setArray methods and the default constructors.
The fields have been made final if possible (apart from the actual index used for the iteration). I have kept them protected to make the access in the derived classes (ArrayListIterator, ObjectArrayListIterator) easier.","17/Jun/13 21:55;sebb@apache.org;As for COLLECTIONS-455, we should use package access where possible.

If not, use getter/setter which is documented for internal use only.","18/Jun/13 08:32;tn;I started doing this, but after I had the code the retrieve the array to alter or access an element I was unhappy with the result.
The fields are already final, thus unmodifiable by sub-classes.

Also keep in mind that iterators in general are not supposed to be thread-safe, so I do not see the point in trying to achieve something that is not necessary.","18/Jun/13 10:33;sebb@apache.org;Thread-safety is only one of the issues here - it's possible for subclasses to destroy the invariant, i.e. startIndex <= index <= endIndex.

How about making the index package protected?

That would at least prevent 3rd party classes from corrupting the index, and would allow it to be made private later if necessary.

As for the array Object, that is less of an issue, though it would be trivial to add a get/set method to the parent class.",18/Jun/13 19:35;tn;Made the fields package private in r1494267.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"AbstractUntypedCollectionDecorator<E, D>  is not used",COLLECTIONS-458,12645322,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,sebb@apache.org,sebb@apache.org,29/Apr/13 22:20,27/Nov/15 21:11,07/Apr/19 20:37,30/Apr/13 12:00,,,,,,,,,,,,,,,0,,,,"The public ctor for AbstractUntypedCollectionDecorator<E, D> takes no argument and so collection = null; however the protected ctor checks for collection parameter != null.

The decorated() method says that all access to collection goes through it, and there is no setter.

At present the only way to recover from calling the public ctor is for the sub-class to set collection directly.

This is inconsistent.

The class is abstract and there appear to be no concrete subclasses. Looks like the class might be superfluous, but if it is required, it should ideally have a private final collection field.",,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2013-04-30 05:24:04.348,,,false,,,,,,,,,,,,,,325684,,,Tue Apr 30 12:00:27 UTC 2013,,,,,,0|i1k6rz:,326029,,,,,,,,"30/Apr/13 05:24;tn;I added the ctor with argument, but in fact we should delete the class as it is not used at all.","30/Apr/13 12:00;sebb@apache.org;URL: http://svn.apache.org/r1477514
Log:
COLLECTIONS-458 AbstractUntypedCollectionDecorator<E, D>  is not used

Removed:
    commons/proper/collections/trunk/src/main/java/org/apache/commons/collections4/collection/AbstractUntypedCollectionDecorator.java
Modified:
    commons/proper/collections/trunk/src/changes/changes.xml
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"AbstractDualBidiMap<K, V> has several mutable protected fields",COLLECTIONS-455,12645118,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,sebb@apache.org,sebb@apache.org,29/Apr/13 00:05,09/Nov/14 14:31,07/Apr/19 20:37,18/Jun/13 20:55,,,,,,4.0,4.0-alpha1,,,,,,,,0,,,,"Any non-private mutable fields make it much harder to ensure thread-safety as well as making it very difficult to test thoroughly.

The fields should be made private.
If protected write access really is needed, setter methods should be used.
These methods can take any necessary precautions to ensure thread-safety.",,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2013-05-05 16:21:45.84,,,false,,,,,,,,,,,,,,325480,,,Tue Jun 18 20:55:14 UTC 2013,,,,,,0|i1k5in:,325825,,,,,,,,"29/Apr/13 00:23;sebb@apache.org;Likewise for:

AbstractCollectionDecorator
AbstractUntypedCollectionDecorator
CompositeCollection
PredicatedCollection
SynchronizedCollection
TransformedCollection
EditCommand
ComparatorChain
AbstractQuantifierPredicate
ArrayIterator
ArrayListIterator
IteratorChain
NodeListIterator
ObjectArrayIterator
ObjectArrayListIterator
ObjectGraphIterator
AbstractKeyValue
AbstractMapEntryDecorator (the field is final but the object is not immutable)
AbstractLinkedList
CursorableLinkedList
NodeCachingLinkedList
SetUniqueList
AbstractHashedMap
AbstractLinkedMap
AbstractMapDecorator
AbstractReferenceMap

etc.",05/May/13 16:21;tn;Are you done with the changes or is something still missing?,"17/Jun/13 19:37;tn;For all the abstract decorator classes I am in favor to keep the things as they are for the following reasons:

 * the use and purpose of such abstract classes is clear
 * refactoring the serialization code is just additional work and does not bring any benefits","17/Jun/13 21:11;tn;In r1493940 I have removed the remaining todos as I want to keep them as is for now to make a 4.0 release.

Thanks for the effort on the other classes!","17/Jun/13 21:53;sebb@apache.org;I think the fields should at least be made package protected where possible.

It's misleading to expose the fields as protected if they are not intended to be mutable by sub-classes (and may make subsequent changes more difficult)

Where the fields cannot be made package protected, I suggest adding a getter/setter which is documented as being for internal use only.",18/Jun/13 20:55;tn;Changed remaining fields to scope package private.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"findBugs Warning: Flat3Map - 3 iterators which are ""both an Iterator and a Map.Entry""",COLLECTIONS-454,12645021,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,tn,tn,27/Apr/13 12:26,09/Nov/14 14:31,07/Apr/19 20:37,28/Apr/13 18:53,3.2.1,,,,,4.0,4.0-alpha1,,,,,,,,0,,,,The iterators should be rewritten as suggested by findbugs.,,,,,,,,,,,,,,,,,,,28/Apr/13 08:42;tn;COLLECTIONS-454.patch;https://issues.apache.org/jira/secure/attachment/12580875/COLLECTIONS-454.patch,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2013-04-28 14:54:33.683,,,false,,,,,,,,,,,,,,325383,,,Sun Apr 28 18:53:13 UTC 2013,,,,,,0|i1k4x3:,325728,,,,,,,,"28/Apr/13 08:42;tn;The attached patch adds a FlatMapEntry object that is returned by the EntryIterator.

The javadoc for the entrySet() method is updated to use mapIterator() if this additional object creation is not wanted.

We have two options:

 * apply this patch with the cost of some additional overhead when iterating over keys, values, entries (which I guess was the original idea to merge the iterator and entry)
 * add ignore filter to findbugs as in this specific case it is intended behavior (for performance reasons).

Any comments?","28/Apr/13 14:54;sebb@apache.org;The Findbugs explanation is:

{quote}
The entrySet() method is allowed to return a view of the underlying Map in which an Iterator and Map.Entry. This clever idea was used in several Map implementations, but introduces the possibility of nasty coding mistakes. If a map m returns such an iterator for an entrySet, then c.addAll(m.entrySet()) will go badly wrong. All of the Map implementations in OpenJDK 1.7 have been rewritten to avoid this, you should to.
{quote}

We should follow the Findbugs advice here.

The additional overhead is likely to be quite small.
Any errors caused by not fixing the bug may be extremely tricky to find.",28/Apr/13 18:53;tn;Applied in r1476813 after some more javadoc improvements.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
findBugs Warnings: several classes in package functors may expose their internal representation,COLLECTIONS-453,12645020,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,tn,tn,27/Apr/13 12:23,09/Nov/14 14:31,07/Apr/19 20:37,05/May/13 16:16,3.2.1,,,,,4.0,4.0-alpha1,,,,,,,,0,,,,"Several classes (e.g. SwitchTransformer) take in their constructor an array as input which is not copied/cloned.
Thus its internal representation may be changed externally.

The corresponding factory methods *do* copy the input arguments thus we have two choices:

 * move the copy from the factory methods to the ctors
 * make the ctors private to prevent their use",,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,325382,,,Sun May 05 16:16:46 UTC 2013,,,,,,0|i1k4wv:,325727,,,,,,,,27/Apr/13 12:28;tn;The warning for ObjectArrayIterator should be filtered as there it is ok to use the array directly imho.,"30/Apr/13 13:37;tn;Any objection to make the respective constructors in the functors package private?

All of them have corresponding factory methods.",30/Apr/13 21:17;tn;Added exclude filter for MultiKey in r1477834.,05/May/13 14:54;tn;Fixed InstantiateTransformer and InvokerTransformer. The constructor now clones the input arrays.,05/May/13 15:07;tn;Fixed ChainedClosure and ChainedTransformer in r1479336.,05/May/13 15:21;tn;Fixed SwitchClosure and SwitchTransformer in r1479337.,05/May/13 16:16;tn;Finished in r1479348.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Latest Version is set to 20040616,COLLECTIONS-449,12636948,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Critical,Won't Fix,joehni,kaicabuslay,kaicabuslay,14/Mar/13 02:50,14/Mar/13 07:28,07/Apr/19 20:37,14/Mar/13 07:28,,,,,,,,,,,,,,,0,,,,"The current maven metadata file for commons-collections shows that the ""latest version"" is 20040616. This is currently affecting spring-webmvc (3.1.3-RELEASE) - causing it to use the outdated version of the collections  package.

http://repo1.maven.org/maven2/commons-collections/commons-collections/maven-metadata.xml",,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2013-03-14 07:28:23.395,,,false,,,,,,,,,,,,,,317440,,,Thu Mar 14 07:28:23 UTC 2013,,,,,,0|i1irwf:,317781,,,,,,,,"14/Mar/13 07:28;joehni;Sorry, but we have no control over the central Maven repository.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
TreeListIterator can return incorrect results after remove() is called,COLLECTIONS-447,12635005,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,jbarnes,jbarnes,03/Mar/13 03:24,09/Nov/15 20:53,07/Apr/19 20:37,04/Mar/13 20:20,Nightly Builds,,,,,3.2.2,4.0,4.0-alpha1,Collection,,,,,,0,patch,test,,"{{TreeList.TreeListIterator}} can get in a bad state when {{remove()}} is called, causing it to subsequently return incorrect results. This is because {{TreeListIterator}} caches an {{AVLNode}} reference in its field {{next}}, and this node reference may become stale when {{remove()}} is called (it may contain a reference to a node that no longer exists in the tree).

I will attach two patches: {{testcase.patch}} will contain a test case illustrating the bug, and {{fix.patch}} will contain a fix. (To fix the bug, I simply clear the cached {{next}} value in {{TreeListIterator.remove}}.)

This was originally reported in a comment to COLLECTIONS-433; I am creating a separate issue for this at Thomas Neidhart's suggestion.","Windows 7, jdk1.5.0_22",,,,,,,,,,,,,,,,,,03/Mar/13 03:26;jbarnes;fix.patch;https://issues.apache.org/jira/secure/attachment/12571781/fix.patch,03/Mar/13 03:26;jbarnes;testcase.patch;https://issues.apache.org/jira/secure/attachment/12571780/testcase.patch,,,,,,,,2.0,,,,,,,,,,,,,,,,,,,2013-03-04 20:20:55.177,,,false,,,,,,,,,,,,,,315498,,,Mon Mar 04 20:20:55 UTC 2013,,,,,,0|i1ifxz:,315842,,,,,,,,"04/Mar/13 20:20;tn;Applied the patch together with some additional comment in r1452481.

Thanks for the analysis and patch, this was really a tricky one!",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Several unit test failures with IBM JDK 6,COLLECTIONS-445,12634291,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Blocker,Fixed,,tn,tn,26/Feb/13 21:21,09/Nov/14 14:31,07/Apr/19 20:37,21/Apr/13 17:48,,,,,,4.0,4.0-alpha1,,,,,,,,0,,,,"Failed tests: 
  AbstractSortedMapTest$TestTailMap>AbstractMapTest.testMapPut:808->AbstractSortedMapTest$TestViewMap.verify:141->AbstractMapTest.verify:1946->AbstractMapTest.verifyValues:2010 values should be same size as HashMap's
Test: []
Real: [value] expected:<1> but was:<0>
  AbstractSortedMapTest$TestTailMap>AbstractMapTest.testMapPutAll:952->AbstractSortedMapTest$TestViewMap.verify:141->AbstractMapTest.verify:1946->AbstractMapTest.verifyValues:2010 values should be same size as HashMap's
Test: []
Real: [value, value, seev, tmpv, we'llv, youv] expected:<6> but was:<0>
  AbstractMapTest$TestMapValues>AbstractCollectionTest.testCollectionClear:638->verify:1888->AbstractCollectionTest.verify:294 Collection should not contain a value that the confirmed collection does not have: againv
Test: []
Real: []
  AbstractMapTest$TestMapValues>AbstractCollectionTest.testCollectionRemoveAll:930->verify:1888->AbstractCollectionTest.verify:294 Collection should not contain a value that the confirmed collection does not have: againv
Test: []
Real: []
  AbstractMapTest$TestMapValues>AbstractCollectionTest.testCollectionRetainAll:973->verify:1888->AbstractCollectionTest.verify:294 Collection should not contain a value that the confirmed collection does not have: againv
Test: []
Real: []
  AbstractMapTest$TestMapEntrySet>AbstractCollectionTest.testCollectionIteratorRemove:838 Collection should shrink by one after iterator.remove expected:<-1> but was:<0>
  AbstractMapTest$TestMapKeySet>AbstractCollectionTest.testCollectionRemove:881 Collection should remove extant element: key
  AbstractMapTest$TestMapValues>AbstractCollectionTest.testCollectionIteratorRemove:838 Collection should shrink by one after iterator.remove expected:<-1> but was:<0>
  AbstractIterableMapTest$InnerTestMapIterator>AbstractMapIteratorTest.testMapIteratorSet:214 Value must be changed after setValue expected same:<newnonnullvalue> was not:<againv>
  AbstractIterableMapTest$InnerTestMapIterator>AbstractMapIteratorTest.testMapIteratorSet:214 Value must be changed after setValue expected same:<newnonnullvalue> was not:<again>
  AbstractBidiMapTest$TestBidiMapIterator>AbstractMapIteratorTest.testMapIteratorSet:214 Value must be changed after setValue expected same:<newnonnullvalue> was not:<again>
  AbstractBidiMapTest$TestInverseBidiMap>AbstractBidiMapTest.testBidiMapIteratorSet:560 expected same:<For> was not:<again>
  AbstractBidiMapTest$TestBidiMapIterator>AbstractMapIteratorTest.testMapIteratorSet:214 Value must be changed after setValue expected same:<newnonnullvalue> was not:<againv>
  DualTreeBidiMapTest>AbstractBidiMapTest.testBidiMapIteratorSet:560 expected same:<For> was not:<againv>
  AbstractOrderedBidiMapTest$TestBidiOrderedMapIterator>AbstractMapIteratorTest.testMapIteratorSet:214 Value must be changed after setValue expected same:<newnonnullvalue> was not:<againv>
  AbstractSortedMapTest$TestTailMap>AbstractMapTest.testMapPut:808->AbstractSortedMapTest$TestViewMap.verify:141->AbstractMapTest.verify:1946->AbstractMapTest.verifyValues:2010 values should be same size as HashMap's
Test: []
Real: [value] expected:<1> but was:<0>
  AbstractSortedMapTest$TestTailMap>AbstractMapTest.testMapPutAll:952->AbstractSortedMapTest$TestViewMap.verify:141->AbstractMapTest.verify:1946->AbstractMapTest.verifyValues:2010 values should be same size as HashMap's
Test: []
Real: [value, value2, seev, tmpv, we'llv, youv] expected:<6> but was:<0>
  AbstractMapTest$TestMapValues>AbstractCollectionTest.testCollectionClear:638->verify:1888->AbstractCollectionTest.verify:294 Collection should not contain a value that the confirmed collection does not have: againv
Test: []
Real: []
  AbstractMapTest$TestMapValues>AbstractCollectionTest.testCollectionRemoveAll:930->verify:1888->AbstractCollectionTest.verify:294 Collection should not contain a value that the confirmed collection does not have: againv
Test: []
Real: []
  AbstractMapTest$TestMapValues>AbstractCollectionTest.testCollectionRetainAll:973->verify:1888->AbstractCollectionTest.verify:294 Collection should not contain a value that the confirmed collection does not have: againv
Test: []
Real: []
  AbstractMapTest$TestMapEntrySet>AbstractCollectionTest.testCollectionIteratorRemove:838 Collection should shrink by one after iterator.remove expected:<-1> but was:<0>
  AbstractMapTest$TestMapValues>AbstractCollectionTest.testCollectionIteratorRemove:838 Collection should shrink by one after iterator.remove expected:<-1> but was:<0>
  AbstractIterableMapTest$InnerTestMapIterator>AbstractMapIteratorTest.testMapIteratorSet:214 Value must be changed after setValue expected same:<newnonnullvalue> was not:<youv>
  AbstractIterableMapTest$InnerTestMapIterator>AbstractMapIteratorTest.testMapIteratorSet:214 Value must be changed after setValue expected same:<newnonnullvalue> was not:<you>
  AbstractBidiMapTest$TestBidiMapIterator>AbstractMapIteratorTest.testMapIteratorSet:214 Value must be changed after setValue expected same:<newnonnullvalue> was not:<you>
  AbstractBidiMapTest$TestInverseBidiMap>AbstractBidiMapTest.testBidiMapIteratorSet:560 expected same:<For> was not:<you>
  AbstractBidiMapTest$TestBidiMapIterator>AbstractMapIteratorTest.testMapIteratorSet:214 Value must be changed after setValue expected same:<newnonnullvalue> was not:<youv>
  DualTreeBidiMap2Test>AbstractBidiMapTest.testBidiMapIteratorSet:560 expected same:<For> was not:<youv>
  AbstractOrderedBidiMapTest$TestBidiOrderedMapIterator>AbstractMapIteratorTest.testMapIteratorSet:214 Value must be changed after setValue expected same:<newnonnullvalue> was not:<youv>
  AbstractSortedMapTest$TestTailMap>AbstractMapTest.testMapPut:808->AbstractSortedMapTest$TestViewMap.verify:141->AbstractMapTest.verify:1946->AbstractMapTest.verifyValues:2010 values should be same size as HashMap's
Test: []
Real: [foov] expected:<1> but was:<0>
  AbstractSortedMapTest$TestTailMap>AbstractMapTest.testMapPutAll:952->AbstractSortedMapTest$TestViewMap.verify:141->AbstractMapTest.verify:1946->AbstractMapTest.verifyValues:2010 values should be same size as HashMap's
Test: []
Real: [againv, allv, barv, bazv, blahv, foov] expected:<6> but was:<0>
  AbstractMapTest$TestMapValues>AbstractCollectionTest.testCollectionClear:638->verify:1888->AbstractCollectionTest.verify:294 Collection should not contain a value that the confirmed collection does not have: youv
Test: []
Real: []
  AbstractMapTest$TestMapValues>AbstractCollectionTest.testCollectionRemoveAll:930->verify:1888->AbstractCollectionTest.verify:294 Collection should not contain a value that the confirmed collection does not have: youv
Test: []
Real: []
  AbstractMapTest$TestMapValues>AbstractCollectionTest.testCollectionRetainAll:973->verify:1888->AbstractCollectionTest.verify:294 Collection should not contain a value that the confirmed collection does not have: youv
Test: []
Real: []
  AbstractMapTest$TestMapEntrySet>AbstractCollectionTest.testCollectionIteratorRemove:838 Collection should shrink by one after iterator.remove expected:<-1> but was:<0>
  AbstractMapTest$TestMapValues>AbstractCollectionTest.testCollectionIteratorRemove:838 Collection should shrink by one after iterator.remove expected:<-1> but was:<0>

Tests in error: 
  AbstractSortedMapTest$TestHeadMap>AbstractMapTest.testMapPut:808->AbstractSortedMapTest$TestViewMap.verify:141->AbstractMapTest.verify:1946->AbstractMapTest.verifyValues:2006 » NullPointer
  AbstractSortedMapTest$TestHeadMap>AbstractMapTest.testMapPutAll:952->AbstractSortedMapTest$TestViewMap.verify:141->AbstractMapTest.verify:1946->AbstractMapTest.verifyValues:2006 » NullPointer
  AbstractSortedMapTest$TestHeadMap>AbstractMapTest.testMapPut:808->AbstractSortedMapTest$TestViewMap.verify:141->AbstractMapTest.verify:1946->AbstractMapTest.verifyValues:2006 » NullPointer
  AbstractSortedMapTest$TestHeadMap>AbstractMapTest.testMapPutAll:952->AbstractSortedMapTest$TestViewMap.verify:141->AbstractMapTest.verify:1946->AbstractMapTest.verifyValues:2006 » NullPointer
  AbstractSortedMapTest$TestHeadMap>AbstractMapTest.testMapPut:808->AbstractSortedMapTest$TestViewMap.verify:141->AbstractMapTest.verify:1946->AbstractMapTest.verifyValues:2006 » NullPointer
  AbstractSortedMapTest$TestHeadMap>AbstractMapTest.testMapPutAll:952->AbstractSortedMapTest$TestViewMap.verify:141->AbstractMapTest.verify:1946->AbstractMapTest.verifyValues:2006 » NullPointer
",,,,,,,,,,,,,,,,,,,09/Mar/13 14:27;tn;TreeMapTest.java;https://issues.apache.org/jira/secure/attachment/12572914/TreeMapTest.java,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,314784,,,Sun Apr 21 17:48:51 UTC 2013,,,,,,0|i1ibjb:,315128,,,,,,,,"28/Feb/13 22:20;tn;Java(TM) SE Runtime Environment (build pxi3260sr12-20121025_01(SR12))
IBM J9 VM (build 2.4, JRE 1.6.0 IBM J9 2.4 Linux x86-32 jvmxi3260sr12-20121024_126067 (JIT enabled, AOT enabled)
J9VM - 20121024_126067
JIT  - r9_20120914_26057
GC   - 20120928_AA)
JCL  - 20121014_01
","06/Mar/13 21:55;tn;Test status:

Tests run: 12172, Failures: 36, Errors: 6, Skipped: 0
","06/Mar/13 21:58;tn;After first changes:

Tests run: 12172, Failures: 16, Errors: 0, Skipped: 0
",09/Mar/13 14:27;tn;Attached a set of TreeMap tests that fail with IBM JDK 6.,"21/Apr/13 17:48;tn;Ignored remaining test failures which were all related to a faulty TreeMap implementation (subMap, tailMap bulkTests).

Committed in r1470322.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
SetUniqueList may become inconsistent,COLLECTIONS-444,12633927,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,t.vahrst,t.vahrst,25/Feb/13 16:08,08/Nov/15 21:36,07/Apr/19 20:37,17/Apr/13 18:13,3.2.1,,,,,3.2.2,4.0,4.0-alpha1,List,,,,,,0,,,,"I found this bug during my work on issue COLLECTIONS-310 : 

When you 'set' an element to a position that contains this element, it is removed from the internal set. This leads to the situation that 
- invocing get() returns the element
- invocing contains() returns false.

Extending the existing test method for set:
{code}
   public void testSet() {
        final SetUniqueList<E> lset = new SetUniqueList<E>(new ArrayList<E>(), new HashSet<E>());

        // Duplicate element
        final E obj1 = (E) new Integer(1);
        final E obj2 = (E) new Integer(2);
        final E obj3 = (E) new Integer(3);

        lset.add(obj1);
        lset.add(obj2);
        lset.set(0, obj1);
        assertEquals(2, lset.size());
        assertSame(obj1, lset.get(0));
        assertSame(obj2, lset.get(1));

        assertTrue(lset.contains(obj1));  // fails !
        assertTrue(lset.contains(obj2));

{code}


",,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2013-02-25 21:48:18.954,,,false,,,,,,,,,,,,,,314421,,,Wed Apr 17 18:13:13 UTC 2013,,,,,,0|i1i9av:,314766,,,,,,,,"25/Feb/13 21:48;tn;Fixed in r1449914.

Thanks for the report!","17/Apr/13 13:46;jvasileff;SetUniqueList.set(int index, object), as currently in trunk, never calls ""set.remove(removed)"" when the new Object equals() the pre-existing Object at the index. However, the Object is removed and re-added to the underlying List by ""removed = super.set(index, object)"".

As a result, the Set and List may wind up containing different elements per ""=="". For example:

{code:java}
    Integer a1 = new Integer(1);
    Integer b1 = new Integer(1);
    ...
    lset.clear();
    lset.add(a1); // both Set and List will have a1
    lset.set(0, b1); // List will have b1, Set will have a1
{code}

While normally this won't cause problems, it does seem wrong, and prevents garbage collection of a1 in the example above.

Reverting the patch, and then simply swapping the order of ""set.add()"" and ""set.remove()"" may be a better fix for the original problem:

{code:java}
    public E set(final int index, final E object) {
        final int pos = indexOf(object);
        final E removed = super.set(index, object);

        if (pos != -1 && pos != index) {
            // the object is already in the uniq list
            // (and it hasn't been swapped with itself)
            super.remove(pos); // remove the duplicate by index
        }

        set.remove(removed); // remove the item deleted by the set
        set.add(object); // add the new item to the unique set

        return removed; // return the item deleted by the set
    }
{code}","17/Apr/13 14:26;tn;Hi John,

good catch, the object is only kept internally, but as you say, this would prevent it from being garbage-collected, thus we should change as you propose.","17/Apr/13 18:13;tn;Fixed in r1469016.

Thanks again for looking into this.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
ExtendedProperties : String only composed of spaces character,COLLECTIONS-438,12625407,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Invalid,,gchauvet,gchauvet,28/Dec/12 09:00,27/Nov/15 21:47,07/Apr/19 20:37,22/Jan/13 13:56,,,,,,,,,Collection,,,,,,0,,,,We have discovered a bug in ExtendedProperties class used in our internal language manager framework. The cause are strings which contains only spaces character. We provide a patch to complete the JUnit class ExtendedPropertiesTest.,,,,,,,,,,,,,,,,,,,28/Dec/12 09:03;gchauvet;COLLECTIONS-438.patch;https://issues.apache.org/jira/secure/attachment/12562572/COLLECTIONS-438.patch,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2013-01-20 11:57:59.472,,,false,,,,,,,,,,,,,,301949,,,Sun Jan 20 11:57:59 UTC 2013,,,,,,0|i16xlr:,248577,,,,,,,,28/Dec/12 09:03;gchauvet;Patch to include new entry in ExtendedProperties JUnit test case,"20/Jan/13 11:57;tn;The ExtendedProperties behaves in the same way as the java.util.Properties class. Values are trimmed on both sides, thus in your test case the two keys are both associated with an empty String as expected.

I do not see a problem with this.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
CollectionUtils.removeAll invoke ListUtils.retainAll !!!,COLLECTIONS-437,12625235,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Critical,Duplicate,,qxo,qxo,26/Dec/12 07:04,09/Nov/14 14:31,07/Apr/19 20:37,28/Feb/13 18:38,,,,,,4.0,4.0-alpha1,,,,,,,,0,,,,"    public static Collection removeAll(Collection collection, Collection remove) {
        return ListUtils.retainAll(collection, remove);
    }",,,,,,,,,,,,,,COLLECTIONS-219,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2012-12-29 15:08:09.991,,,false,,,,,,,,,,,,,,301779,,,Sat Dec 29 15:08:09 UTC 2012,,,,,,0|i16wgv:,248392,,,,,,,,29/Dec/12 15:08;garydgregory;Already reported and already fixed in trunk.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
CollectionUtils.removeAll() calls ListUtils.retainAll(),COLLECTIONS-435,12616040,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Duplicate,,mikolajr,mikolajr,14/Nov/12 10:13,14/Nov/12 10:26,07/Apr/19 20:37,14/Nov/12 10:26,3.2.1,,,,,,,,Collection,,,,,,0,,,,"A snippet from CollectionUtils.java:

{code:title=CollectionUtils.java}
public static Collection removeAll(Collection collection, Collection remove) {
        return ListUtils.retainAll(collection, remove);
}
{code}
It should call ListUtils.removeAll() instead.",,,,,,,,,,,,,,COLLECTIONS-219,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,257655,,,2012-11-14 10:13:40.0,,,,,,0|i0k3u7:,115439,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
performance problem in SetUniqueList.retainAll(),COLLECTIONS-427,12600099,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,mertguldur,mertguldur,24/Jul/12 23:50,27/Nov/15 21:11,07/Apr/19 20:37,27/Jan/15 15:09,3.2.1,,,,,4.0,4.0-alpha1,4.1,,,,,,,0,,,,"I am encountering a performance problem in SetUniqueList.retainAll().
It appears in version 3.2.1 and also in revision 1365132.  I attached
a test that exposes this problem and a patch that fixes it.  On my
machine, for this test, the patch provides a 621X speedup.

To run the test, just do:

$ java Test

The output for the un-patched version is:
Time is 6215

The output for the patched version is:
Time is 10

There are two problems here.  First, ""SetUniqueList.retainAll()""
should have similar implementation with the current implementation of
""ListOrderedSet.retainAll()"", which is more optimized.  Second, even
""ListOrderedSet.retainAll()"" has a performance problem, which was
reported and explained in detail in COLLECTIONS-426.

The attached patch has two parts.  The first part (the first loop) is
inspired from COLLECTIONS-426.  The second part (everything after the
first loop) is in fact the current implementation of
""ListOrderedSet.retainAll()"", with some minor changes to adapt it for
the current code.  Overall, the attached patch is very similar to the
COLLECTIONS-426 patch.

I will rehash some of the information from COLLECTIONS-426 (which
describes ""ListOrderedSet.retainAll()"") for the current
""SetUniqueList.retainAll()"".

The current code for ""SetUniqueList.retainAll()"" is:

{code:java|borderStyle=solid}
public boolean retainAll(Collection<?> coll) {
    boolean result = super.retainAll(coll);
    set.retainAll(coll);
    return result;
}
{code} 

where both ""super.retainAll(coll)"" and ""set.retainAll(coll)"" can have
quadratic complexity, e.g., if ""coll"" is a List.  Both these calls to
""retainAll"" are in fact calls to
""java.util.AbstractCollection.retainAll()"", which has the code:

{code:java|borderStyle=solid}
public boolean retainAll(Collection<?> c) {
    boolean modified = false;
    Iterator<E> e = iterator();
    while (e.hasNext()) {
        if (!c.contains(e.next())) {
            e.remove();
            modified = true;
        }
    }
    return modified;
}
{code} 

which iterates over ""this"" and calls ""contains()"" on ""c"".  Mapping
this code back to ""SetUniqueList.retainAll()"" means that the code
iterates over ""this"" and ""set"" and calls ""contains()"" on ""coll"".  If
""coll"" has slow ""contains()"" (e.g., if ""coll"" is a list), then
""SetUniqueList.retainAll()"" has quadratic complexity.

The patch iterates over ""coll"" and calls ""contains()"" on ""set"", which
we know is fast, because ""set"" is a Set.  For a more detailed
discussion of the patch and the problem, see the current
implementation of ""ListOrderedSet.retainAll()"", the discussion for
COLLECTIONS-426, and the patch for COLLECTIONS-426.

Is this a bug, or am I misunderstanding the intended behavior?  If so,
can you please confirm if the patch is correct?
","java 1.6.0_24
Ubuntu 11.10",,,,,,,,,,,,,,,,,,24/Jul/12 23:50;mertguldur;Test.java;https://issues.apache.org/jira/secure/attachment/12537770/Test.java,24/Jul/12 23:50;mertguldur;patch.diff;https://issues.apache.org/jira/secure/attachment/12537769/patch.diff,,,,,,,,2.0,,,,,,,,,,,,,,,,,,,2015-01-24 18:07:13.978,,,false,,,,,,,,,,,,,,255281,,,Tue Jan 27 15:09:58 UTC 2015,,,,,,0|i0eqnz:,84082,,,,,,,,24/Jan/15 18:07;tn;This fix is wrong imho and should be reverted in 4.1,"25/Jan/15 00:40;adriannistor;Hi Thomas,

Oh, ok.  Why is the fix wrong?  What is the bug in this fix?

Best,

Adrian","25/Jan/15 10:40;tn;The fix is technically correct but conceptually wrong.

It tries to improve the worst-case scenario for a well-known method at the expense of additional space complexity.
It many cases the additional temporary set is unneeded, especially when the provided collection has a fast contains method or the collection is small.

A user can always solve the performance problem him/herself by putting the elements in a set and provide this as parameter to retainAll.

The described problem also applies to almost *all* collection types as the default implementation of retainAll is provided in AbstractCollection and is unchanged for all the collections I know of. If you want to press forward your fix, I suggest to move it to the openjdk project and discuss it there, actually I would be interested on their opinions on this issue.","25/Jan/15 12:15;adriannistor;Hi Thomas,

> A user can always solve the performance problem him/herself by
> putting the elements in a set and provide this as parameter to
> retainAll.

Yes, but:

(1) typically users spend (a lot) of time making the code work
correctly.  Users don't want to spend time with optimizations if they
can avoid it.

(2) users needs to identify this call as a potential optimization
point, which is not easy if the buggy case is not triggered during
testing.  Furthermore, if the program-wide slowdown is small but
non-negligible (e.g., 10%), users may view it as unfortunate but
legitimate, i.e., users may not realize it can be improved.

(3) the user needs figure out there is a easy and fast way to optimize
this code.  This requires the user to look inside the method
implementation.

No user will do the above, so it is better to do it automatically if
we can.  And in this case we can do it easily and transparently in the
library.  If we can optimize something, we should do it.

> at the expense of additional space complexity.

Yes.  But typically we have memory available, speed is more difficult
to get.  And the additional space is linear in the size of c, whereas
the time improvement is huge.  And the added memory is less than half
the memory used by the SetUniqueList and is very short lived.  So the
added memory is not a problem.

> The described problem also applies to almost all collection types 

Yes, but ""others do it too"" is not a reason for us to not improve if
we can.

Overall, it is your decision.  I just feel that if we can help the
developers, we should do it.  And if others don't do it, that's their
problem, not ours.

Best,

Adrian","25/Jan/15 12:43;sebb@apache.org;The problem with unconditionally using extra memory in the hope that it will improve performance is that users who don't want or need it have no choice.
Commons code may be used in devices with limited memory; we should not assume that memory is not an issue.

Whereas if such copying is not done automatically, at least users who want to trade memory for speed can do so.","25/Jan/15 12:52;adriannistor;Hi Sebb,

> at least users who want to trade memory for speed can do so.

Ok.  Let's at least write this down in the method Javadoc, like in
COLLECTIONS-415 and COLLECTIONS-417?

Best,

Adrian","25/Jan/15 12:58;tn;Again, users need to know what they are doing and be aware of the performance constraints of the collection types they are using.
I agree that the implemented algorithm of retainAll is not explained in detail (the original Collection#retainAll method has just a reference to contains(), but does not describe the performance implications), and we will add a note as in other cases, but this is not a problem limited to commons-collections but to the collection framework of java in general.

That's why I suggested to move the discussion to openjdk. In fact, if your proposed fix would be implemented in AbstractCollection the problem would go away for almost all collection types and users would be safe (or is that so?).

On a personal note: I strongly doubt that the described problem is a ""real"" one. A quick search on stackoverflow with ""retainAll slow"" lists two posts with both suggesting to call it with a set.","25/Jan/15 15:54;adriannistor;Hi Thomas,

> users need to know what they are doing and be aware of the
> performance constraints

:-) true, and how often does that happen?

> this is not a problem limited to commons-collections

Ok, I will try this ""others do it too"" argument next time when I get a
speeding ticket.  I will let you know how that works out :-)

> devices with limited memory

Is Apache Collections optimized for such devices?  How many
optimizations for such devices do we have?  1, 2, 5?  It seems quite a
unique instance here that we are all of the sudden worrying about some
memory (less than half of this collection, and short lived).

Overall, I still think that if we can optimize something without
disadvantages (I would not count this memory thing, except the case we
are optimizing memory---small quantities of memory---in more than 5
places in the entire Apache Collections), there is no reason to not do
it.  But all the pros and cons are in this thread, so in the end do
what you think best for this library.

Best,

Adrian","25/Jan/15 17:29;tn;{quote}
> users need to know what they are doing and be aware of the
> performance constraints

true, and how often does that happen?
{quote}

I do not think it should be the goal of a general-purpose library to pre-optimize every possible use-case.

{quote}
> this is not a problem limited to commons-collections

Ok, I will try this ""others do it too"" argument next time when I get a
speeding ticket. I will let you know how that works out 
{quote}

I did not say that. I said that the retainAll() method suffers from the ""problem"" in general.
Changing it in collections, especially for some rarely used classes does not safe users from the performance problems you are talking about. I am pretty sure that ArrayList.retainAll is much, much more often used than SetUniqueList.retainAll. So why changing it here and not for ArrayList?

You are looking at the problem from a purely theoretical POV. From an engineering POV it is much more important that users get what they expect. And the retainAll method as implemented is well-known in the java community.

And again, a user can get the expected performance by putting the argument in a set himself. So where is the problem (apart from documenting it properly)?","26/Jan/15 09:21;tn;There is a similar ticket for openjdk from 2004, with a comment from Josh Bloch: https://bugs.openjdk.java.net/browse/JDK-5028425?page=com.atlassian.streams.streams-jira-plugin:activity-stream-issue-tab","27/Jan/15 15:09;tn;Reverted performance improvement, added clarifying javadoc wrt runtime complexity and did a slight improvement over the original code in r1655062.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
performance problem in ListOrderedSet.retainAll(),COLLECTIONS-426,12600077,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,adriannistor,adriannistor,24/Jul/12 22:04,27/Nov/15 21:11,07/Apr/19 20:37,27/Jan/15 15:06,3.2.1,,,,,4.0,4.0-alpha1,4.1,,,,,,,0,,,,"Hi,

I am encountering a performance problem in ListOrderedSet.retainAll().
It appears in version 3.2.1 and also in revision 1365132.  I attached
a test that exposes this problem and a patch that fixes it.  On my
machine, for this test, the patch provides a 263X speedup.

To run the test, just do:

$ java Test

The output for the un-patched version is:
Time is 3682

The output for the patched version is:
Time is 14

The problem is that the code for method
""ListOrderedSet.retainAll(Collection<?> coll)"" is:

{code:java|borderStyle=solid}
public boolean retainAll(Collection<?> coll) {
    boolean result = collection.retainAll(coll);
....
}
{code}

because ""collection.retainAll(coll)"" has quadratic complexity if
parameter ""coll"" is a List.  Conceptually, the solution is to call
""coll.retainAll(collection)"" which has linear complexity (not
quadratic), because ""collection"" is always a HashSet (we know this,
because ""collection"" is an inherited field of ListOrderedSet, and thus
cannot have another type).  See the
""java.util.AbstractCollection.retainAll()"" code inlined below for why
one call has quadratic complexity, and the other has linear
complexity.

Directly calling ""coll.retainAll(collection)"" would change the
behavior of ListOrderedSet.retainAll(), which is why the patch seems a
bit involved.  In reality, the patch simulates the behavior of
""coll.retainAll(collection)"" (which is just the intersection of two
collections).  You can easily see this by looking at the patch and at
the ""java.util.AbstractCollection.retainAll()"" code inlined below.

""collection.retainAll(coll)"" is ""java.util.HashSet.retainAll()"", which
is ""java.util.AbstractCollection.retainAll()"", which has the code:

{code:java|borderStyle=solid}
public boolean retainAll(Collection<?> c) {
    boolean modified = false;
    Iterator<E> e = iterator();
    while (e.hasNext()) {
        if (!c.contains(e.next())) {
            e.remove();
            modified = true;
        }
    }
    return modified;
}
{code} 


Is this a bug, or am I misunderstanding the intended behavior?  If so,
can you please confirm if the patch is correct?

Thanks,

Adrian
","java 1.6.0_24
Ubuntu 11.10",,,,,,,,,,,,,,,,,,24/Jul/12 22:04;adriannistor;Test.java;https://issues.apache.org/jira/secure/attachment/12537758/Test.java,24/Jul/12 22:04;adriannistor;patch.diff;https://issues.apache.org/jira/secure/attachment/12537757/patch.diff,,,,,,,,2.0,,,,,,,,,,,,,,,,,,,2015-01-24 18:06:54.124,,,false,,,,,,,,,,,,,,255280,,,Tue Jan 27 15:06:21 UTC 2015,,,,,,0|i0eqnr:,84081,,,,,,,,24/Jan/15 18:06;tn;This fix is wrong imho and should be reverted for 4.1,"25/Jan/15 00:40;adriannistor;Hi Thomas,

Oh, ok.  Why is the fix wrong?  What is the bug in this fix?

Best,

Adrian",27/Jan/15 15:06;tn;Reverted the performance improvement and added clarifying javadoc wrt runtime complexity in r1655060.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
performance problem in ListOrderedMap.remove(),COLLECTIONS-425,12600047,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,adriannistor,adriannistor,24/Jul/12 18:15,09/Nov/14 14:31,07/Apr/19 20:37,25/Jul/12 21:15,3.2.1,,,,,4.0,4.0-alpha1,,,,,,,,0,,,,"Hi,

I am encountering a performance problem in ListOrderedMap.remove().
It appears in version 3.2.1 and also in revision 1365132.  I attached
a test that exposes this problem and a simple patch that fixes it.  On
my machine, for this test, the patch provides a 213X speedup.

To run the test, just do:

$ java Test

The output for the un-patched version is:
Time is 1497

The output for the patched version is:
Time is 7

The patch changes the ""ListOrderedMap.remove(Object key)"" code from:

{code:java|borderStyle=solid}
Object result = getMap().remove(key);
insertOrder.remove(key);
{code}

to:

{code:java|borderStyle=solid}
if (decorated().containsKey(key)) {
    result = decorated().remove(key);
    insertOrder.remove(key);
}
{code}

If ""decorated()"" does not contain the key, there is no need to remove
it.  This change significantly speeds up the code by avoiding the call
to ""insertOrder.remove(key)"", which is very expensive because
""insertOrder"" is an ArrayList, and removing from an ArrayList is a
linear time operation.

It may appear that the check ""if (decorated().containsKey(key))"" may
slow down the code when ""decorated()"" contains the key, because it
adds a new operation ""decorated().containsKey(key)"", without avoiding
the calls to ""getMap().remove(key)"" and ""insertOrder.remove(key)"".

I attached a test, TestWorstCase.java, that show that, even when
removing only existing keys (i.e., ""decorated().containsKey(key)""
always returns ""true""), the patched version takes almost the same time
as the un-patched version.

To run TestWorstCase, just do:

$ java TestWorstCase

The output for the un-patched version for TestWorstCase is:
Time is 96

The output for the patched version for TestWorstCase is:
Time is 97

The reason why the patch does not slow down the code, even for this
worst case, is because ""decorated().containsKey(key)"" is a
""containsKey()"" on a HashMap (very fast, constant time operation),
whereas ""insertOrder.remove(key);"" is a ""remove()"" on an ArrayList
(very slow, linear time operation).  So the time taken by
""decorated().containsKey(key)"" is negligible compared to the time
taken by ""insertOrder.remove(key);"".  In other words, most of the time
is spent inside ""insertOrder.remove(key)"", and performing one
additional fast operation cannot be noticed.

Is this truly a bug? If so, can you please confirm if the patch is
correct?

Thanks,

Adrian
","java 1.6.0_24
Ubuntu 11.10",,,,,,,,,,,,,,,,,,24/Jul/12 18:15;adriannistor;Test.java;https://issues.apache.org/jira/secure/attachment/12537722/Test.java,24/Jul/12 18:15;adriannistor;TestWorstCase.java;https://issues.apache.org/jira/secure/attachment/12537723/TestWorstCase.java,24/Jul/12 18:15;adriannistor;patch.diff;https://issues.apache.org/jira/secure/attachment/12537721/patch.diff,,,,,,,3.0,,,,,,,,,,,,,,,,,,,2012-07-25 21:15:28.318,,,false,,,,,,,,,,,,,,292941,,,Wed Jul 25 21:15:28 UTC 2012,,,,,,0|i0shov:,164343,,,,,,,,25/Jul/12 21:15;tn;Fixed in r1365749. Thanks for the report and patch!,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Surprising exception by CompositeSet in a situation where CompositeCollection works fine,COLLECTIONS-424,12599826,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,michaelpradel,michaelpradel,23/Jul/12 09:07,09/Nov/14 14:31,07/Apr/19 20:37,17/Mar/13 10:03,3.2.1,,,,,4.0,4.0-alpha1,,Set,,,,,,0,,,,"We have a method that uses a CompositeCollection. Here's a simplified version of it:

  void m(CompositeCollection coll) {
    coll.addComposited(new TreeBag());
  }

It works fine when the argument is a CompositeCollection, but it throws an exception when the argument is a CompositeSet. E.g.:

  m(new CompositeCollection());  // OK
  m(new CompositeSet());         // IllegalArgumentException

Although the exception is documented in CompositeSet, this behavior is very surprising. Is there a way to have m() accept CompositeCollections without running into this exception? The only solution that comes to my mind is to dynamically check the type of 'coll' in m(), but this is a rather nasty work-around.


A better solution may be to make the genericity of CompositeCollection explicit by adding a type parameter:

  class CompositeCollection<T extends Collection> {
    void addComposited(T c) { /* .. */ }
  }
	
  class CompositeSet extends CompositeCollection<Set> {
    @Override void addComposited(Set c) { /* .. */ }
  }

This way, users of CompositeCollection must choose the kind of collections that can be composed and will not encounter surprises, such as the above.
",All environments,,,,,,,,,,,,,,,,,,10/Mar/13 20:40;tn;COLLECTIONS-424.patch;https://issues.apache.org/jira/secure/attachment/12572989/COLLECTIONS-424.patch,31/Aug/12 20:54;srirangadeepthi;collections424.patch;https://issues.apache.org/jira/secure/attachment/12543337/collections424.patch,,,,,,,,2.0,,,,,,,,,,,,,,,,,,,2012-07-24 16:43:14.996,,,false,,,,,,,,,,,,,,244856,,,Sun Mar 17 10:03:19 UTC 2013,,,,,,0|i05uav:,32006,,,,,,,,24/Jul/12 16:43;srirangadeepthi;I started working on this issue..but wondering how to assign this issue to myself..Can anybody help me on this..,"24/Jul/12 20:55;tn;Hi srirangadeepthi,

you can attach patches for this specific problem directly to the issue, there is no need to assign the issue itself to you.

Thomas","31/Aug/12 21:03;srirangadeepthi;I have uploaded the patch. Here is the brief explanation of the changes i made in the current files.

1. Composite Collection holds the collections added to it in List<E> instead of List<Collection<E>>.This solves the issue of type checking in the code as mentioned in the bug.

2. I see add() and addComposited() performing the same functionality according to the current version.Whereas according to the apache commons collections doc,the functionalities are supposed to be different as shown below.

add(java.lang.Object obj)
          Adds an object to the collection, throwing UnsupportedOperationException unless a CollectionMutator strategy is specified.

addAll(java.util.Collection coll)
          Adds a collection of elements to this collection, throwing UnsupportedOperationException unless a CollectionMutator strategy is specified.

addComposited(java.util.Collection c)
          Add an additional collection to this composite.

But according to the current version,both does the same thing.In that case i don't see the need of having two methods for the same functionality.So i changed the functionality of the methods according to the document.

3. I changed the junit test cases accordingly and uploaded in the patch.",09/Sep/12 14:52;srirangadeepthi;Hi..just wanted to remind about the patch uploaded.,"20/Sep/12 18:25;tn;Hi,

thanks for providing the patch, but unfortunately I am not sure if it goes into the right direction. Constraining a CompositeCollection to just one specific collection type is against the idea of the class (to provide a composite interface for a set of collections). Also the type safety for the element type is lost due to the fact that CompositeCollections extends Collection<Object>.

Tbh, I am more in favor of rejecting this issue or removing the inheritance to CompositeCollection in CompositeSet as there is no real need for it apart from code re-use.","07/Mar/13 20:45;tn;I would be in favor of removing the inheritance of CompositeCollection, as it violates the [Liskov substitution principle|http://en.wikipedia.org/wiki/Liskov_substitution_principle]:

 a CompositeSet is *not* a CompositeCollection, and can not replace one

Any objections?","10/Mar/13 20:40;tn;The patch removes the inheritance to CompositeCollection and cleans up the code with everything that does not make sense for a CompositeSet.

We also can not extend a composite set / collection with collections containing subtypes (e.g. Set<? extends E>) as this may lead to undefined behavior.

Consider the following case:

class A
class B extends A

a CompositeSet set which is composed of a Set<A> and a Set<B>

if set.add(A) would be called, the mutator could decide to add A to the Set<B> which in turn will lead to runtime errors.",17/Mar/13 10:03;tn;Applied patch in r1457410.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
FastArrayList.toString() fails to check for reference to itself,COLLECTIONS-423,12599824,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Won't Fix,,michaelpradel,michaelpradel,23/Jul/12 09:05,27/Nov/15 21:47,07/Apr/19 20:37,26/Aug/12 21:06,3.2.1,,,,,,,,List,,,,,,0,,,,"FastArrayList.toString() throws a StackOverflowError when the list contains itself, because toString() is called recursively. In contrast, ArrayList checks for this case and deals with it appropriately. E.g.:

  ArrayList l = new FastArrayList();
  l.add(l);
  l.toString(); // StackOverflowError

But:

  ArrayList l = new ArrayList();
  l.add(l);
  l.toString(); // OK
	
To be compatible with its superclass, FastArrayList should also consider this special case.",All environments,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2012-07-25 18:59:37.3,,,false,,,,,,,,,,,,,,255282,,,Wed Jul 25 18:59:37 UTC 2012,,,,,,0|i0eqo7:,84083,,,,,,,,"25/Jul/12 18:59;tn;Hi Michael,

thanks for your bug report. It is unlikely that there will be a 3.2.2 release and the FastArrayList has been dropped for future major releases (currently preparing release 4.0) in favor of CopyOnWriteArrayList which is available from the standard JDK.

Thomas",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Update JavaDoc in ListUtils to discribe generified methods,COLLECTIONS-421,12597903,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Trivial,Fixed,,britter,britter,07/Jul/12 14:47,09/Nov/14 14:31,07/Apr/19 20:37,14/Jul/12 21:36,,,,,,4.0,4.0-alpha1,,Collection,,,,,,0,,,,The JavaDoc of {{ListUtils.lazyList()}} and {{ListUtils.fixedSizeList}} still refer to the old methods prior to generics. This should be updated.,,,,,,,,,,,,,,,,,,,07/Jul/12 14:52;britter;COLLECTIONS-421.patch;https://issues.apache.org/jira/secure/attachment/12535530/COLLECTIONS-421.patch,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2012-07-14 21:36:54.081,,,false,,,,,,,,,,,,,,292942,,,Sun Jul 15 11:48:26 UTC 2012,,,,,,0|i0shp3:,164344,,,,,,,,"07/Jul/12 14:52;britter;Sorry, I've created this issue with the wrong type. Should be Improvement.

I've attached a patch. It just contains JavaDoc changes.
",14/Jul/12 21:36;tn;Thanks for the patch! Applied together with other small fixes in r1361590.,"15/Jul/12 11:35;britter;Hi Thomas,

thanks for taking care of this. Is there a reason why you didn't change 
{{After the above code is executed, <code>date</code> will contain a new <code>Date</code> instance.}}
to 
{{After the above code is executed, <code>date</code> will refer to a new <code>Date</code> instance.}}
as I suggested? IMHO the date variable is a reference to an instance of type {{Date}}. So ""refer to"" is a bit more precise than ""contain a"".

Regards,
Benedikt","15/Jul/12 11:48;tn;You are right, I just missed it, done in r1361690.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
CompositeCollection.containsAll() is very slow,COLLECTIONS-420,12596483,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Won't Fix,,adriannistor,adriannistor,30/Jun/12 01:05,27/Nov/15 21:47,07/Apr/19 20:37,26/Aug/12 21:25,3.2.1,,,,,,,,,,,,,,0,,,,"Hi,

I am encountering a performance problem in
CompositeCollection.containsAll().  It appears in version 3.2.1 and
also in revision 1355448.  I attached a test that exposes this problem
and a patch that fixes it.  On my machine, for this test, the patch
provides a 167X speedup.

To run the test, just do:

$ java Test

The output for the un-patched version is:
Time is 9192

The output for the patched version is:
Time is 54

The problem is that 
""CompositeCollection.containsAll(Collection<?> coll)"" performs 
""contains(item)"" for each item in ""coll"", and ""contains(item)""
searches ""item"" in all collections in CompositeCollection.  This can
be very slow if the collections in CompositeCollection have slow
""contains()"", e.g., when these collections are lists.

The patch I attached puts the elements in each collection of
CompositeCollection in a HashSet (which has very fast ""contains()"") if
that collection is not already a set.  For efficiency, putting
elements in several HashSet objects is performed lazily in the patch.

Is this a bug, or am I misunderstanding the intended behavior?  If so,
can you please confirm that the patch is correct?

Thanks,

Adrian
","java 1.6.0_24
Ubuntu 11.10",,,,,,,,,,,,,,,,,,30/Jun/12 01:05;adriannistor;Test.java;https://issues.apache.org/jira/secure/attachment/12534082/Test.java,30/Jun/12 01:05;adriannistor;patch.diff;https://issues.apache.org/jira/secure/attachment/12534081/patch.diff,,,,,,,,2.0,,,,,,,,,,,,,,,,,,,2012-08-26 21:25:18.229,,,false,,,,,,,,,,,,,,255283,,,Sun Aug 26 21:25:18 UTC 2012,,,,,,0|i0eqof:,84084,,,,,,,,"26/Aug/12 21:25;tn;CompositeCollection is a decorator for existing collections. Operations shall not alter the backing collections. To support a unified view on collections with a fast contains, users should better use a CompositeSet and convert the collections to a set themselves.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
ListUtils.retainAll() is very slow,COLLECTIONS-418,12596465,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Won't Fix,,adriannistor,adriannistor,29/Jun/12 22:16,27/Nov/15 21:47,07/Apr/19 20:37,26/Aug/12 21:32,3.2.1,,,,,,,,,,,,,,0,,,,"Hi,

I am encountering a performance problem in ListUtils.retainAll().  It
appears in version 3.2.1 and also in revision 1355448.  I attached a
test that exposes this problem and a one-line patch that fixes it.  On
my machine, for this test, the patch provides a 238X speedup.

To run the test, just do:

$ java Test

The output for the un-patched version is:
Time is 5485

The output for the patched version is:
Time is 23

As the patch shows, the problem is that
""ListUtils.retainAll(Collection<E> collection, Collection<?> retain)""
performs ""retain.contains(obj)"" for each element in ""collection"",
which can be very expensive if ""retain.contains(obj)"" is expensive,
e.g., when ""retain"" is a list.

The one-line patch I attached puts the elements of ""retain"" in a
HashSet (which has very fast ""contains()""), if ""retain"" is not already
a set:

""if (!(retain instanceof java.util.Set<?>)) retain = new HashSet<Object>(retain);""

Is this a bug, or am I misunderstanding the intended behavior? If so,
can you please confirm that the patch is correct?

Thanks,

Adrian
","java 1.6.0_24
Ubuntu 11.10",,,,,,,,,,,,,,,,,,29/Jun/12 22:16;adriannistor;Test.java;https://issues.apache.org/jira/secure/attachment/12534059/Test.java,29/Jun/12 22:16;adriannistor;patch.diff;https://issues.apache.org/jira/secure/attachment/12534058/patch.diff,,,,,,,,2.0,,,,,,,,,,,,,,,,,,,2012-08-26 21:32:46.002,,,false,,,,,,,,,,,,,,255284,,,Sun Aug 26 21:32:46 UTC 2012,,,,,,0|i0eqon:,84085,,,,,,,,26/Aug/12 21:32;tn;Added to the javadoc a clarification on the runtime complexity of the method. Users shall use a data structure for the elements to be retained which supports a fast implementation of contains.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
AbstractLinkedList.retainAll() is very slow,COLLECTIONS-417,12596461,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,adriannistor,adriannistor,29/Jun/12 22:01,09/Nov/14 14:31,07/Apr/19 20:37,20/Sep/12 18:07,3.2.1,,,,,4.0,4.0-alpha1,,,,,,,,0,,,,"Hi,

I am encountering a performance problem in
AbstractLinkedList.retainAll().  It appears in version 3.2.1 and also
in revision 1355448.  I attached a test that exposes this problem and
a one-line patch that fixes it.  On my machine, for this test, the
patch provides a 158X speedup.

To run the test, just do:

$ java Test

The output for the un-patched version is:
Time is 5531

The output for the patched version is:
Time is 35

As the patch shows, the problem is that
""AbstractLinkedList.retainAll(Collection<?> coll)"" performs
""coll.contains(it.next())"" for each element in the AbstractLinkedList,
which can be very expensive if ""coll.contains()"" is expensive, e.g.,
when ""coll"" is a list.

The one-line patch I attached puts the elements of ""coll"" in a HashSet
(which has very fast ""contains()""), if ""coll"" is not already a set:

""if (!(coll instanceof java.util.Set<?>)) coll = new java.util.HashSet<Object>(coll);""

Is this a bug, or am I misunderstanding the intended behavior? If so,
can you please confirm that the patch is correct?

Thanks,

Adrian
","java 1.6.0_24
Ubuntu 11.10",,,,,,,,,,,,,,,,,,29/Jun/12 22:01;adriannistor;Test.java;https://issues.apache.org/jira/secure/attachment/12534056/Test.java,30/Aug/12 23:05;adriannistor;docPatch.diff;https://issues.apache.org/jira/secure/attachment/12543186/docPatch.diff,29/Jun/12 22:01;adriannistor;patch.diff;https://issues.apache.org/jira/secure/attachment/12534055/patch.diff,,,,,,,3.0,,,,,,,,,,,,,,,,,,,2012-09-20 18:07:52.617,,,false,,,,,,,,,,,,,,244858,,,Thu Sep 20 18:07:52 UTC 2012,,,,,,0|i05ubb:,32008,,,,,,,,"30/Aug/12 23:05;adriannistor;I am attaching a patch with the javadoc clarification on the runtime
complexity of the method.  This javadoc patch is almost identical to
the javadoc added for COLLECTIONS-416 and COLLECTIONS-418.  As
discussed in COLLECTIONS-416, users should use a data structure for
the elements to be retained which supports a fast implementation of
contains.",20/Sep/12 18:07;tn;Applied patch in r1388146. Thanks for the patch!,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
ListUtils.removeAll() is very slow,COLLECTIONS-416,12596453,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Won't Fix,,adriannistor,adriannistor,29/Jun/12 21:09,27/Nov/15 21:47,07/Apr/19 20:37,25/Jul/12 21:40,3.2.1,,,,,,,,,,,,,,0,,,,"Hi,

I am encountering a performance problem in ListUtils.removeAll().  It
appears in version 3.2.1 and also in revision 1355448.  I attached a
test that exposes this problem and a one-line patch that fixes it.  On
my machine, for this test, the patch provides a 217X speedup.

To run the test, just do:

$ java Test

The output for the un-patched version is:
Time is 5430

The output for the patched version is:
Time is 25

As the patch shows, the problem is that
""ListUtils.removeAll(Collection<E> collection, Collection<?> remove)""
performs ""remove.contains(obj)"" for each element in ""collection"",
which can be very expensive if ""remove.contains(obj)"" is expensive,
e.g., when ""remove"" is a list.

The one-line patch I attached puts the elements of ""remove"" in a
HashSet (which has very fast ""contains()""), if ""remove"" is not already
a set:

""if (!(remove instanceof java.util.Set<?>)) remove = new HashSet<Object>(remove);""

Is this a bug, or am I misunderstanding the intended behavior? If so,
can you please confirm that the patch is correct?

Thanks,

Adrian
","java 1.6.0_24
Ubuntu 11.10",,,,,,,,,,,,,,,,,,29/Jun/12 21:09;adriannistor;Test.java;https://issues.apache.org/jira/secure/attachment/12534042/Test.java,29/Jun/12 21:09;adriannistor;patch.diff;https://issues.apache.org/jira/secure/attachment/12534041/patch.diff,,,,,,,,2.0,,,,,,,,,,,,,,,,,,,2012-07-03 21:50:35.038,,,false,,,,,,,,,,,,,,292943,,,Wed Jul 25 21:42:45 UTC 2012,,,,,,0|i0shpb:,164345,,,,,,,,"03/Jul/12 21:50;tn;Hi Adrian,

in this case (similar to the other issues like COLLECTIONS-415, 417, 418) I am not sure if the proposed patch is the right way to go. I would actually prefer to document the behavior of the method and to make it clear that removeAll will call contains() on the collection to be removed, so that users have to use a collection that supports this operation fast, e.g. by wrapping it themselves in the same way as outlined in the patch.","03/Jul/12 23:11;adriannistor;Hi Thomas,

Yes, you are absolutely right, my patch:

""if (!(remove instanceof java.util.Set<?>)) remove = new HashSet<Object>(remove);""

assumes that anything else except Set has slow contains(), which is
false.

Maybe the best tradeoff is to document this problem, just like you
said, and handle the most common case of slow contains(), i.e., when
the collection is a list:

""if (remove instanceof java.util.List) remove = new HashSet<Object>(remove);""

The scalable solution would be to have a helper method, presumably in
CollectionUtils:

public static <E> Collection<E> createFastContainsCollection(Collection<E> c) {
   return (c instanceof List<E>) ? new HashSet<E>(c) : c;
}

and use it when the complexity of contains() affects the complexity of
the algorithm.  This is similar with choosing your algorithm based on
if a collection implements java.util.RandomAccess or not.

Best,

Adrian

","15/Jul/12 15:41;tn;Hi Adrian,

maybe this case is not as clear as for example COLLECTIONS-420. I think that users should use the proper data structures for their use-cases and we should be careful to not just mimick HashSet behavior regardless of what comes along. If somebody provides a List to removeAll, he/she needs to be aware that this will slow things down, and that a different data structure would be more appropriate (IF it contains lots of data of course, when there are just 1 or 2 elements it makes not much of a difference).

Other people may have different opinions on this?

Thomas","16/Jul/12 14:31;adriannistor;Hi Thomas,

Sure, I agree, documenting this behavior is equally good.

Best,

Adrian

",25/Jul/12 21:40;tn;Added clarifying javadoc to the method in r1365784.,"25/Jul/12 21:42;tn;Resolved as ""Won't Fix"". The user is responsible for using proper data structures as argument to this method. This is also inline with the jdk whenever there are are methods that take a Collection as input.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
AbstractLinkedList.removeAll() is very slow,COLLECTIONS-415,12596451,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,adriannistor,adriannistor,29/Jun/12 21:02,09/Nov/14 14:31,07/Apr/19 20:37,20/Sep/12 18:08,3.2.1,,,,,4.0,4.0-alpha1,,,,,,,,0,,,,"Hi,

I am encountering a performance problem in
AbstractLinkedList.removeAll().  It appears in version 3.2.1 and also
in revision 1355448.  I attached a test that exposes this problem and
a one-line patch that fixes it.  On my machine, for this test, the
patch provides a 226X speedup.

To run the test, just do:

$ java Test

The output for the un-patched version is:
Time is 5655

The output for the patched version is:
Time is 25

As the patch shows, the problem is that
""AbstractLinkedList.removeAll(Collection<?> coll)"" performs
""coll.contains(it.next())"" for each element in the AbstractLinkedList,
which can be very expensive if ""coll.contains()"" is expensive, e.g.,
when ""coll"" is a list.

The one-line patch I attached puts the elements of ""coll"" in a HashSet
(which has very fast ""contains()""), if ""coll"" is not already a set:

""if (!(coll instanceof java.util.Set<?>)) coll = new java.util.HashSet<Object>(coll);""

Is this a bug, or am I misunderstanding the intended behavior? If so,
can you please confirm that the patch is correct?

Thanks,

Adrian
","java 1.6.0_24
Ubuntu 11.10",,,,,,,,,,,,,,,,,,29/Jun/12 21:02;adriannistor;Test.java;https://issues.apache.org/jira/secure/attachment/12534040/Test.java,30/Aug/12 22:58;adriannistor;docPatch.diff;https://issues.apache.org/jira/secure/attachment/12543183/docPatch.diff,29/Jun/12 21:02;adriannistor;patch.diff;https://issues.apache.org/jira/secure/attachment/12534039/patch.diff,,,,,,,3.0,,,,,,,,,,,,,,,,,,,2012-09-20 18:08:08.594,,,false,,,,,,,,,,,,,,244857,,,Thu Sep 20 18:08:08 UTC 2012,,,,,,0|i05ub3:,32007,,,,,,,,"30/Aug/12 22:58;adriannistor;I am attaching a patch with the javadoc clarification on the runtime
complexity of the method.  This javadoc patch is almost identical to
the javadoc added for COLLECTIONS-416 and COLLECTIONS-418.  As
discussed in COLLECTIONS-416, users should use a data structure for
the elements to be removed which supports a fast implementation of
contains.
","20/Sep/12 18:08;tn;Applied patch in r1388146. Thanks for the patch!
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Collections does not compile with openjdk 1.6.0_24,COLLECTIONS-414,12595681,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,tn,tn,23/Jun/12 12:31,09/Nov/14 14:31,07/Apr/19 20:37,15/Jul/12 11:19,Nightly Builds,,,,,4.0,4.0-alpha1,,,,,,,,0,,,,"There are several classes for which generic type inference does not work when using the openjdk 1.6.0_24 compiler:

{noformat}
[ERROR] /home/tn/workspace/apache/commons-collections/src/main/java/org/apache/commons/collections/functors/OnePredicate.java:[66,38] invalid inferred types for T; actual arguments do not conforms to inferred formal arguments
[ERROR] required: org.apache.commons.collections.Predicate<? super java.lang.Object>[]
[ERROR] found: org.apache.commons.collections.Predicate<? super T>[]
{noformat}

This is mainly due to re-using a method argument that is restricted by Predicate<? super T> to assign methods results of type Predicate<T>.

The eclipse compiler does not report an error in these cases.",,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2012-06-23 13:06:28.46,,,false,,,,,,,,,,,,,,292944,,,Sat Jun 23 14:35:41 UTC 2012,,,,,,0|i0shpj:,164346,,,,,,,,"23/Jun/12 13:06;hudson;Integrated in commons-collections #31 (See [https://builds.apache.org/job/commons-collections/31/])
    [COLLECTIONS-414] Fix type inference problems. (Revision 1353123)

     Result = SUCCESS
tn : http://svn.apache.org/viewvc/?view=rev&rev=1353123
Files : 
* /commons/proper/collections/trunk/src/main/java/org/apache/commons/collections/functors/ChainedClosure.java
* /commons/proper/collections/trunk/src/main/java/org/apache/commons/collections/functors/ChainedTransformer.java
* /commons/proper/collections/trunk/src/main/java/org/apache/commons/collections/functors/NonePredicate.java
* /commons/proper/collections/trunk/src/main/java/org/apache/commons/collections/functors/OnePredicate.java
* /commons/proper/collections/trunk/src/main/java/org/apache/commons/collections/functors/SwitchClosure.java
* /commons/proper/collections/trunk/src/main/java/org/apache/commons/collections/functors/SwitchTransformer.java
","23/Jun/12 13:32;tn;This is related to the following bugs:

http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6302954
https://bugs.eclipse.org/bugs/show_bug.cgi?id=98379","23/Jun/12 14:35;hudson;Integrated in commons-collections #32 (See [https://builds.apache.org/job/commons-collections/32/])
    [COLLECTIONS-414] work-around for test-case when providing null argument to static method that infers return type based on input argument. (Revision 1353130)

     Result = SUCCESS
tn : http://svn.apache.org/viewvc/?view=rev&rev=1353130
Files : 
* /commons/proper/collections/trunk/src/test/java/org/apache/commons/collections/TestCollectionUtils.java
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Performance problem in DualHashBidiMap,COLLECTIONS-413,12595468,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,adriannistor,adriannistor,21/Jun/12 18:38,09/Nov/14 14:31,07/Apr/19 20:37,23/Jun/12 12:06,3.2.1,,,,,4.0,4.0-alpha1,,,,,,,,0,,,,"Hi,

I am encountering a performance problem in DualHashBidiMap.  It
appears in version 3.2.1 and also in revision 1352574 (21 June 2012).
I attached a test that exposes this problem and a patch that fixes it.
On my machine, for this test, the patch provides a 173X speedup.

To run the test, just do:

$ java Test

The output for the un-patched version is:
Time is 5029

The output for the patched version is:
Time is 29

The attached test shows that, for a ""DualHashBidiMap bidi"" object, the
following operation is very slow:

bidi.entrySet().removeAll(toRemove);

DualHashBidiMap.entrySet() returns a
""DualHashBidiMap.EntrySet"" object, which inherits 
removeAll(Collection<?> coll) from ""DualHashBidiMap.View"".  

As the patch shows, the problem is that
""DualHashBidiMap.View.removeAll(Collection<?> coll)"" performs
""coll.contains(it.next())"" for each element in the View.
""coll.contains(it.next())"" can be very slow, e.g., if ""coll"" is a
list.

The patch avoids this cost by using remove(Object obj) (defined in
""EntrySet<K, V>"", ""KeySet<K>"", and ""Values<V>""), which is fast because
it uses only operations on sets.

Is this a bug, or am I misunderstanding something? If so, can you
please confirm that the patch is correct?

Thanks,

Adrian


","java 1.6.0_24
Ubuntu 11.10",,,,,,,,,,,,,,,,,,21/Jun/12 18:39;adriannistor;Test.java;https://issues.apache.org/jira/secure/attachment/12532923/Test.java,22/Jun/12 23:32;adriannistor;removeAll.diff;https://issues.apache.org/jira/secure/attachment/12533130/removeAll.diff,,,,,,,,2.0,,,,,,,,,,,,,,,,,,,2012-06-23 12:06:24.049,,,false,,,,,,,,,,,,,,292945,,,Sat Jun 23 12:35:26 UTC 2012,,,,,,0|i0shpr:,164347,,,,,,,,"23/Jun/12 12:06;tn;Applied patch in r1353115.

Thanks for reporting and providing a patch!","23/Jun/12 12:35;hudson;Integrated in commons-collections #30 (See [https://builds.apache.org/job/commons-collections/30/])
    [COLLECTIONS-413] Improve performance of DualBidiMap#removeAll. Thanks to Adrian Nistor for report and patch. (Revision 1353115)

     Result = SUCCESS
tn : http://svn.apache.org/viewvc/?view=rev&rev=1353115
Files : 
* /commons/proper/collections/trunk/src/main/java/org/apache/commons/collections/bidimap/AbstractDualBidiMap.java
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
CollectionUtils.subtract() is very slow,COLLECTIONS-412,12595338,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,adriannistor,adriannistor,20/Jun/12 20:44,09/Nov/14 14:31,07/Apr/19 20:37,23/Jun/12 11:34,,,,,,4.0,4.0-alpha1,,,,,,,,0,,,,"Hi,

I am encountering a performance problem in CollectionUtils.subtract().
It appears in version 3.2.1 and also in revision 1352300 (20 June
2012).  I attached a test that exposes this problem and a patch that
fixes it.  On my machine, for this test, the patch provides a 204X
speedup.

To run the test, just do:

$ java Test

The output for the un-patched version is:
Time is 11036

The output for the patched version is:
Time is 54

The root cause of this problem is similar to the root cause of the
previously fixed COLLECTIONS-406 in ListUtils.subtract(), i.e.,
quadratic complexity instead of linear complexity.  This problem
affects two methods:

CollectionUtils.subtract(final Iterable<? extends O> a, final Iterable<? extends O> b)
and
CollectionUtils.subtract(final Iterable<? extends O> a, final Iterable<? extends O> b, final Predicate<O> p)

because the former just calls the latter.

Currently, the code for
""CollectionUtils.subtract(final Iterable<? extends O> a, final Iterable<? extends O> b, final Predicate<O> p)""
is:

ArrayList<O> list = new ArrayList<O>();
addAll(list, a);
for (O element : b) {
    if (p.evaluate(element)) {
        list.remove(element);
    }
}

which is quadratic, because ""list.remove(element)"" has linear
complexity for ""ArrayList<O> list = new ArrayList<O>()"".

The attached patch makes the remove() be constant complexity by
removing from an org.apache.commons.collections.bag.HashBag.  The
attached patch is very similar to the patch of COLLECTIONS-406, so I
assume the risk of applying this patch is minimal.  Just like in the
patch for COLLECTIONS-406, this patch uses a HashBag (and not a
HashSet) to respect cardinality when there are repeated objects.

Can you please confirm if the patch is correct?

Thanks,

Adrian

","java 1.6.0_24
Ubuntu 11.10",,,,,,,,,,,,,,,,,,20/Jun/12 20:44;adriannistor;Test.java;https://issues.apache.org/jira/secure/attachment/12532761/Test.java,20/Jun/12 20:44;adriannistor;patch.diff;https://issues.apache.org/jira/secure/attachment/12532760/patch.diff,,,,,,,,2.0,,,,,,,,,,,,,,,,,,,2012-06-23 11:34:06.376,,,false,,,,,,,,,,,,,,292946,,,Sat Jun 23 12:01:09 UTC 2012,,,,,,0|i0shpz:,164348,,,,,,,,"23/Jun/12 11:34;tn;Fixed in r1353111.

I did not apply the patch, but rather changed the method in a similar way as outlined in the patch. Instead of evaluating the predicate on all elements of A, only elements of B that satisfy the predicate are added to a bag. The rest is similar to the patch.

Also added more information in the javadoc how the resulting collection will look like depending on the predicate evaluation.

Thanks for reporting and the patch!","23/Jun/12 12:01;hudson;Integrated in commons-collections #29 (See [https://builds.apache.org/job/commons-collections/29/])
    [COLLECTIONS-412] Improved performance of CollectionUtils#subtract. Thanks to Adrian Nistor for report and patch. (Revision 1353111)

     Result = FAILURE
tn : http://svn.apache.org/viewvc/?view=rev&rev=1353111
Files : 
* /commons/proper/collections/trunk/src/main/java/org/apache/commons/collections/CollectionUtils.java
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Exception in ListOrderedMap.putAll(),COLLECTIONS-411,12595281,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,adriannistor,adriannistor,20/Jun/12 15:45,09/Nov/14 14:31,07/Apr/19 20:37,20/Jun/12 17:54,,,,,,4.0,4.0-alpha1,,,,,,,,0,,,,"Hi,

I am encountering an IndexOutOfBoundsException in
ListOrderedMap.putAll(int index, Map<? extends K, ? extends V> map).
It appears in revision 1351903 (20 June 2012).  I have attached a test
that exposes this problem.

To run the test, just do:

$ java Test

The output is:

......................................................................
Exception in thread ""main"" java.lang.IndexOutOfBoundsException: Index: 5, Size: 4
        at java.util.ArrayList.add(ArrayList.java:367)
        at org.apache.commons.collections.map.ListOrderedMap.put(ListOrderedMap.java:437)
        at org.apache.commons.collections.map.ListOrderedMap.putAll(ListOrderedMap.java:245)
        at Test.main(Test.java:19)
......................................................................

The documentation does not specify anything like this.  Is this a bug,
or should the documentation just be updated?  If the former, is there
a patch for it?

Thanks,

Adrian


","java 1.6.0_24
Ubuntu 11.10",,,,,,,,,,,,,,,,,,20/Jun/12 15:45;adriannistor;Test.java;https://issues.apache.org/jira/secure/attachment/12532714/Test.java,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2012-06-20 17:54:27.938,,,false,,,,,,,,,,,,,,292947,,,Wed Jun 20 17:54:27 UTC 2012,,,,,,0|i0shq7:,164349,,,,,,,,"20/Jun/12 17:54;tn;Fixed in r1352235.

The problem was that when a key was replaced, the insert index was not adjusted accordingly.

Thanks for reporting!",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
SetUniqueList.addAll() is very slow,COLLECTIONS-410,12595162,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,adriannistor,adriannistor,19/Jun/12 20:37,09/Nov/14 14:31,07/Apr/19 20:37,20/Jun/12 18:04,,,,,,4.0,4.0-alpha1,,,,,,,,0,,,,"Hi,

I am encountering a performance problem in SetUniqueList.addAll().  It
appears in revision 1351837 (19 June 2012).  I attached a test that
exposes this problem and a patch that fixes it.  On my machine, for
this test, the patch provides a 540X speedup.

To run the test, just do:

$ java Test

The output for the un-patched version is:
Time is 2706

The output for the patched version is:
Time is 5

As the patch shows, the problem is that
SetUniqueList.addAll(int index, Collection<? extends E> coll)
performs:
""add(index, e)"" for each element in ""coll"". This is very expensive, 
because each ""add(index, e)"" performs a 
LinkedList.add(int index, E element), which requires traversing the 
LinkedList to find the index.

The patched version avoids this cost by inserting all the elements at
once, thus performing only one insert.

Is this a bug? If so, can you please confirm that the patch is
correct?

Thanks,

Adrian
","java 1.6.0_24
Ubuntu 11.10",,,,,,,,,,,,,,,,,,19/Jun/12 20:37;adriannistor;Test.java;https://issues.apache.org/jira/secure/attachment/12532604/Test.java,19/Jun/12 20:37;adriannistor;patch.diff;https://issues.apache.org/jira/secure/attachment/12532603/patch.diff,,,,,,,,2.0,,,,,,,,,,,,,,,,,,,2012-06-20 18:04:42.911,,,false,,,,,,,,,,,,,,292948,,,Wed Jun 20 20:58:53 UTC 2012,,,,,,0|i0shqf:,164350,,,,,,,,"20/Jun/12 18:04;tn;Applied patch in r1352243.

Thanks for reporting!","20/Jun/12 18:32;hudson;Integrated in commons-collections #27 (See [https://builds.apache.org/job/commons-collections/27/])
    [COLLECTIONS-410] Improved performance of SetUniqueList.addAll(index, coll). Thanks to Adrian Nistor for reporting and providing a patch. (Revision 1352243)

     Result = UNSTABLE
tn : http://svn.apache.org/viewvc/?view=rev&rev=1352243
Files : 
* /commons/proper/collections/trunk/src/main/java/org/apache/commons/collections/list/SetUniqueList.java
","20/Jun/12 20:58;tn;The failing unit test on hudson/jenkins has been fixed in r1352264.
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
ListOrderedSet.addAll() is very slow,COLLECTIONS-409,12595135,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,adriannistor,adriannistor,19/Jun/12 16:00,09/Nov/14 14:31,07/Apr/19 20:37,19/Jun/12 19:52,3.2.1,,,,,4.0,4.0-alpha1,,,,,,,,0,,,,"Hi,

I am encountering a performance problem in ListOrderedSet.addAll().
It appears in version 3.2.1 and also in revision 1351465 (18 Jun
2012). I have attached a test that exposes this problem and a
three-line patch that fixes it. On my machine, for this test, the
patch provides a 79X speedup.

To run the test, just do:

$ java Test

The output for the un-patched version is:
Time is 1837

The output for the patched version is:
Time is 23

As the patch shows, the problem is that 
ListOrderedSet.addAll(int index, Collection<? extends E> coll) 
performs:
""setOrder.add(index++, e)"" for each element in ""coll"".  This is very 
expensive, because ""setOrder"" is an ArrayList, and inserting an
element in the middle of an ArrayList shifts all the elements to the
right.

The patched version avoids this cost by inserting all the elements at
once, thus performing only one insert.

Is this a bug?  If so, can you please confirm that the patch is
correct?

Thanks,

Adrian
","java 1.6.0_24
Ubuntu 11.10",,,,,,,,,,,,,,,,,,19/Jun/12 16:00;adriannistor;Test.java;https://issues.apache.org/jira/secure/attachment/12532570/Test.java,19/Jun/12 16:00;adriannistor;patch.diff;https://issues.apache.org/jira/secure/attachment/12532569/patch.diff,,,,,,,,2.0,,,,,,,,,,,,,,,,,,,2012-06-19 19:52:30.135,,,false,,,,,,,,,,,,,,292949,,,Tue Jun 19 20:06:31 UTC 2012,,,,,,0|i0shqn:,164351,,,,,,,,"19/Jun/12 19:52;tn;Applied the patch in r1351821.

Thanks for reporting!","19/Jun/12 20:06;hudson;Integrated in commons-collections #23 (See [https://builds.apache.org/job/commons-collections/23/])
    [COLLECTIONS-409] Improve performance of ListOrderedSet#addAll, add missing javadoc. Thanks to Adrian Nistor for reporting and providing a patch. (Revision 1351821)

     Result = SUCCESS
tn : http://svn.apache.org/viewvc/?view=rev&rev=1351821
Files : 
* /commons/proper/collections/trunk/src/main/java/org/apache/commons/collections/set/ListOrderedSet.java
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
performance problem in SetUniqueList.removeAll(),COLLECTIONS-408,12559038,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,adriannistor,adriannistor,02/Jun/12 06:56,09/Nov/14 14:31,07/Apr/19 20:37,19/Jun/12 19:22,,,,,,4.0,4.0-alpha1,,,,,,,,0,,,,"Hi,

I am encountering a performance problem in SetUniqueList.removeAll().
It appears in version 3.2.1 and also in revision 1344775 (31 May
2012).  I have attached a test that exposes this problem and a
one-line patch that fixes it.  The patch makes the code two times
faster for this test.

To run the test, just do:

$ java Test

The output for the un-patched version is:
Time is: 5027

The output for the patched version is:
Time is: 2554

The one-line patch I attached changes the 
SetUniqueList.removeAll(Collection<?> coll) code from:

boolean result = super.removeAll(coll);
set.removeAll(coll);
return result;

to:

boolean result = super.removeAll(coll);
if (result) set.removeAll(coll);
return result;

If ""super.removeAll(coll)"" did not change the collection, there is no
need to call ""set.removeAll(coll)"", because we already know there is
nothing to remove.

As one may expect ""set.removeAll(coll)"" (on a set) to be faster than
""super.removeAll(coll)"" (on a list), one may have expected the speedup
gained by avoiding ""set.removeAll(coll)"" to be smaller than 2X
achieved for the attached test.  However, the speedup is 2X because
""java.util.HashSet.removeAll(Collection<?> collection)"" has quadratic
(not linear) complexity if ""this.size() <= collection.size()"" and the
""collection"" is a list.  Thus, ""set.removeAll(coll)"" is about as slow
as ""super.removeAll(coll)"" in this case, and not executing
""set.removeAll(coll)"" reduces the work done by half.  The quadratic
behavior of ""java.util.HashSet.removeAll(Collection<?> collection)""
comes from ""java.util.AbstractSet.removeAll(Collection<?> c)"" and is
discussed for example here:
http://mail.openjdk.java.net/pipermail/core-libs-dev/2011-July/007148.html
(The link is for OpenJDK, but Oracle JDK has the same problem.)

In many other cases ""set.removeAll(coll)"" is actually faster than
""super.removeAll(coll)"", so one can get even more speedup by
reordering those two checks:

boolean result = set.removeAll(coll);
if (result) super.removeAll(coll);
return result;

Is this a bug, or am I misunderstanding the intended behavior?  If so,
can you please confirm that the patch is correct?

Thanks,

Adrian

","java 1.6.0_24
Ubuntu 11.10",,,,,,,,,,,,,,,COLLECTIONS-407,,,02/Jun/12 06:57;adriannistor;Test.java;https://issues.apache.org/jira/secure/attachment/12530638/Test.java,02/Jun/12 06:57;adriannistor;patch.diff;https://issues.apache.org/jira/secure/attachment/12530637/patch.diff,,,,,,,,2.0,,,,,,,,,,,,,,,,,,,2012-06-19 19:22:58.986,,,false,,,,,,,,,,,,,,292950,,,Tue Jun 19 19:33:14 UTC 2012,,,,,,0|i0shqv:,164352,,,,,,,,"19/Jun/12 19:22;tn;Fixed in r1351804.

I have not applied the patch, but rather used a similar approach as for ListOrderedSet: instead of using the removeAll method of the underlying collection, iterate over the elements of the collection to be removed and call the remove method on each element. The remove method does now the same check as in ListOrderedSet, just the other way round: first remove in the set, and then in the list if something was removed.","19/Jun/12 19:33;hudson;Integrated in commons-collections #22 (See [https://builds.apache.org/job/commons-collections/22/])
    [COLLECTIONS-408] improve performance of remove and removeAll methods, add missing javadoc. Thanks to Adrian Nistor for reporting. (Revision 1351804)

     Result = SUCCESS
tn : http://svn.apache.org/viewvc/?view=rev&rev=1351804
Files : 
* /commons/proper/collections/trunk/src/main/java/org/apache/commons/collections/list/SetUniqueList.java
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
ListOrderedSet.removeAll() is slow,COLLECTIONS-407,12558984,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,adriannistor,adriannistor,01/Jun/12 17:55,09/Nov/14 14:31,07/Apr/19 20:37,19/Jun/12 19:00,3.2.1,,,,,4.0,4.0-alpha1,,,,,,,,0,,,,"Hi,

I am encountering a performance problem in ListOrderedSet.removeAll().
It appears in version 3.2.1 and also in revision 1344775 (31 May
2012).  I have attached a test that exposes this problem and a
one-line patch that fixes it.  On my machine, for this test, the patch
provides a 317X speedup.

To run the test, just do:

$ java Test

The output for the un-patched version is:
Time is 3812

The output for the patched version is:
Time is 12

As the patch shows, the problem is in 
ListOrderedSet.remove(Object object).  The code for this method is:

boolean result = collection.remove(object);
setOrder.remove(object);
return result;

The patch changes it to :

boolean result = collection.remove(object);
if (result) setOrder.remove(object);
return result;

The ""setOrder.remove(object)"" is not necessary if 
""collection.remove(object)"" did not find the object.

This small change speeds up
ListOrderedSet.ListOrderedSet.removeAll(Collection<?> coll) because
ListOrderedSet.ListOrderedSet.removeAll(Collection<?> coll) iterates
over all the elements in ""coll"" and calls 
ListOrderedSet.remove(Object object).  So the un-patched code has
quadratic complexity, while the patched code has linear complexity.

Is this truly a bug, or am I missing something here?  If so, can you
please confirm if the patch is correct?

Thanks,

Adrian
","java 1.6.0_24
Ubuntu 11.10",,,,,,,,,,,,,,,COLLECTIONS-409,,,01/Jun/12 17:55;adriannistor;Test.java;https://issues.apache.org/jira/secure/attachment/12530579/Test.java,01/Jun/12 17:55;adriannistor;patch.diff;https://issues.apache.org/jira/secure/attachment/12530578/patch.diff,,,,,,,,2.0,,,,,,,,,,,,,,,,,,,2012-06-19 07:16:38.054,,,false,,,,,,,,,,,,,,292951,,,Tue Jun 19 19:06:13 UTC 2012,,,,,,0|i0shr3:,164353,,,,,,,,"19/Jun/12 07:16;tn;The patch looks correct. The only thing that comes to my mind is that there may be collections which wrongly implement the methods in question and do not correctly return the change status.

So the way it is implemented right now is a bit slower but will work in all cases.","19/Jun/12 15:36;adriannistor;Hi Thomas,

Thanks, it's great that the patch works.

java.util, Apache Commons Collections, Guava Libraries, all use on a
regular basis methods from the collections passed as parameters (over
which these three libraries have no control), just like in this case.
It's the normal thing to do, there must be hundreds of such examples,
and nobody tries to avoid them.

In fact, how can one use the collections passes as parameters
otherwise?  For example, the implementation of ListOrderedSet alone
(not to mention the other classes in Commons Collections, java.util,
and Guava Libraries) uses methods from ""collection"" 9 different times,
including the return value of ""collection.retainAll"" in the
implementation of ""ListOrderedSet.retainAll(Collection<?> coll)"".  It
would not be possible to implement Commons Collections otherwise.

> a bit slower

Quadratic vs linear complexity is a big difference.  This can get
really slow (e.g., two orders of magnitude) even for medium size data
sets.

Best,

Adrian

","19/Jun/12 16:21;tn;You are right, in fact other methods (in ListOrderedSet, e.g. retainAll) already use similar logic as proposed in your patch, so I guess it is safe to do it also for the remove method.","19/Jun/12 19:00;tn;Applied patch in r1351800.

Thanks for reporting!","19/Jun/12 19:06;hudson;Integrated in commons-collections #21 (See [https://builds.apache.org/job/commons-collections/21/])
    [COLLECTIONS-407] improve performance of remove method by taking method result from underlying collection into account. Thanks to Adrian Nistor for reporting and providing a patch. (Revision 1351800)

     Result = SUCCESS
tn : http://svn.apache.org/viewvc/?view=rev&rev=1351800
Files : 
* /commons/proper/collections/trunk/src/main/java/org/apache/commons/collections/set/ListOrderedSet.java
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
ListUtils.subtract is very slow ,COLLECTIONS-406,12558285,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,adriannistor,adriannistor,27/May/12 19:52,09/Nov/14 14:31,07/Apr/19 20:37,03/Jun/12 10:25,3.2.1,,,,,4.0,4.0-alpha1,,,,,,,,0,,,,"Hi,

ListUtils.subtract is very slow when subtracting two large lists.  The
root cause of this problem is similar to the root cause of the
previously fixed COLLECTIONS-328 in ListUtils, i.e., quadratic
complexity instead of linear complexity.

I am encountering this problem in version 3.2.1 and also in revision
1342815 (May 25th 2012).  I have attached a test that exposes this
problem and a simple patch.  On my machine, for the attached test,
this patch provides a 95X speedup.

To run the test, just do:

$ java Test

Currently, the code for ListUtils.subtract is:

final ArrayList<E> result = new ArrayList<E>(list1);
for (E e : list2) {
    result.remove(e);
}
return result;

which is quadratic, because result.remove(e) has linear complexity.

The attached patch makes the remove() be constant complexity by
removing from an org.apache.commons.collections.bag.HashBag.  I use
HashBag and not HashSet because ListUtils.subtract needs to respect
the cardinality when there are repeated objects in the list.

As mentioned in COLLECTIONS-328 discussion, for small lists, there is
some overhead for creating the HashBag.  This can be fixed with a
threshold, but I did not implement it in my patch because the
COLLECTIONS-328 patch does not implement it.

Unlike the patch for COLLECTIONS-328, my patch does not choose the
list to iterate over based on size, because of the cardinality
requirement in subtract.  This means the code could be made even
faster if we could use something like a LinkedHashBag but neither
Apache Collections nor standard Java libraries have such a class.
Even so, this patch is still a lot faster than the original version.

Is this truly a bug, or am I missing something here?  If so, can you
please confirm if the patch is correct?

Thanks,

Adrian


","java 1.6.0_24
Ubuntu 11.10",,,,,,,,,,,,,,,,,,27/May/12 19:53;adriannistor;Test.java;https://issues.apache.org/jira/secure/attachment/12529905/Test.java,27/May/12 19:53;adriannistor;patch.diff;https://issues.apache.org/jira/secure/attachment/12529904/patch.diff,,,,,,,,2.0,,,,,,,,,,,,,,,,,,,2012-06-03 10:25:40.249,,,false,,,,,,,,,,,,,,292952,,,Sun Jun 03 10:35:11 UTC 2012,,,,,,0|i0shrb:,164354,,,,,,,,"03/Jun/12 10:25;tn;Thanks for reporting this issue and providing a patch.

The patch has been applied in r1345644 together with unit tests for the subtract method (was missing before).","03/Jun/12 10:35;hudson;Integrated in commons-collections #20 (See [https://builds.apache.org/job/commons-collections/20/])
    [COLLECTIONS-406] Improved ListUtils.subtract to O(n) performance. Thanks to Adrian Nistor for reporting and providing a patch. (Revision 1345644)

     Result = SUCCESS
tn : http://svn.apache.org/viewvc/?view=rev&rev=1345644
Files : 
* /commons/proper/collections/trunk/src/main/java/org/apache/commons/collections/ListUtils.java
* /commons/proper/collections/trunk/src/test/java/org/apache/commons/collections/TestListUtils.java
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"Inconsistent Javadoc comment and code in intersection(List list1,List list2)in org.apache.commons.collections.ListUtils",COLLECTIONS-402,12548780,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Invalid,,shinhwei,shinhwei,30/Mar/12 03:42,27/Nov/15 21:47,07/Apr/19 20:37,26/Jul/12 20:59,3.2.1,,,,,,,,Collection,,,,,,0,,,,"The Javadoc comment below states that the method ""throws NullPointerException if either list is null"". 
    	     /*......
	     * 
	     * @throws NullPointerException if either list is null
	     */
	    public static List intersection(final List list1, final List list2)
	        ..
	    }
However, when called with a null list1 and an empty list2(i.e., ""intersection((List)null, new ArrayList())""), the method executes normally without throwing any exception.

Suggested Fixes:
1. Add code ""if (list1 == null) throw NullPointerException();"" at the beginning of the method body.
or
2. Remove ""@throws NullPointerException if either list is null"" from the Javadoc.
or
3. Change ""@throws NullPointerException if either list is null"" to ""@throws NullPointerException if list2 is null or (the list2 is non-empty and the list1 is null)"".
",Platform Independent ,,,,180,180,,0%,180,180,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2012-04-09 17:56:08.067,,,false,,,,,,,,,,,,,,233877,,,Mon Apr 09 17:56:08 UTC 2012,,,,,,0|i0shrz:,164357,,,,,,,,"09/Apr/12 17:56;tn;Already fixed for 4.0, although we should consider throwing an IllegalArgumentException in such a case.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"Inconsistent Javadoc comment and code in removeAll(Collection<E>, Collection<?>) in org.apache.commons.collections.ListUtils",COLLECTIONS-401,12548778,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Not A Problem,,shinhwei,shinhwei,30/Mar/12 03:02,27/Nov/15 21:47,07/Apr/19 20:37,26/Jul/12 21:02,3.2.1,,,,,,,,Collection,,,,,,0,javadoc,,,"The Javadoc comment below states that the method ""throws NullPointerException if either parameter is null"". 
    	     /*......
	     * 
	     * @throws NullPointerException if either parameter is null
	     */
	    public static <E> List<E> removeAll(Collection<E> collection, Collection<?> remove) {
	        ..
	    }
However, when called with two null collections (i.e., ""removeAll((Collection)null, (Collection)null)""), the method executes normally without throwing any exception.

Suggested Fixes:
1. Add code ""if (collection == null) throw NullPointerException();"" at the beginning of the method body.
or
2. Remove ""@throws NullPointerException if either parameter is null"" from the Javadoc.
or
3. Change ""@throws NullPointerException if either parameter is null"" to ""@throws NullPointerException if the first collection is null or (the first collection is non-empty and the second collection is null)"".",,,,,180,180,,0%,180,180,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2012-04-09 17:54:28.828,,,false,,,,,,,,,,,,,,233875,,,Wed Jun 20 17:23:51 UTC 2012,,,,,,0|i0shs7:,164358,,,,,,,,"09/Apr/12 17:54;tn;Already fixed for 4.0, although we should consider throwing IllegalArgumentException in such cases.",20/Jun/12 07:20;thomasle75@live.com;the removeAll is calling ListUtils.retainAll instead of ListUtils.removeAll,"20/Jun/12 17:23;tn;Can you be a bit more precise?

Looking at the code of ListUtils, I do not see that retainAll is called. In fact doing a reference check of ListUtils.retainAll shows that it is only called by CollectionUtils.retainAll (and some test class).",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"Inconsistent Javadoc comment and code in addIgnoreNull(Collection<T>, T) in org.apache.commons.collections.CollectionUtils",COLLECTIONS-400,12548777,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,shinhwei,shinhwei,30/Mar/12 02:59,09/Nov/14 14:31,07/Apr/19 20:37,09/Apr/12 17:27,3.2.1,,,,,4.0,4.0-alpha1,,Collection,,,,,,0,javadoc,,,"The Javadoc comment below states that the method ""throws NullPointerException if the collection is null"". 
    	    /**
	       .....
	     * @param collection  the collection to add to, must not be null
	     * @param object  the object to add, if null it will not be added
	     * @return true if the collection changed
	     * @throws NullPointerException if the collection is null
	     */
	    public static <T> boolean addIgnoreNull(Collection<T> collection, T object) {
	        return (object != null && collection.add(object));
	    }
However, when called with an null collection and a null object (i.e., ""addIgnoreNull((Collection)null, null)""), the method executes normally without throwing any exception.

Suggested Fixes:
1. Add code ""if (collection == null) throw NullPointerException();"" at the beginning of the method body.
or
2. Remove ""@throws NullPointerException if the collection is null"" from the Javadoc.
or
3. Change ""@throws NullPointerException if the collection is null"" to ""@throws NullPointerException if the collection is null and the object is non-null)"".",Platform independent,,,,180,180,,0%,180,180,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2012-04-09 17:27:40.632,,,false,,,,,,,,,,,,,,233874,,,Mon Apr 09 17:33:23 UTC 2012,,,,,,0|i0shsf:,164359,,,,,,,,09/Apr/12 17:27;tn;Thanks for the report. I have added the missing null check in r1311344.,"09/Apr/12 17:33;hudson;Integrated in commons-collections #16 (See [https://builds.apache.org/job/commons-collections/16/])
    [COLLECTIONS-400] Added missing null check, thanks to Shin Hwei Tan. (Revision 1311344)

     Result = SUCCESS
tn : http://svn.apache.org/viewvc/?view=rev&rev=1311344
Files : 
* /commons/proper/collections/trunk/src/main/java/org/apache/commons/collections/CollectionUtils.java
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
FastTreeMap is not compatible with TreeMap,COLLECTIONS-394,12544629,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Won't Fix,,michaelpradel,michaelpradel,29/Feb/12 14:49,27/Nov/15 21:47,07/Apr/19 20:37,23/Jun/12 17:14,3.2.1,,,,,,,,Map,,,,,,0,,,,"FastTreeMap extends TreeMap in a way that doesn't preserve the superclass behavior. For example, the following code prints 'null', but I would expect it to print '1=1', which is what TreeMap does:

TreeMap map = new FastTreeMap();
//TreeMap map = new TreeMap();

map.put(1, ""1"");
map.put(3, ""3"");
		
Entry e = map.floorEntry(2);
System.out.println(e);

This behavior is surprising and can hit you every time a reference of type TreeMap refers to an instance of FastTreeMap. A subclass instance used through a superclass interface shouldn't change the visible behavior of its superclass.

The reason for this problem seems to be that FastTreeMap both extends TreeMap and delegates to a TreeMap via the 'map' field. I.e., there are  two map instances for a single FastTreeMap instance.",all,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2012-02-29 14:51:42.479,,,false,,,,,,,,,,,,,,229815,,,Sat Jun 23 17:14:22 UTC 2012,,,,,,0|i0shsv:,164361,,,,,,,,"29/Feb/12 14:51;garydgregory;Would you be willing to provide a patch for unit test and code?

Thank you.","02/Mar/12 14:19;michaelpradel;It seems the problem affects several other methods in FastTreeMap, specifically methods that have been added to TreeMap in Java 1.6. E.g. TreeMap.headMap(K) existed before Java 1.6 and is overridden by FastTreeMap, while TreeMap.headMap(K, boolean) got added in Java 1.6. and is not overridden by FastTreeMap. All inherited methods do not refer to the 'map' field, and therefore use the wrong map.

One way to fix these problems is to override all public methods from TreeMap in FastTreeMap. Since I'm not familiar with FastTreeMap's implementation, I'll leave this task to someone more experienced with the Commons Collections.","23/Jun/12 17:14;tn;The FastTreeMap class has been removed from trunk.

There is no drop-in replacement, but one can use a ConcurrentHashMap from the java.util.concurrent package or a synchronized TreeMap.

Please open new issue if you would like to have an equivalent class in collections 4.0.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"Inconsistent Javadoc comment and code for toProperties(final Map<K, V>) in org.apache.commons.collections.MapUtils",COLLECTIONS-391,12537668,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,shinhwei,shinhwei,08/Jan/12 08:38,09/Nov/14 14:31,07/Apr/19 20:37,09/Apr/12 18:03,4.0,4.x,,,,4.0,4.0-alpha1,,Collection,,,,,,0,javadoc,null,,"The Javadoc comment below states that the parameter map ""..., may not be null"":
   	   /**
	    ..
	     * @param map  the map to convert to a Properties object, may not be null
	     * @return the properties object
	     */
	    public static <K, V> Properties toProperties(final Map<K, V> map) {
	        Properties answer = new Properties();
	        if (map != null) {
	            ...
	        }
	        return answer;
	    }
However, the method return normally without throwing any exception when called with null.

Suggested Fixes:
1. Change ""@param map  the map to convert to a Properties object, may not be null"" to ""@param map  the map to convert to a Properties object, may be null""
or
2. Remove ""may not be null"" from @param.
",Platform Indepedent,,,,120,120,,0%,120,120,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2012-04-09 18:03:18.814,,,false,,,,,,,,,,,,,,223174,,,Mon Apr 09 18:45:04 UTC 2012,,,,,,0|i0shtj:,164364,,,,,,,,"09/Apr/12 18:03;tn;Thanks for the report. Fixed in r1311359.

The additional constraint about the map parameter has been removed, as the javadoc already states that a null input will result in an empty properties object.","09/Apr/12 18:45;hudson;Integrated in commons-collections #17 (See [https://builds.apache.org/job/commons-collections/17/])
    [COLLECTIONS-391] Fixed javadoc, thanks to Shin Hwei Tan. (Revision 1311359)

     Result = SUCCESS
tn : http://svn.apache.org/viewvc/?view=rev&rev=1311359
Files : 
* /commons/proper/collections/trunk/src/main/java/org/apache/commons/collections/MapUtils.java
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"Inconsistent Javadoc comment and code for mapTransformer(Map<? super I, ? extends O>) in org.apache.commons.collections.TransformerUtils",COLLECTIONS-390,12537667,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Duplicate,,shinhwei,shinhwei,08/Jan/12 08:31,24/Jun/13 19:34,07/Apr/19 20:37,08/Jan/12 08:32,4.0,,,,,,,,Buffer,,,,,,0,,,,"The Javadoc comment below states that the method ""throws IllegalArgumentException if the map is null"":
   	    /** 
	     ....
	     * @param map  the map to use to transform the objects
	     * @return the transformer
	     * @throws IllegalArgumentException if the map is null
	     */
	    public static <I, O> Transformer<I, O> mapTransformer(Map<? super I, ? extends O> map) {
	        return MapTransformer.mapTransformer(map);
	    }
However, the method returns a NULL_INSTANCE object instead of throwing IllegalArgumentException when called with null.

Suggested Fixes:
1. Change ""@throws IllegalArgumentException if the map is null"" and ""@return"" to ""@return NULL_INSTANCE if the map is null"".
or
2. Remove the entire ""throws IllegalArgumentException if the map is null"".
",Platform Independent,,,,120,120,,0%,120,120,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,223173,,,2012-01-08 08:31:53.0,,,,,,0|i0shtr:,164365,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"Inconsistent Javadoc comment and code for mapTransformer(Map<? super I, ? extends O>) in org.apache.commons.collections.TransformerUtils",COLLECTIONS-389,12537666,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,shinhwei,shinhwei,08/Jan/12 08:31,09/Nov/14 14:31,07/Apr/19 20:37,09/Apr/12 17:21,4.0,4.x,,,,4.0,4.0-alpha1,,Collection,,,,,,0,javadoc,null,,"The Javadoc comment below states that the method ""throws IllegalArgumentException if the map is null"":
   	    /** 
	     ....
	     * @param map  the map to use to transform the objects
	     * @return the transformer
	     * @throws IllegalArgumentException if the map is null
	     */
	    public static <I, O> Transformer<I, O> mapTransformer(Map<? super I, ? extends O> map) {
	        return MapTransformer.mapTransformer(map);
	    }
However, the method returns a NULL_INSTANCE object instead of throwing IllegalArgumentException when called with null.

Suggested Fixes:
1. Change ""@throws IllegalArgumentException if the map is null"" and ""@return"" to ""@return NULL_INSTANCE if the map is null"".
or
2. Remove the entire ""throws IllegalArgumentException if the map is null"".
",Platform Independent,,,,120,120,,0%,120,120,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2012-04-09 17:21:08.026,,,false,,,,,,,,,,,,,,223172,,,Mon Apr 09 17:33:23 UTC 2012,,,,,,0|i0shtz:,164366,,,,,,,,"09/Apr/12 17:21;tn;Thanks for the report. It has been fixed in r1311337.

I have picked option 1.","09/Apr/12 17:33;hudson;Integrated in commons-collections #16 (See [https://builds.apache.org/job/commons-collections/16/])
    [COLLECTIONS-389] Fixed javadoc, thanks to Shin Hwei Tan. (Revision 1311337)

     Result = SUCCESS
tn : http://svn.apache.org/viewvc/?view=rev&rev=1311337
Files : 
* /commons/proper/collections/trunk/src/main/java/org/apache/commons/collections/TransformerUtils.java
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Inconsistent Javadoc comment and code for prototypeFactory(T) in org.apache.commons.collections.FactoryUtils,COLLECTIONS-388,12537665,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,shinhwei,shinhwei,08/Jan/12 08:29,09/Nov/14 14:31,07/Apr/19 20:37,09/Apr/12 17:16,4.0,4.x,,,,4.0,4.0-alpha1,,Collection,,,,,,0,javadoc,null,,"The Javadoc comment below states that the method ""throws IllegalArgumentException if the prototype is null"":
   	    /**	     
	     ..
	     * @param prototype  the object to clone each time in the factory
	     * @return the <code>prototype</code> factory
	     * @throws IllegalArgumentException if the prototype is null
	     * @throws IllegalArgumentException if the prototype cannot be cloned
	     */
	    public static <T> Factory<T> prototypeFactory(T  prototype) {
	        return PrototypeFactory.<T>prototypeFactory(prototype);
	    }

However, the method returns a NULL_INSTANCE object instead of throwing IllegalArgumentException when called with null.

Suggested Fixes:
1. Change ""@throws IllegalArgumentException if the prototype is null"" and ""@return"" to ""@return NULL_INSTANCE if the prototype is null"".
or
2. Remove the entire ""throws IllegalArgumentException if the prototype is null"".",Platform independent,,,,120,120,,0%,120,120,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2012-04-09 17:14:34.604,,,false,,,,,,,,,,,,,,223171,,,Mon Apr 09 17:33:23 UTC 2012,,,,,,0|i0shu7:,164367,,,,,,,,"09/Apr/12 17:14;tn;Thanks for the hint, it has been fixed in r1311334.","09/Apr/12 17:33;hudson;Integrated in commons-collections #16 (See [https://builds.apache.org/job/commons-collections/16/])
    [COLLECTIONS-388] Fixed javadoc, thanks to Shin Hwei Tan. (Revision 1311334)

     Result = SUCCESS
tn : http://svn.apache.org/viewvc/?view=rev&rev=1311334
Files : 
* /commons/proper/collections/trunk/src/main/java/org/apache/commons/collections/FactoryUtils.java
* /commons/proper/collections/trunk/src/main/java/org/apache/commons/collections/functors/PrototypeFactory.java
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
CollectionUtils.removeAll does retain instead of remove,COLLECTIONS-387,12536417,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Duplicate,,smoker,smoker,27/Dec/11 12:34,28/Feb/13 20:02,07/Apr/19 20:37,27/Dec/11 12:35,3.2.1,,,,,4.0,,,Collection,,,,,,0,bug,removeAll,,"org.apache.commons.collections.CollectionUtils.removeAll(Collection, Collection) method calls org.apache.commons.collections.ListUtils.retainAll(Collection, Collection) instead of org.apache.commons.collections.ListUtils.removeAll(Collection, Collection).",,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,222100,,,2011-12-27 12:34:41.0,,,,,,0|i0shuf:,164368,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"CollectionUtils.removeAll(Collection, Collection) has an CopyPaste-Failure",COLLECTIONS-386,12530050,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Critical,Duplicate,joehni,thomas.steininger,thomas.steininger,03/Nov/11 14:07,03/Nov/11 16:19,07/Apr/19 20:37,03/Nov/11 16:19,3.2.1,,,,,4.0,Nightly Builds,,,,,,,,0,,,,"public static Collection removeAll(Collection collection, Collection remove) {
        return ListUtils.retainAll(collection, remove);
    }
",commons-collections-3.2.1.jar,,,,,,,,,,,,,COLLECTIONS-357,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2011-11-03 14:09:02.867,,,false,,,,,,,,,,,,,,215909,,,Thu Nov 03 16:19:31 UTC 2011,,,,,,0|i0shun:,164369,,,,,,,,03/Nov/11 14:09;garydgregory;This is already fixed in trunk.,03/Nov/11 14:15;garydgregory;Already in SVN trunk.,"03/Nov/11 16:19;joehni;Closed as Nth duplicate, otherwise we might have it multiple times in the change log.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"Inconsistent Javadoc comment and code in addAll(Collection, Object[]) in org.apache.commons.collections.CollectionUtils",COLLECTIONS-385,12528956,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Not A Problem,,shinhwei,shinhwei,26/Oct/11 20:27,27/Nov/15 21:47,07/Apr/19 20:37,26/Jul/12 21:06,2.1,2.1.1,3.0,3.1,3.2,,,,Collection,,,,,,0,javadoc,nullpointerexception,,"The Javadoc comment below states that the method ""throws NullPointerException if the collection or array is null"". 
    /** 
     * Adds all elements in the array to the given collection.
     * 
     * @param collection  the collection to add to, must not be null
     * @param elements  the array of elements to add, must not be null
     * @throws NullPointerException if the collection or array is null
     */
    public static void addAll(Collection collection, Object[] elements) {
        for (int i = 0, size = elements.length; i < size; i++) {
            collection.add(elements[i]);
        }
    }    

However, when called with an empty array and a null collection (i.e., ""addAll((Collection)null, new Object[])""), the method executes normally without throwing any exception.

Suggested Fixes:
1. Add code ""if (collection == null) throw NullPointerException();"" at the beginning of the method body.
or
2. Remove ""@throws NullPointerException if the collection or array is null"" from the Javadoc.
or
3. Change ""@throws NullPointerException if the collection or array is null"" to ""@throws NullPointerException if the array is null or (the array is non-empty and the collection is null)"".",Platform Independent,,,,300,300,,0%,300,300,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2011-10-29 21:11:47.1,,,false,,,,,,,,,,,,,,214816,,,Sun Oct 30 00:51:03 UTC 2011,,,,,,0|i0shuv:,164370,,,,,,,,"29/Oct/11 20:41;shinhwei;I found the same problem for overloaded method CollectionUtils#public static void addAll(Collection collection,Iterator iterator) and CollectionUtils#public static void addAll(Collection collection,Enumeration enumeration)",29/Oct/11 21:11;garydgregory;I do not think this applies to trunk.,"30/Oct/11 00:51;shinhwei;Yes, the trunk currently have:

           /**
	     * Adds all elements in the iteration to the given collection.
	     *
	     * @param collection
	     *            the collection to add to, must not be null
	     * @param iterator
	     *            the iterator of elements to add, must not be null
	     * @return a boolean indicating whether the collection has changed or not.
	     * @throws NullPointerException
	     *             if the collection or iterator is null
	     */
	    public static <C> boolean addAll(Collection<C> collection, Iterator<? extends C> iterator) {
	        boolean changed = false;
	        while (iterator.hasNext()) {
	            changed |= collection.add(iterator.next());
	        }
	        return changed;
	    }

           /**
	     * Adds all elements in the array to the given collection.
	     *
	     * @param collection
	     *            the collection to add to, must not be null
	     * @param elements
	     *            the array of elements to add, must not be null
	     * @throws NullPointerException
	     *             if the collection or array is null
	     */
	    public static <C> boolean addAll(Collection<C> collection, C[] elements) {
                 ............
            }

           /**
	     * Adds all elements in the iteration to the given collection.
	     *
	     * @param collection
	     *            the collection to add to, must not be null
	     * @param iterator
	     *            the iterator of elements to add, must not be null
	     * @return a boolean indicating whether the collection has changed or not.
	     * @throws NullPointerException
	     *             if the collection or iterator is null
	     */
	    public static <C> boolean addAll(Collection<C> collection, Iterator<? extends C> iterator) {

           /**
	     * Adds all elements in the iteration to the given collection.
	     *
	     * @param collection
	     *            the collection to add to, must not be null
	     * @param iterator
	     *            the iterator of elements to add, must not be null
	     * @return a boolean indicating whether the collection has changed or not.
	     * @throws NullPointerException
	     *             if the collection or iterator is null
	     */
	    public static <C> boolean addAll(Collection<C> collection, Iterator<? extends C> iterator) {
                    .....
            }

When called with an empty iterator/elements and a null collection (i.e., ArrayList al=new ArrayList(); addAll((Collection)null, new al.iterator())""), the method still executes normally without throwing any exception.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Inconsistent Javadoc comment and code for synchronizedMap(Map) in org.apache.commons.collections.MapUtils,COLLECTIONS-384,12528955,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,shinhwei,shinhwei,26/Oct/11 20:21,09/Nov/14 14:31,07/Apr/19 20:37,29/Oct/11 20:54,3.0,3.1,3.2,,,4.0,4.0-alpha1,,Collection,,,,,,0,code,javadoc,synchronizedMap,"The Javadoc comment below states that the method ""throws IllegalArgumentException if the map is null"":
    /**
     ...
     * @param map  the map to synchronize, must not be null
     * @return a synchronized map backed by the given map
     * @throws IllegalArgumentException  if the map is null
     */
    public static Map synchronizedMap(Map map) {
        return Collections.synchronizedMap(map);
    }

However, the method throws NullPointerException instead of IllegalArgumentException when called with null.

Suggested Fixes:
1. Add code ""if (map == null) throw IllegalArgumentException();"" at the beginning of the method body.
or
2. Change ""@throws IllegalArgumentException  if the map is null"" to ""@throws NullPointerException  if the map is null"".
or
3. Remove the entire ""@throws IllegalArgumentException  if the map is null"".",Platform independent,,,,300,300,,0%,300,300,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2011-10-29 20:52:18.267,,,false,,,,,,,,,,,,,,214815,,,Sat Oct 29 21:07:45 UTC 2011,,,,,,0|i0shv3:,164371,,,,,,,,"29/Oct/11 20:52;garydgregory;I picked option (3) because {{Collections.synchronizedMap(map);}} says nothing on the topic so I do not think it should be part of our contract. 

In fact our method seems superfluus. Why use it instead of Collections.synchronizedMap(map)?",29/Oct/11 20:54;garydgregory;Committed revision 1195031.,"29/Oct/11 21:07;hudson;Integrated in commons-collections #2 (See [https://builds.apache.org/job/commons-collections/2/])
    [COLLECTIONS-384] Inconsistent Javadoc comment and code for synchronizedMap(Map) in org.apache.commons.collections.MapUtils.

ggregory : http://svn.apache.org/viewvc/?view=rev&rev=1195031
Files : 
* /commons/proper/collections/trunk/src/java/org/apache/commons/collections/MapUtils.java
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
UnmodifiableBoundedCollection.unmodifiableBoundedCollection is an infinite loop,COLLECTIONS-380,12525229,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Minor,Fixed,,dbrosius@apache.org,dbrosius@apache.org,29/Sep/11 18:45,09/Nov/14 14:31,07/Apr/19 20:37,09/Apr/12 18:41,,,,,,4.0,4.0-alpha1,,Collection,,,,,,0,,,,"This method, just calls itself. As BoundedCollection extends Collection, it would seem to me that this method should be removed:


    /**
     * Factory method to create an unmodifiable bounded collection.
     *
     * @param coll  the <code>BoundedCollection</code> to decorate, must not be null
     * @return a new unmodifiable bounded collection
     * @throws IllegalArgumentException if bag is null
     */
    public static <E> BoundedCollection<E> unmodifiableBoundedCollection(BoundedCollection<E> coll) {
        return unmodifiableBoundedCollection(coll);
    }
",,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2012-01-02 18:07:09.178,,,false,,,,,,,,,,,,,,40352,,,Mon Apr 09 18:45:04 UTC 2012,,,,,,0|i0shvr:,164374,,,,,,,,02/Jan/12 18:07;mattbishop;This should be a higher severity. APIs shouldn't lock up like this.,"09/Apr/12 18:41;tn;Fixed in r1311366.

Additionally I have added a first unit test and fixed more javadoc issues in the class.","09/Apr/12 18:45;hudson;Integrated in commons-collections #17 (See [https://builds.apache.org/job/commons-collections/17/])
    [COLLECTIONS-380] Fixed infinte recursion when creating an unmodifiable bounded collection, added unit test, fixed additional javadoc, thanks to Dave Brosius for reporting. (Revision 1311366)

     Result = SUCCESS
tn : http://svn.apache.org/viewvc/?view=rev&rev=1311366
Files : 
* /commons/proper/collections/trunk/src/main/java/org/apache/commons/collections/collection/UnmodifiableBoundedCollection.java
* /commons/proper/collections/trunk/src/test/java/org/apache/commons/collections/collection/TestUnmodifiableBoundedCollection.java
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Bugs In Javadoc Comment in the CollectionUtils class,COLLECTIONS-379,12524228,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,shinhwei,shinhwei,22/Sep/11 02:45,09/Nov/14 14:31,07/Apr/19 20:37,26/Jul/12 21:19,3.2,,,,,4.0,4.0-alpha1,,Collection,,,,,,0,test,,,"I came across the following bugs in the Javadoc comments in the method below in the CollectionUtils class:

1.
{quote} 
   /** 
     * Selects all elements from input collection which match the given predicate
     * and adds them to outputCollection.
     * <p>
     * If the input collection or predicate is null, there is no change to the 
     * output collection.
     * 
     * @param inputCollection  the collection to get the input from, may be null
     * @param predicate  the predicate to use, may be null
     * @*param outputCollection  the collection to output into, may not be null*
     */
    public static void select(Collection inputCollection, Predicate predicate, Collection outputCollection) {
{quote}
_This method will execute normally when calling select((Collection)null, (Predicate)null, (Collection)null) but the comment clearly states that outputCollection may not be null_

2.
{quote}
  /** 
     * Selects all elements from inputCollection which don't match the given predicate
     * and adds them to outputCollection.
     * <p>
     * If the input predicate is <code>null</code>, no elements are added to <code>outputCollection</code>.
     * 
     * @param inputCollection  the collection to get the input from, may be null
     * @param predicate  the predicate to use, may be null
     * @*param outputCollection  the collection to output into, may not be null*
     */
    public static void selectRejected(Collection inputCollection, Predicate predicate, Collection outputCollection) {
{quote}
_This method will execute normally when calling selectRejected((Collection)null, (Predicate)null, (Collection)null) but the comment also clearly states that outputCollection may not be null_

3.
{quote}
  /** 
     * Transforms all elements from the inputIterator with the given transformer 
     * and adds them to the outputCollection.
     * <p>
     * If the input iterator or transformer is null, there is no change to the 
     * output collection.
     *
     * @param inputIterator  the iterator to get the input from, may be null
     * @param transformer  the transformer to use, may be null
     * @*param outputCollection  the collection to output into, may not be null*
     * @return the outputCollection with the transformed input added
     * @*throws NullPointerException if the output collection is null*
     */
    public static Collection collect(Iterator inputIterator, final Transformer transformer, final Collection outputCollection) {
{quote}
_This method will execute normally when calling collect((Iterator)null, (Transformer)null, (Collection)null) but the comment clearly states that NullPointerException will be thrown when the outputCollection is null_

4.
{quote}
 /** 
     * Transforms all elements from inputCollection with the given transformer 
     * and adds them to the outputCollection.
     * <p>
     * If the input collection or transformer is null, there is no change to the 
     * output collection.
     *
     * @param inputCollection  the collection to get the input from, may be null
     * @param transformer  the transformer to use, may be null
     * @*param outputCollection  the collection to output into, may not be null*
     * @return the outputCollection with the transformed input added
     * @*throws NullPointerException if the output collection is null*
     */
    public static Collection collect(Collection inputCollection, final Transformer transformer, final Collection outputCollection) {
{quote}
_This method will execute normally when calling collect((Collection)null, (Transformer)null, (Collection)null) but the comment clearly states that NullPointerException will be thrown when the outputCollection is null_


The bugs in the Javadoc comments above could be confusing to the users of the Common Collection library and they could be fixed easily by the developers..


There are a few ways to fix the:
1. Throwing the NullPointerException explicitly when the outputCollection is null.
2. Changing the Javadoc comments to include the case where all of the parameters are null.",System independent,,,,1200,1200,,0%,1200,1200,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2012-07-26 21:19:02.853,,,false,,,,,,,,,,,,,,3625,,,Thu Jul 26 23:07:49 UTC 2012,,,,,,0|i0shvz:,164375,,,,,,,,26/Jul/12 21:19;tn;Fixed in r1366204.,"26/Jul/12 23:07;hudson;Integrated in commons-collections #69 (See [https://builds.apache.org/job/commons-collections/69/])
    [COLLECTIONS-379] Fixed javadoc in CollectionUtils. (Revision 1366204)

     Result = SUCCESS
tn : http://svn.apache.org/viewvc/?view=rev&rev=1366204
Files : 
* /commons/proper/collections/trunk/src/changes/changes.xml
* /commons/proper/collections/trunk/src/main/java/org/apache/commons/collections/CollectionUtils.java
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Incorrect links in JavaDoc,COLLECTIONS-378,12518222,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Implemented,,kdombeck,kdombeck,08/Aug/11 16:54,09/Nov/14 14:31,07/Apr/19 20:37,28/Feb/13 19:17,,,,,,4.0,4.0-alpha1,,,,,,,,0,,,,"The links for several JavaDocs were not updated during the implementation of COLLECTIONS-251.

Attached patch file includes the necessary changes.",,,,,,,,,,,,,,,,,,,08/Aug/11 16:55;kdombeck;COLLECTIONS-378_javadoc_fixes.patch;https://issues.apache.org/jira/secure/attachment/12489711/COLLECTIONS-378_javadoc_fixes.patch,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2012-04-09 18:09:43.2,,,false,,,,,,,,,,,,,,18625,,,Mon Apr 09 18:09:43 UTC 2012,,,,,,0|i0shw7:,164376,,,,,,,,09/Apr/12 18:09;tn;Thanks for the report. This has already been fixed in r1300075.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
CollatingIterator throws NullPointerException when constructor is given null (or no) Comparator,COLLECTIONS-377,12514494,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Minor,Duplicate,,ryanhos,ryanhos,18/Jul/11 19:51,09/Nov/14 14:31,07/Apr/19 20:37,03/Jun/12 11:19,3.2,,,,,4.0,4.0-alpha1,,Iterator,,,,,,0,,,,"CollatingIterator's javadoc (http://commons.apache.org/collections/api-release/index.html) states that natural sort ordering will be used when null is passed as the Comparator argument to any of the constructors accepting one (and for the nullary constructor).  The following stack is thrown from the subsequent unit test.  The implementation of least() does not appear to account for the natural sort order case.

java.lang.NullPointerException
	at org.apache.commons.collections.iterators.CollatingIterator.least(CollatingIterator.java:334)
	at org.apache.commons.collections.iterators.CollatingIterator.next(CollatingIterator.java:230)
	at mil.af.statistics.jutl.collection.MutableDataSeriesTest...


    @SuppressWarnings(""unchecked"")
    @Test
    public void testCollatingIteratorNaturalOrdering() throws Exception
    {
        Integer[] expected =
        { Integer.valueOf(1), Integer.valueOf(2), Integer.valueOf(3), Integer.valueOf(4), Integer.valueOf(5),
            Integer.valueOf(6) };
        List<Integer> evens = Arrays.asList(new Integer[]
        { Integer.valueOf(2), Integer.valueOf(4), Integer.valueOf(6) });
        List<Integer> odds = Arrays.asList(new Integer[]
        { Integer.valueOf(1), Integer.valueOf(3), Integer.valueOf(5) });

        Iterator<Integer> collatingIter = new CollatingIterator(null, evens.iterator(), odds.iterator());

        for (Integer expectedInt : expected)
        {
            assertTrue(collatingIter.hasNext());
            assertEquals(expectedInt, collatingIter.next());
        }
    }

Workaround: provide a Comparator that implements the natural ordering contract.",Java 1.6.0_26,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2011-10-20 12:00:49.828,,,false,,,,,,,,,,,,,,18626,,,Sun Jun 03 11:19:51 UTC 2012,,,,,,0|i0shwf:,164377,,,,,,,,"18/Jul/11 19:56;ryanhos;Setting priority, as I forgot to set it originally, and it defaulted to Major.",20/Oct/11 12:00;jxcoder;I fixed. ,"20/Oct/11 12:41;jxcoder;How to commit my changes?
I've got message: 

svn commit --username jxcoder -m ""fixed 377""


""Access to '/repos/asf/!svn/me' forbidden""

what's wrong?
",03/Jun/12 11:19;tn;This has been fixed as part of [COLLECTIONS-331]. Now the javadoc states that a comparator *must* be provided (either via constructor or by calling setComparator afterwards) before using the iterator.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
 CollectionUtils.removeAll return retainAll - 3.2.1,COLLECTIONS-376,12512488,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Duplicate,,patrick sauts,patrick sauts,01/Jul/11 17:15,01/Jul/11 23:03,07/Apr/19 20:37,01/Jul/11 23:03,3.2,,,,,,,,Collection,,,,,,0,,,,"The code of removeAll method isn't correct

ligne 1121 of CollectionUtils
public static Collection removeAll(Collection collection, Collection remove) {
        return ListUtils.retainAll(collection, remove);
    }",,,,,,,,,,,,,,COLLECTIONS-357,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2011-07-01 23:03:37.246,,,false,,,,,,,,,,,,,,18627,,,Fri Jul 01 23:03:37 UTC 2011,,,,,,0|i0shwn:,164378,,,,,,,,01/Jul/11 23:03;joehni;See linked issue,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Bug in class#BeanMap and TransformedBuffer with reproducible JUnit test,COLLECTIONS-374,12503219,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Won't Fix,,saizhang,saizhang,03/Apr/11 08:02,27/Nov/15 21:47,07/Apr/19 20:37,18/Apr/13 19:09,3.2,,,,,,,,,,,,,,0,,,,"Hi all:

(as in the previous post)

I am writing an automated bug finding tool, and using
Apache Commons Collections as an experimental subject
for evaluation.

The tool creates executable JUnit tests as well as
explanatory code comments. I attached one bug-revealing
test as follows. Could you please kindly check it, to
see if it is a real bug or not?

Also, it would be tremendous helpful if you could give
some feedback and suggestion on the generated code comments?
From the perspective of developers who are relatively familiar
with the code,
is the automatically-inferred comment useful in understanding
the generated test? is the comment helpful in bug fixing?

Your suggestion will help us improve the tool.

Please see attachment for the failed test. 

The comment appears in the form of:
//Tests pass if .... (it gives some small change to the test which can make the failed test pass)",jdk 1.6.0,,,,,,,,,,,,,,,,,,03/Apr/11 08:02;saizhang;ApacheCommons_Documented_Test.java;https://issues.apache.org/jira/secure/attachment/12475302/ApacheCommons_Documented_Test.java,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2011-04-03 10:22:06.145,,,false,,,,,,,,,,,,,,18629,,,Thu Apr 18 19:09:57 UTC 2013,,,,,,0|i0ftcv:,90354,,,,,,,,"03/Apr/11 10:22;sebb@apache.org;The tool sounds interesting, but at present it is difficult to check what is happening. The comments on the asserts are OK, but otherwise the tests are hard to understand.

Every class name is given in full, even java.lang.Integer. The testing tool should generate the necessary imports.

There should be a package clause with the same package as the class under test, and the test class name should relate to the class under test, e.g. BeanMapAutoTest. Each test class should only test one target class.

The throws clauses should be ""throws Exception"" rather than Throwable.

In the test0() method, there appear to be lots of unused variables, and the test target (BeanMap) has been deprecated (and in fact has since been removed).

In the test1() method, again there are a lot of unused variables. It also looks like the tool failed to add a test part way through, as there is a comment, but no assertion. This might explain the unused variables. Ideally every assertion should be in a different method.","03/Apr/11 10:49;sebb@apache.org;I should have added - test1() does seem to be valid. 

Not sure whether test0() is useful, given that the class is deprecated, but it does seem to expose a failure, as the hashCode is not stable.","03/Apr/11 16:00;saizhang;Thank you very much, Sebb, for all your good suggestion!

We really appreciate your response.





Thanks. We should implement this feature.





Thanks. We should improve the readability of class name



Actually, all you have mentioned above reflect the fact that:
automatically-generated test, though
can reveal previously-unknown bugs, is hard to interpret. From the viewpoint
of developing new fully-automatic testing techniques, that is an inherent
problem, because to reveal bugs: the test created need to be
behaviorally-diverse (e.g., covering as many program states as possible).
Therefore, in my tool, we use several heuristic and randomized algorithms to
achieve this (since doing exhaustive program state search is infeasible,
given the huge space of possible method invocations).

The comments the tool generates aim to alleviate (we can not say it solves)
the above problem (poor readability). As you may find, the generated test is
long, and often has many unused variables. Even developers who are
already familiar with the code can not easily have ideas on which test code
part should they inspect. The comments provide an alternative way to
""correct"" a failed test, which we hope to given additional debugging clues.
We add this ""comment "" feature based on our own (limited) experience: when
given a long/hard-to-read failed test, a common practice for programmers to
start debugging is try to make some minimal edit,  making the failed test
pass. Then, observe the difference between a failed and passing execution.

We agree that the tool itself is still far from perfect (due to the
randomized algorithm it uses). Compared with the long test without comments,
 do you think the test with comments can somehow give certain debugging
clues, and help to guide programmers to inspect the right place more
efficiently? (we know the automatically-generated test is still much worse
than human written one)

Thanks a lot.

-Sai





","03/Apr/11 18:46;sebb@apache.org;The assertion itself is easy to understand, it's just that all the redundant assignments make it hard to read (and may generate warnings from some IDEs).","03/Apr/11 19:04;saizhang;Thanks Sebb. What about the comments in the middle of the long test. Do you
think such kind of comments useful for debugging?

-Sai





--
","07/Feb/13 18:25;tn;The first test is not relevant anymore, as BeanMap has been removed.

The second test checks symmetry of equals for the following scenario:

{noformat}
 v1 = BoundedFifoBuffer
 v2 = TransformedBuffer(v1)
 v3 = UnmodifiableBuffer(v2)

 v2 == v3 && v3 == v2
{noformat}

this fails because of AbstractCollectionDecorate#equals:

{noformat}
 return object == this || decorated().equals(object);
{noformat}

now v3.equals(v2) evaluates to true, as v3.decorated() == v2
the other way round, v2.equals(v3) if false, as v2.decorated() == v1, and v1 does not implement equals, thus the default Object.equals() is used, which just compares references.","18/Apr/13 19:09;tn;The respective classes (Buffer, and BeanMap) have been removed for 4.0 so this is not going to be fixed anymore.

The same problem may be still present with the Queue implementations, though the Queue interface states:

{noformat}
Queue implementations generally do not define element-based versions of methods equals and hashCode but instead inherit the identity based versions from class Object, because element-based equality is not always well-defined for queues with the same elements but different ordering properties. 
{noformat}

Thus we should keep it as it is atm, imho.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Bug in class#ListOrderedSet with reproducible JUnit test,COLLECTIONS-373,12503218,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Invalid,,saizhang,saizhang,03/Apr/11 07:43,27/Nov/15 21:47,07/Apr/19 20:37,23/Jan/13 17:05,3.2,,,,,,,,,,,,,,0,patch,,,"Hi all:

I am writing an automated bug finding tool, and using
Apache Commons Collections as an experimental subject
for evaluation.

The tool creates executable JUnit tests as well as
explanatory code comments. I attached one bug-revealing
test as follows. Could you please kindly check it, to
see if it is a real bug or not? 

Also, it would be tremendous helpful if you could give
some feedback and suggestion on the generated code comments?
From the perspective of developers who are relatively familiar
with the code,
is the automatically-inferred comment useful in understanding
the generated test? is the comment helpful in bug fixing?

Your suggestion will help us improve the tool.

Please see attachment for the failed test. A little explaination
on the generated code comments in the failed test

//explaination:
//Test passes if var53 is: (java.lang.Boolean)false  ===> means: 
//     test passes if var52 is not added to var28 (only in that case, var53 is false)
boolean var53 = var28.add((java.lang.Object)var52);",jdk 1.6.x,,,,,,,,,,,,,,,,,,03/Apr/11 07:51;saizhang;ApacheListOrderSet_Documented_Test.java;https://issues.apache.org/jira/secure/attachment/12475301/ApacheListOrderSet_Documented_Test.java,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2013-01-23 17:04:49.561,,,false,,,,,,,,,,,,,,18630,,,Wed Jan 23 17:04:49 UTC 2013,,,,,,0|i0ftd3:,90355,,,,,,,,"18/Aug/11 01:19;saizhang;Hi,

Here is the latest output of our documentation inference tool. It renames all
variable names and (hopefully) makes the test easier to read.

The comments generated by our research tool are shown in the form of:

{code}
//Test passes if:  xxxx (it indicates changes that will make a failed test pass)
{code}

Each piece of comments (not the combination of them) provides a way to correct the failed test.
We hope such additional information will help developers understand/fix the test faster/better.

So, it would be great if anyone can take a look at the reported bug to:
(1) confirm is it a real bug?
(2) is such comment information useful? If not, please give us feedback so we can do our best
     to improve our tool!

Thank you!

-Sai


{code}
public void test0() {
    ListOrderedSet listOrderedSet0 = new ListOrderedSet();
    List list0 = listOrderedSet0.asList();
    List list1 = listOrderedSet0.asList();
    listOrderedSet0.clear();
    Integer i0 = new Integer((-1));
    ListOrderedSet listOrderedSet1 = new ListOrderedSet();
    Integer i1 = new Integer((-1));
    ListOrderedSet listOrderedSet2 = new ListOrderedSet();
    List list2 = listOrderedSet2.asList();
    ListOrderedSet listOrderedSet3 = ListOrderedSet.decorate((Set)listOrderedSet2);
    boolean b0 = listOrderedSet1.addAll(i1, (Collection)listOrderedSet2);
    boolean b1 = listOrderedSet0.addAll(i0, (Collection)listOrderedSet2);
    ListOrderedSet listOrderedSet4 = new ListOrderedSet();
    List list3 = listOrderedSet4.asList();
    List list4 = listOrderedSet4.asList();
    ListOrderedSet listOrderedSet5 = new ListOrderedSet();
    List list5 = listOrderedSet5.asList();
    ListOrderedSet listOrderedSet6 = ListOrderedSet.decorate((Set)listOrderedSet5);
    ListOrderedSet listOrderedSet7 = new ListOrderedSet();
    List list6 = listOrderedSet7.asList();
    ListOrderedSet listOrderedSet8 = ListOrderedSet.decorate((Set)listOrderedSet5, list6);
    boolean b2 = listOrderedSet4.containsAll((Collection)list6);
    ListOrderedSet listOrderedSet9 = ListOrderedSet.decorate((Set)listOrderedSet0, list6);
    ListOrderedSet listOrderedSet10 = new ListOrderedSet();
    int i2 = listOrderedSet10.size();
    boolean b3 = listOrderedSet0.add((Object)i2);
    //Test passes if line is: Integer s0 = new Integer(0)
    Short s0 = new Short((short)1);
    //Test passes if s0 is not added to listOrderedSet0
    boolean b4 = listOrderedSet0.add((Object)s0);
    ListOrderedSet listOrderedSet11 = new ListOrderedSet();
    List list7 = listOrderedSet11.asList();
    List list8 = listOrderedSet11.asList();
    listOrderedSet11.clear();
    Integer i3 = new Integer((-1));
    ListOrderedSet listOrderedSet12 = new ListOrderedSet();
    Integer i4 = new Integer((-1));
    ListOrderedSet listOrderedSet13 = new ListOrderedSet();
    List list9 = listOrderedSet13.asList();
    ListOrderedSet listOrderedSet14 = ListOrderedSet.decorate((Set)listOrderedSet13);
    boolean b5 = listOrderedSet12.addAll(i4, (Collection)listOrderedSet13);
    boolean b6 = listOrderedSet11.addAll(i3, (Collection)listOrderedSet13);
    ListOrderedSet listOrderedSet15 = new ListOrderedSet();
    List list10 = listOrderedSet15.asList();
    List list11 = listOrderedSet15.asList();
    ListOrderedSet listOrderedSet16 = new ListOrderedSet();
    List list12 = listOrderedSet16.asList();
    ListOrderedSet listOrderedSet17 = ListOrderedSet.decorate((Set)listOrderedSet16);
    ListOrderedSet listOrderedSet18 = new ListOrderedSet();
    List list13 = listOrderedSet18.asList();
    ListOrderedSet listOrderedSet19 = ListOrderedSet.decorate((Set)listOrderedSet16, list13);
    boolean b7 = listOrderedSet15.containsAll((Collection)list13);
    ListOrderedSet listOrderedSet20 = ListOrderedSet.decorate((Set)listOrderedSet11, list13);
    ListOrderedSet listOrderedSet21 = new ListOrderedSet();
    int i5 = listOrderedSet21.size();
    //Test passes if i5 is not added to listOrderedSet11
    boolean b8 = listOrderedSet11.add((Object)i5);
    boolean b9 = listOrderedSet0.removeAll((Collection)listOrderedSet11);
    
    // Checks the contract:  equals-hashcode on listOrderedSet0 and listOrderedSet20
    assertTrue(""Contract failed: equals-hashcode on listOrderedSet0 and listOrderedSet20"", listOrderedSet0.equals(listOrderedSet20) ? listOrderedSet0.hashCode() == listOrderedSet20.hashCode() : true);
    
    // Checks the contract:  equals-hashcode on listOrderedSet9 and listOrderedSet20
    assertTrue(""Contract failed: equals-hashcode on listOrderedSet9 and listOrderedSet20"", listOrderedSet9.equals(listOrderedSet20) ? listOrderedSet9.hashCode() == listOrderedSet20.hashCode() : true);
    
    // Checks the contract:  equals-hashcode on listOrderedSet11 and listOrderedSet9
    assertTrue(""Contract failed: equals-hashcode on listOrderedSet11 and listOrderedSet9"", listOrderedSet11.equals(listOrderedSet9) ? listOrderedSet11.hashCode() == listOrderedSet9.hashCode() : true);
    
    // Checks the contract:  equals-hashcode on listOrderedSet20 and listOrderedSet9
    assertTrue(""Contract failed: equals-hashcode on listOrderedSet20 and listOrderedSet9"", listOrderedSet20.equals(listOrderedSet9) ? listOrderedSet20.hashCode() == listOrderedSet9.hashCode() : true);
    
    // Checks the contract:  equals-symmetric on listOrderedSet0 and listOrderedSet20.
    assertTrue(""Contract failed: equals-symmetric on listOrderedSet0 and listOrderedSet20."", listOrderedSet0.equals(listOrderedSet20) == listOrderedSet20.equals(listOrderedSet0));
    
    // Checks the contract:  equals-symmetric on listOrderedSet11 and listOrderedSet9.
    assertTrue(""Contract failed: equals-symmetric on listOrderedSet11 and listOrderedSet9."", listOrderedSet11.equals(listOrderedSet9) == listOrderedSet9.equals(listOrderedSet11));
  }

{code}
","23/Jan/13 17:04;tn;Hi,

thanks for the bug report. Such automated test generation tools can be really helpful and interesting, but I do have a hard time trying to understand this testcase. Has there been any improvement to your test tool wrt to understanding the tested scenario?

I adapted the testcase for the latest trunk (4.0-SNAPSHOT) by simply changing the decorate methods with the corresponding listOrderedSet.
The test fails here:

{noformat}
        assertTrue(""Contract failed: equals-hashcode on var0 and var50"", var0.equals(var50) ? var0.hashCode() == var50.hashCode() : true);
{noformat}

When looking at the testcase, var50 is initialized as follows:

{noformat}
        org.apache.commons.collections.set.ListOrderedSet var50 = org.apache.commons.collections.set.ListOrderedSet.listOrderedSet((java.util.Set)var28, var47);
{noformat}

according to the contract of the decorate/listOrderedSet static factory method, the provided List and Set have to be empty and not null. This is not true for your testcase, as the provided argument var28 is not empty.

So I have to reject this testcase as invalid, but would be interested to see advancements in this field.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
ComparatorUtils.transformedComparator wrongly typed (generics),COLLECTIONS-372,12501783,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Minor,Fixed,,pilotmi80,pilotmi80,18/Mar/11 12:45,09/Nov/14 14:31,07/Apr/19 20:37,06/Mar/13 19:52,4.x,,,,,4.0,4.0-alpha1,,Comparator,,,,,,1,patch,,,"ComparatorUtils.transformedComparator is currently typed as follows :

{{public static <I,O> Comparator<O> transformedComparator(Comparator<I> comparator, Transformer<I, O> transformer)}}

It should be typed as follows so that is can be used without removing generics typing:
{{public static <I,O> Comparator<I> transformedComparator(Comparator<O> comparator, Transformer<I, O> transformer)}}

Here is a unit test for it : 
Transformer<Integer, String> itosTransformer = TransformerUtils.stringValueTransformer();
		Comparator<Integer> c = new Comparator<Integer>() {
			
			@Override
			public int compare(Integer o1, Integer o2) {
				return o1.compareTo(o2);
			}
		};
		Comparator<String> stringComparator = ComparatorUtils.transformedComparator(c, itosTransformer);
		
		stringComparator.compare(""string1"", ""string2"");",n/a,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2013-03-06 19:52:38.571,,,false,,,,,,,,,,,,,,18631,,,Wed Mar 06 19:52:38 UTC 2013,,,,,,0|i0ftdb:,90356,,,,,,,,"06/Mar/13 19:52;tn;Made change in r1453516.

Makes sense for a TransformingComparator imho, not always possible for other occurrences.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"BUG in org.apache.commons.collections.CollectionUtils.removeAll(Collection, Collection)   ",COLLECTIONS-371,12497242,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Critical,Duplicate,,li.gui@idealo.de,li.gui@idealo.de,31/Jan/11 19:17,01/Feb/11 07:19,07/Apr/19 20:37,01/Feb/11 07:19,3.2,,,,,,,,Collection,,,,,,0,,,,"line: 1121
public static Collection removeAll(Collection collection, Collection remove) {
    return ListUtils.retainAll(collection, remove); //<<<<<-------- here absolutely wrong!

}

",,,,,,,,,,,,,,COLLECTIONS-357,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,18632,,,2011-01-31 19:17:45.0,,,,,,0|i0shwv:,164379,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
CollectionUtils#removeAll is broken,COLLECTIONS-369,12494808,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Duplicate,,mjharris,mjharris,06/Jan/11 05:52,06/Jan/11 07:29,07/Apr/19 20:37,06/Jan/11 07:29,3.2,,,,,,,,,,,,,,0,,,,method calls into ListUtils#retainAll instead of ListUtils#removeAll.  Should be easy fix for someone with commit rights.,,,,,,,,,,,,,,COLLECTIONS-357,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,18634,,,2011-01-06 05:52:17.0,,,,,,0|i0shx3:,164380,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
DualTreeBidiMap.readObject() uses wrong comparator to create reverseMap,COLLECTIONS-364,12477662,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,sebb@apache.org,sebb@apache.org,sebb@apache.org,18/Oct/10 18:51,27/Nov/15 21:11,07/Apr/19 20:37,18/Oct/10 19:17,,,,,,,,,BidiMap,,,,,,0,,,,"DualTreeBidiMap.readObject() uses the wrong comparator to create reverseMap. The code reads:

bq. reverseMap = new TreeMap(comparator);

it should read:

bq. reverseMap = new TreeMap(valueComparator);

Note: this was found when trying to fix generics warnings.",,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,18639,,,2010-10-18 18:51:11.0,,,,,,0|i0shxz:,164384,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
TransformedMap is Serializable but its superclass doesn't define an accessible void constructor,COLLECTIONS-363,12477526,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,sebb@apache.org,sebb@apache.org,16/Oct/10 01:39,09/Nov/14 14:31,07/Apr/19 20:37,20/Dec/10 19:25,3.2,,,,,4.0,4.0-alpha1,,Map,,,,,,0,,,,"TransformedMap is Serializable but its superclass doesn't define an accessible void constructor.
For example, the following test fails:

{code}
public void testSerialisation() throws Exception {
    TransformedMap<String, String, String, String> map = TransformedMap.decorate(
            new HashMap<String, String>(),  NOPTransformer.<String> getInstance(), NOPTransformer.<String> getInstance());
    ByteArrayOutputStream bytes = new ByteArrayOutputStream();
    ObjectOutputStream out = new ObjectOutputStream(bytes);
    out.writeObject(map); // fails with java.io.InvalidClassException: org.apache.commons.collections.splitmap.TransformedMap; no valid constructor
    out.close();
}
{code}
",,,,,,,,,,,,,,,,,,,20/Dec/10 18:17;isaprykin;COLLECTIONS-363-obj-test-fix.patch;https://issues.apache.org/jira/secure/attachment/12466647/COLLECTIONS-363-obj-test-fix.patch,13/Dec/10 07:52;isaprykin;COLLECTIONS-363.patch;https://issues.apache.org/jira/secure/attachment/12466121/COLLECTIONS-363.patch,20/Dec/10 18:20;isaprykin;TransformedMap.emptyCollection.version3.2.obj;https://issues.apache.org/jira/secure/attachment/12466648/TransformedMap.emptyCollection.version3.2.obj,20/Dec/10 18:20;isaprykin;TransformedMap.fullCollection.version3.2.obj;https://issues.apache.org/jira/secure/attachment/12466649/TransformedMap.fullCollection.version3.2.obj,,,,,,4.0,,,,,,,,,,,,,,,,,,,2010-12-13 07:50:05.928,,,false,,,,,,,,,,,,,,18640,,,Mon Dec 20 19:25:03 UTC 2010,,,,,,0|i0shy7:,164385,,,,,,,,"13/Dec/10 07:50;isaprykin;Hello.
It seems to me that addition of constructor really solves the problem. (look COLLECTIONS-363.patch attached)","20/Dec/10 10:40;scolebourne;All the serializable collections are supposed to have a serialization test, with a .obj file checked into the repo (see the data folder). If you could upload a second patch with the obj file and test that uses it, that would be useful.","20/Dec/10 18:01;isaprykin;I attempted to follow your instructions and done a test case which use .obj files (see patch COLLECTIONS-363-obj-test-fix.patch attached). I'm also open for any suggestions about making it better.

I wonder why splitmap.TestTransformedMap extends BulkTest, but not a AbstractTestObject like all other containers.","20/Dec/10 19:25;sebb@apache.org;Thanks, second patch and obj files applied to SVN",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
FilterListIterator#hasNext throws exception (associate with JUnit tests),COLLECTIONS-360,12472288,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,jochen@apache.org,saizhang,saizhang,23/Aug/10 19:29,09/Nov/14 14:31,07/Apr/19 20:37,01/Mar/11 22:17,3.2,,,,,4.0,4.0-alpha1,,,,,,,,0,,,,"Hi,

I found the some of the iterator classes does not fulfill the iterator specification of JDK.

e.g. hasNext() should never throw exception.

Here is an automatically generated junit test (I am now writing a tool)

{code:java}
public void test233() throws Throwable {
    java.lang.Integer var6 = new java.lang.Integer(0);
    org.apache.commons.collections.list.GrowthList var7 = new org.apache.commons.collections.list.GrowthList(var6);
    org.apache.commons.collections.Predicate var9 = org.apache.commons.collections.PredicateUtils.anyPredicate((java.util.Collection)var7);
    java.lang.Long var10 = new java.lang.Long(10L);
    org.apache.commons.collections.iterators.FilterListIterator var13 = new org.apache.commons.collections.iterators.FilterListIterator(var9);
    //this line throws exception!
    var13.hasNext();
}
{code}
could you please check it to confirm whether it is bug or I misunderstand the specification of apache common collections?

thanks,
",ubuntu,,,,,,,,,,,,,,,,,,29/Dec/10 10:26;miccagiann;FilterListIterator.java;https://issues.apache.org/jira/secure/attachment/12467106/FilterListIterator.java,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2010-12-13 08:56:42.004,,,false,,,,,,,,,,,,,,18643,,,Tue Mar 01 22:17:27 UTC 2011,,,,,,0|i0shyn:,164387,,,,,,,,"13/Dec/10 08:56;isaprykin;As far as I understand expression ""{{FilterListIterator(var9)}}"" resolves into {{FilterListIterator(Predicate<? super E> predicate)}} constructor. Here's what it's javadoc is saying:
{quote}{noformat}
Constructs a new <code>FilterListIterator</code> that will not function
until {@link #setListIterator(ListIterator) setListIterator} is invoked.

@param predicate  the predicate to use.{noformat}{quote}
So if a {{ListIterator}} isn't specified than [NullPointerException|http://download.oracle.com/javase/6/docs/api/java/lang/NullPointerException.html](your case) is thrown.
I think, you're partialy right - {{FilterListIterator}} implements {{Iterator}} interface and [Iterator.hasNext()|http://download.oracle.com/javase/6/docs/api/java/util/Iterator.html#hasNext()] doesn't specify any exceptions to be thrown.

If it's really an issue maybe these two constructors  - {{FilterListIterator(Predicate<? super E> predicate)}} and {{FilterListIterator(ListIterator<? extends E> iterator )}} should be deprecated?","27/Dec/10 16:09;miccagiann;I can confirm that the line ""var13.hasNext();"" from the above unitTest throws a NullPointerException and that's because iterator has the value NULL. So in order to fix this bug wouldn't it be a good idea before we checked the private variable iterator if is null in the functions of FilterListIterator where it is called? ","29/Dec/10 10:26;miccagiann;Functions that have been modified: setNextObject(), setPreviousObject().",30/Dec/10 08:46;miccagiann;I would like to ask if anyone who has worked with this issue has any unit Tests so as to be sure that this implementation work 100%... Thanks!,"01/Mar/11 22:17;jochen@apache.org;Diagnosis: Agreed that the contract of hasNext() forbids throwing an NPE and this is a bug.
Also agreeing with Igor that the constructors allowing such behaviour are essentially broken. Nevertheless we have them and so we must support them for binary compatibility.
Hence eliminating the NPE for the FilterListIterator.

Zhang writes that ""some of the iterator classes"" have this problem. OTOH, this is nowhere made clear. Feel free to reopen, should you find any more classes in question.
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
A  ∩ B  !=  B  ∩ A when duplicates are present in a list,COLLECTIONS-359,12468568,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,mwshead,mwshead,05/Jul/10 14:58,09/Nov/14 14:31,07/Apr/19 20:37,28/Feb/13 19:37,3.2,,,,,4.0,4.0-alpha1,,Collection,,,,,,0,,,,"When duplicates are present in a list, ListUtils.intersection doesn't behave as expected. The intersection of two lists should give the same result regardless of which list comes first. ListUtils.intersection(A,B) should equal ListUtils.intersection(B,A).  This is not the case when the list contains duplicates.

Right now:
 [a, b]  ∩  [a, a, b, b] =  [a, a, b, b]
and
 [a, a, b, b]  ∩  [a, b] =  [a, b]

Expected behavior:

 [a, a, b, b]  ∩  [a, b] =  [a, b]
 [a, b]  ∩  [a, a, b, b] =  [a, b]


Code demonstrating the problem.

		List A = new ArrayList();
		List B = new ArrayList();
		A.add(""a"");
		A.add(""b"");
		B.add(""a"");
		B.add(""a"");
		B.add(""b"");
		B.add(""b"");
		System.out.println(""List A: "" + A);
		System.out.println(""List B: "" + B);
		System.out.println(""A ∩ B = "" + ListUtils.intersection(A,B));
		System.out.println(""B ∩ A = "" +ListUtils.intersection(B,A));

output:

List A: [a, b]
List B: [a, a, b, b]
A ∩ B = [a, a, b, b]
B ∩ A = [a, b]",,,,,,,,,,,,,,,,,,,05/Jul/10 15:48;mwshead;COLLECTIONS-359.patch;https://issues.apache.org/jira/secure/attachment/12448709/COLLECTIONS-359.patch,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2010-07-18 07:43:55.447,,,false,,,,,,,,,,,,,,18644,,,Sun Jul 18 07:43:55 UTC 2010,,,,,,0|i0shyv:,164388,,,,,,,,05/Jul/10 15:48;mwshead;This patch fixes the problem and adds a unit test that will fail when the problem remains.,"18/Jul/10 07:43;bayard;Thanks Mark. Patch applied.

svn ci -m ""Applying Mark Shead's patch to COLLECTIONS-359. The intersection method was not handling duplicates correctly. ""
Sending        src/java/org/apache/commons/collections/ListUtils.java
Sending        src/test/org/apache/commons/collections/TestListUtils.java
Transmitting file data ..
Committed revision 965173.
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"CollectionUtils.removeAll(Collection collection, Collection remove) calls ListUtils.retainAll(collection, remove)",COLLECTIONS-358,12468204,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Duplicate,,rasenderhase,rasenderhase,29/Jun/10 21:35,29/Jun/10 23:38,07/Apr/19 20:37,29/Jun/10 23:38,3.1,,,,,,,,Collection,,,,,,0,,,,"Inside CollectionUtils.removeAll(Collection collection, Collection remove) the retainAll() method of ListUtils is called in line 1122.
It should read ListUtils.removeAll(collection, remove) instead.

Workaround: use ListUtils.removeAll(Collection collection, Collection remove) instead.",any,,,,,,,,,,,,,COLLECTIONS-357,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,18645,,,2010-06-29 21:35:09.0,,,,,,0|i0shz3:,164389,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
CollectionUtils.removeAll invokes wrong Listutils method,COLLECTIONS-357,12467833,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Critical,Duplicate,,fabianlange,fabianlange,24/Jun/10 20:03,09/Nov/14 14:31,07/Apr/19 20:37,28/Feb/13 19:25,3.2,,,,,4.0,4.0-alpha1,,Collection,,,,,,0,,,,"{code}
    public static Collection removeAll(Collection collection, Collection remove) {
        return ListUtils.retainAll(collection, remove);
    }
{code}",,,,,,,,,,,,,,COLLECTIONS-219,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2010-07-18 07:40:45.853,,,false,,,,,,,,,,,,,,18646,,,Sun Jul 18 07:40:45 UTC 2010,,,,,,0|i0shzb:,164390,,,,,,,,18/Jul/10 07:40;bayard;Fixed in trunk.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
class cast exception in common collection-3.2  jar,COLLECTIONS-355,12465455,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Invalid,,manu004,manu004,26/May/10 13:18,19/Jun/10 19:37,07/Apr/19 20:37,19/Jun/10 19:37,3.2,,,,,,,,Map,,,,,,0,,,,"Recently I have upgraded common collection jar to 3.2 version. After that I got a class cast exception in the following code java code 
String checkedInStation = (String)(((HashMap)lstQueuedPsgrs.get(startIndex))
                        .get(""PSGRCHECKEDINSTATION""));

The exception detail as below

java.lang.ClassCastException: org.apache.commons.collections.map.ListOrderedMap
at sun.reflect.GeneratedMethodAccessor279.invoke(Unknown Source)
at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
at java.lang.reflect.Method.invoke(Method.java:585) 
at org.springframework.aop.support.AopUtils.invokeJoinpointUsingReflection(AopUtils.java:287)
at org.springframework.aop.framework.ReflectiveMethodInvocation.invokeJoinpoint(ReflectiveMethodInvocation.java:181) 
at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation","Unix, jdk 1.5.0.06",,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2010-05-26 13:25:59.709,,,false,,,,,,,,,,,,,,18648,,,Sat Jun 19 19:37:29 UTC 2010,,,,,,0|i0shzj:,164391,,,,,,,,"26/May/10 13:25;julien.ayme@gmail.com;Hello,

I think the ClassCastException is thrown because the lstQueuedPsgrs object you have is not an HashMap but a ListOrderedMap.
Did you try to cast your object to a Map instead?

It is generally better to use the Map interface rather than a specific implementation in case of the implementation changes, just as the error you appears to have.

HTH,
Regards,

Julien",26/May/10 14:34;sebb@apache.org;Reformat to make stacktrace easier to read,"01/Jun/10 11:40;manu004;
Hi Julien, 
Thanks for your support...... When i changed HashMap to Map it is working.
Still I am confused about the listOrderedMap

In the following code snippet :

List<HashMap> objList =null;       //Create a list and it is  using the Data Access layer to fetch the data .
objList = XDA.getInfo(threadId);     //in XDA,we fetch the data using the hibernate jdbc templete: 

list = YDAO.getListByQuery(sqlStr.toString(), arr); 
return list; // So the return list will be  a List of Maps. This value will be stored in the objList  variable.

//set the list objList  in a model object called psgrModel
   psgrModel.setPassengers(objList); 
//pass the model into another method in the same class and fetch the same data processXInfo(psgrModel);

//in processXInfo(psgrModel) method we are delclaring a list called lstQueuedPsgrs and stored the queued passengers
    List lstQueuedPsgrs = psgrModel.getQueuedPassengers(); 
Int startIndex=0; 
//get the data from the list into the HashMap and then get the value from it using the key XYZ as set DA layer while 
//fetching from the database 
     String xyz = (String)(((HashMap)lstQueuedPsgrs.get(startIndex)).get(""XYZ""));

It was working fine in the appache common-collection version 1.1 but as we upgraded it to 3.2 version, its giving the following exception. 
java.lang.ClassCastException: org.apache.commons.collections.map.ListOrderedMap 

And in this particular class we are importing the java.util package. not common collection.
Although it is working fine with Map, but can anyone please tell us the reason why is it getting ListOrderedMap instead of HaspMap???
","19/Jun/10 19:37;bayard;Resolving - please take to the user list.

Note that you don't identify the entry point into Commons; this could (by the look of your comments) be a change in Hibernate or could be a change in whatever the part of Commons is that you're calling to get the Map.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
AbstractLinkedMap firstKey/lastKey JavaDoc reversed,COLLECTIONS-353,12457133,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Duplicate,,mduerig,mduerig,23/Feb/10 10:15,27/Apr/13 21:26,07/Apr/19 20:37,19/Jun/10 19:28,3.2,,,,,4.0,,,Map,,,,,,0,,,,"According to the Javadoc on AbstractLinkedMap#firstKey and AbstractLinkedMap#lastKey the following test shouldn't fail:

    LinkedMap map = new LinkedMap();
    map.put(""one"", ""one"");
    map.put(""two"", ""two"");
    assertEquals(""one"", map.lastKey());
    assertEquals(""two"", map.firstKey());
",,,,,,,,,,,,,,COLLECTIONS-262,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2010-06-19 19:28:28.912,,,false,,,,,,,,,,,,,,18650,,,Sat Jun 19 19:28:28 UTC 2010,,,,,,0|i0shzr:,164392,,,,,,,,19/Jun/10 19:28;bayard;Closing as a duplicate of a fixed issue.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
AbstractCollectionDecorator is inconsistent with AbstractListDecorator. Uses private member variable instead of protected getter,COLLECTIONS-352,12455936,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Minor,Fixed,,agent,agent,10/Feb/10 20:34,09/Nov/14 14:31,07/Apr/19 20:37,28/Feb/13 20:05,3.0,3.1,3.2,,,4.0,4.0-alpha1,,Collection,,,,,,0,,,,"AbstractListDecorator uses getList() to access its private member variable for its methods:
{code}
    public int indexOf(Object object) {
        return getList().indexOf(object);
    }
{code}

Which allows me to almost do something like this (notice I'm taking some liberties here with the no-arg serialization constructor):

{code}
    public static class FutureList<T> extends AbstractListDecorator {

        private Future<List<T>> futureList;

        public FutureList(Future<List<T>> futureList)
        {
            super();
            this.futureList = futureList;
        }

        @Override
        protected Collection<T> getCollection()
        {
            try
            {
                return futureList.get();
            }
            catch (InterruptedException e)
            {
                throw new RuntimeException(e);
            }
            catch (ExecutionException e)
            {
                throw new RuntimeException(e);
            }
        }
    }
{code}

But AbstractCollectionDecorator uses its private member variable
{code}
    public boolean add(Object object) {
        return collection.add(object);
    }
{code}

When it should be IMHO:

{code}
    public boolean add(Object object) {
        return getCollection().add(object);
    }
{code}

Of course most everybody has an armpit and an opinion :) ",,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2010-06-19 19:25:59.399,,,false,,,,,,,,,,,,,,18651,,,Sat Jun 19 19:25:59 UTC 2010,,,,,,0|i0shzz:,164393,,,,,,,,19/Jun/10 19:25;bayard;4.0 uses decorated() and both classes are using it instead of the private variable.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
MapUtils.getNumber sends output to System.out,COLLECTIONS-350,12445640,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Minor,Fixed,,eakerma,eakerma,15/Jan/10 16:35,07/Nov/15 20:59,07/Apr/19 20:37,28/Feb/13 20:07,3.2,,,,,3.2.2,4.0,4.0-alpha1,,,,,,,0,,,,"MapUtils.getNumber calls ""logInfo"" on a ParseException and it produces output on the System.out, instead of just returning ""null"" as the documentation states.

Since the expected behavior is to return null, *not* print to System.out.  I recommend we remove the call to logInfo and/or remove the System.out.println inside it.

At minimum, if that's not agreed upon, the ""side-effect"" of writing to System.out should be documented.

I'm happy to offer code for either of these fixes.",,,,,3600,3600,,0%,3600,3600,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2010-01-15 16:48:53.784,,,false,,,,,,,,,,,,,,18653,,,Fri Jan 15 16:48:53 UTC 2010,,,,,,0|i0si07:,164394,,,,,,,,"15/Jan/10 16:48;bayard;logInfo removed. Thanks Michael.

I looked for other System.out instances in the main java tree and the only other one was intended.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
The method CollectionUtils.removeAll() call wrongly ListUtils.retainAll(),COLLECTIONS-349,12444891,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Duplicate,,mat.apache,mat.apache,07/Jan/10 10:47,27/Apr/13 21:26,07/Apr/19 20:37,19/Jun/10 19:21,3.2,,,,,4.0,,,Collection,,,,,,0,,,,The method CollectionUtils.removeAll() calls wrongly ListUtils.retainAll() instead of ListUtils.removeAll().,,,,,,,,,,,,,,COLLECTIONS-219,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2010-02-02 00:11:02.337,,,false,,,,,,,,,,,,,,18654,,,Sat Jun 19 19:21:33 UTC 2010,,,,,,0|i0si0f:,164395,,,,,,,,"02/Feb/10 00:11;bishiboosh;In the last trunk, it seems to be fixed.",19/Jun/10 19:21;bayard;Closing as dupe.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Javadoc: incorrect behavior explained for XXXUtils.transformedXXX,COLLECTIONS-348,12443858,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,pbenedict,pbenedict,20/Dec/09 03:58,09/Nov/14 14:31,07/Apr/19 20:37,15/Oct/10 19:39,3.2,,,,,4.0,4.0-alpha1,,Bag,Collection,List,Map,Set,,0,,,,"As a sequel to COLLECTIONS-288, any utility method that ""transformed"" needs to document that the incoming collection is not immediately transformed -- future additions are.

Candidate methods:
* BagUtils.transformedBag
* BagUtils.transformedSortedBag
* CollectionUtils.transform
* CollectionUtils.transformedCollection
* ListUtils.transformedList *done*
* MapUtils.transformedMap
* MapUtils.transformedSortedMap
* SetUtils.transformedSet
* SetUtils.transformedSortedSet",,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2010-10-15 19:39:57.299,,,false,,,,,,,,,,,,,,18655,,,Fri Oct 15 19:39:57 UTC 2010,,,,,,0|i0si0n:,164396,,,,,,,,15/Oct/10 19:39;brentworden;all changes have been made.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
SetUniqueList.decorate throws exceptions that is not documented,COLLECTIONS-346,12441619,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Won't Fix,,justfly,justfly,24/Nov/09 23:18,19/Jun/10 19:41,07/Apr/19 20:37,19/Jun/10 19:41,3.2,,,,,,,,List,,,,,,0,,,,"public static void main(String[] args) {
        List<String> testList=Arrays.asList(""a"",""b"",""c"",""a"",""b"",""c"",""e"");
        SetUniqueList decoratedList = SetUniqueList.decorate(testList);
        System.out.println(decoratedList);
    }
 
throws below exception:
Exception in thread ""main"" java.lang.UnsupportedOperationException
	at java.util.AbstractList.remove(AbstractList.java:172)
	at java.util.AbstractList$Itr.remove(AbstractList.java:437)
	at java.util.AbstractList.removeRange(AbstractList.java:662)
	at java.util.AbstractList.clear(AbstractList.java:258)
	at org.apache.commons.collections.list.SetUniqueList.decorate(SetUniqueList.java:80)

caused by the list to decorate is unmodifiable.",,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2010-02-02 00:13:02.599,,,false,,,,,,,,,,,,,,18657,,,Sat Jun 19 19:41:43 UTC 2010,,,,,,0|i0si0v:,164397,,,,,,,,"02/Feb/10 00:13;bishiboosh;I think a simple add in the javadoc would prevent this issue, as the comportement seems legal (but not documented)","19/Jun/10 19:41;bayard;Agreed, but it should be javadoc'd in java.util.Arrays.asList as that's the location that is throwing the UnsupportedOperationException.

SetUniqueList.decorate() isn't the one making the decision here; the coder is as they've chosen to pass in an unmodifiable list (though Arrays.asList doesn't make that clear, at least in the 1.5 javadoc).

Resolving as nothing for us to do.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Functor singleton classes do not implement singleton pattern correctly,COLLECTIONS-343,12438201,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,ghacek,ghacek,15/Oct/09 12:15,09/Nov/14 14:31,07/Apr/19 20:37,28/Feb/13 19:37,,,,,,4.0,4.0-alpha1,,Functor,,,,,,0,,,,"All classes in package ""org.apache.commons.collections.functors"" that advertise that they have singleton instance actually cannot guarantee that.  Because of serialization support multiple instances of those classes can exist at runtime.

Following classes are making this false claim:
* CloneTransformer
* ExceptionClosure
* ExceptionFactory
* ExceptionPredicate
* ExceptionTransformer
* FalsePredicate
* NOPClosure
* NOPTransformer
* NotNullPredicate
* NullPredicate
* StringValueTransformer
* TruePredicate",,,,,,,,,,,,,,,,,,,15/Oct/09 12:20;ghacek;fix_functor_singletones.patch;https://issues.apache.org/jira/secure/attachment/12422223/fix_functor_singletones.patch,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2009-12-29 23:12:50.355,,,false,,,,,,,,,,,,,,18660,,,Tue Dec 29 23:12:50 UTC 2009,,,,,,0|i0si1j:,164400,,,,,,,,"15/Oct/09 12:20;ghacek;Fix for this issue is simple, all of these classes should implement readResolve() in the following way:

{noformat}private Object readResolve() {
    return INSTANCE;
}
{noformat}

This also makes default equals() and hashCode() methods behave correctly for this classes.

I am providing a patch for this issue with tests, so can someone, please, review it.","29/Dec/09 23:12;mbenson;! /Users/mbenson/oss/asf/commons/trunks-proper/collections> svn commit -m ""[COLLECTIONS-343] applied patch to preserve singleton integrity with readResolve"" src pom.xml 
Sending        pom.xml
Sending        src/java/org/apache/commons/collections/functors/CloneTransformer.java
Sending        src/java/org/apache/commons/collections/functors/ExceptionClosure.java
Sending        src/java/org/apache/commons/collections/functors/ExceptionFactory.java
Sending        src/java/org/apache/commons/collections/functors/ExceptionPredicate.java
Sending        src/java/org/apache/commons/collections/functors/ExceptionTransformer.java
Sending        src/java/org/apache/commons/collections/functors/FalsePredicate.java
Sending        src/java/org/apache/commons/collections/functors/NOPClosure.java
Sending        src/java/org/apache/commons/collections/functors/NOPTransformer.java
Sending        src/java/org/apache/commons/collections/functors/NotNullPredicate.java
Sending        src/java/org/apache/commons/collections/functors/NullPredicate.java
Sending        src/java/org/apache/commons/collections/functors/StringValueTransformer.java
Sending        src/java/org/apache/commons/collections/functors/TruePredicate.java
Sending        src/test/org/apache/commons/collections/TestClosureUtils.java
Sending        src/test/org/apache/commons/collections/TestFactoryUtils.java
Sending        src/test/org/apache/commons/collections/TestPredicateUtils.java
Sending        src/test/org/apache/commons/collections/TestTransformerUtils.java
Adding         src/test/org/apache/commons/collections/TestUtils.java
Transmitting file data ..................
Committed revision 894507.
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
NOPClosure has a broken equals method,COLLECTIONS-340,12438076,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Minor,Fixed,,ghacek,ghacek,14/Oct/09 11:45,09/Nov/14 14:31,07/Apr/19 20:37,28/Feb/13 19:55,,,,,,4.0,4.0-alpha1,,Functor,,,,,,0,,,,"Equals method of NOPClosure class doesn't follow objects equals contract. It isn't symmetric nor transitive and it is just plain wrong.

Following code evaluates to true on most (if not all) JVM implementations:
{noformat} NOPClosure.INSTANCE.equals(new Integer(System.identityHashCode(NOPClosure.INSTANCE))) {noformat} ",,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2009-10-14 14:18:37.128,,,false,,,,,,,,,,,,,,18663,,,Tue Apr 23 19:35:59 UTC 2013,,,,,,0|i0si1z:,164402,,,,,,,,"14/Oct/09 11:48;ghacek;None of the classes in ""org.apache.commons.collections.functors"" package implement equals() or hashCode() so why should NOPClosure be any different.

I suggest removal of both equals() and hashCode()  from NOPClosure.","14/Oct/09 14:18;mbenson;Rather than remove it -- any NOPClosure, after all, _should_ be equal to any other -- I fixed it.  Committed revision 825148.","23/Apr/13 19:35;tn;It looks like this change has been lost during the generics_branch merge.
I think we can keep it as is and highlight it in the release notes.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
BasicPredicateTestBase.assertFalse & BasicPredicateTestBase.assertTrue methods have confusing names,COLLECTIONS-337,12435750,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Won't Fix,,sebb@apache.org,sebb@apache.org,15/Sep/09 19:32,19/Jun/10 19:43,07/Apr/19 20:37,19/Jun/10 19:43,,,,,,,,,,,,,,,0,,,,"BasicPredicateTestBase.assertFalse & BasicPredicateTestBase.assertTrue methods have confusing names - they are the same as the JUnit names, but don't override them.

Of course it's still possible to use the JUnit versions of the methods, but the code is harder to understand.",,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2010-06-19 19:43:45.755,,,false,,,,,,,,,,,,,,18666,,,Sat Jun 19 19:43:45 UTC 2010,,,,,,0|i0si2n:,164405,,,,,,,,19/Jun/10 19:43;bayard;I don't see why they would have to override the method signatures in the JUnit superclass. Method overloading is not abnormal.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
bidimap.TreeBidiMap.entrySet is never written,COLLECTIONS-335,12435485,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,jochen@apache.org,sebb@apache.org,sebb@apache.org,11/Sep/09 22:17,07/Nov/15 20:31,07/Apr/19 20:37,01/Mar/11 22:28,,,,,,3.2.2,4.0,4.0-alpha1,,,,,,,0,,,,"The field bidimap.TreeBidiMap.entrySet is never written.

Looks like it was perhaps intended to be used as a cache, but the cache value is not written.",,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2010-02-02 00:14:05.354,,,false,,,,,,,,,,,,,,18668,,,Tue Mar 01 22:28:44 UTC 2011,,,,,,0|i0si33:,164407,,,,,,,,"02/Feb/10 00:14;bishiboosh;entrySet is used by public Set<Map.Entry<K, V>> entrySet()","02/Feb/10 00:29;sebb@apache.org;Yes, but the *only code* that accesses entrySet is the following, which does not write the value:

{code}
public Set<Map.Entry<K, V>> entrySet() {
    if (entrySet == null) {
        return new EntryView();
    }
    return entrySet;
}
{code}

Thus entrySet will remain null, and a new EntryView() will always be created.","01/Mar/11 22:28;jochen@apache.org;Following the behaviour in the trunk and assigning entrySet now when entrySet() is invoked for the first time.
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
map.StaticBucketMap.size() needs to synchronize access to lock,COLLECTIONS-334,12435451,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,jochen@apache.org,sebb@apache.org,sebb@apache.org,11/Sep/09 17:46,08/Nov/15 21:07,07/Apr/19 20:37,01/Mar/11 22:36,,,,,,3.2.2,4.0,4.0-alpha1,Collection,,,,,,0,,,,"The field Lock.size is updated using synchronization, however the StaticBucketMap.size() method reads the values without synch.

If the read is done in a different thread from the updates, there is no guarantee that the reading thread will see the most recent value.
",collections_jdk5_branch,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2011-03-01 22:36:02.185,,,false,,,,,,,,,,,,,,18669,,,Tue Mar 01 22:36:02 UTC 2011,,,,,,0|i0si3b:,164408,,,,,,,,"01/Mar/11 22:36;jochen@apache.org;Sebb is right: The size() method is the only place not synchronizing access to the locks. Fixed.
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
ListOrderedMap not respecting underlying list,COLLECTIONS-332,12430014,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Minor,Fixed,,thpr,thpr,10/Jul/09 02:24,09/Nov/14 14:31,07/Apr/19 20:37,08/Mar/11 21:34,,,,,,4.0,4.0-alpha1,,Map,,,,,,0,,,,"When decorating either CaseInsensitiveMap or IdentityMap (and I believe this will impact any java.util.TreeMap built with a non-.equals() Comparator), ListOrderedMap responds inconsistently with the underlying map.  The ordering seems to be operating off .equals() rather than the actual contents of the underlying map. 
",,,,,,,,,,,,,,,,,,,10/Jul/09 02:26;thpr;ListOrderedMapTest.java;https://issues.apache.org/jira/secure/attachment/12413071/ListOrderedMapTest.java,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2009-07-26 20:13:01.215,,,false,,,,,,,,,,,,,,18671,,,Tue Mar 08 21:34:21 UTC 2011,,,,,,0|i0si3j:,164409,,,,,,,,"10/Jul/09 02:26;thpr;Test that demonstrates the issue with both CaseInsensitiveMap or IdentityMap as the underlying map.

Note that this set of tests is not comprehensive (other methods than .firstKey() can demonstrate the issue)","26/Jul/09 20:13;curtjohn;When you remove an object from a ListOrderedMap there are two main steps:

{code}
public Object remove(Object key) {
        Object result = getMap().remove(key);
        insertOrder.remove(key);
        return result;
}
{code}

Firstly, the removal of the object from the underlying map is delegated to the map instance. Since in your case this will be an Identity map, the removal method will search by '==' rather than '.equals()' as with a standard Map implementation.

Secondly, the ListOrderedMap decorator needs to remove this key from its own internal list which is charged with maintaining order. To do this it will use the standard '.remove()' from the ArrayList class, which will search using equality rather than identity.

These two different implementations cause problems when used together. In my opinion the IdentityMap (knowingly) breaks the Map interface by searching on identity rather than equality (see Map.remove() javadoc: ""if this map contains a mapping from key k to value v such that (key==null ? k==null : key.equals(k)), that mapping is removed.""). This causes problems for any classes using an instance of this class expecting it to strictly adhere to the Map interface.

Therefore the bug isn't really in the ListOrderedMap class but rather in the usage of the two together. I would suggest improving documentation in the IdentityMap javadoc to clarify this problem. Otherwise we would need to introduce a less-than-elegant 'instance of' check in the ListOrderedMap class which would not be ideal.","14/Aug/09 03:41;thpr;Per my note to the commons user list, I was hoping for either updated docs or a code change, but I think one of the two would be good.

Looking for a code change, I agree casting is nasty and would recommend against it... it's very ugly to get all cases correct.  For example, a TreeMap sorted in case insensitive order also breaks ListOrderedMap because it also fails to use .equals().  

Before this is turned into a documentation bug or feature request, I'd like to note a potential solution simply depends upon how much of a performance hit one is willing to take.

{code:java}
Object result = getMap().remove(key);
for (Iterator<Object> it = insertOrder.iterator(); it.hasNext();) {
  if (!getMap().containsKey(it.next())) { //This respects equality as defined by the underlying map
    it.remove();
  }
}
return result;
{code}

...would seem to be universal (if slower since it effectively trades a .equals() for a .containsKey() call) [and yes, getMap() should be extracted to a local variable]
","08/Mar/11 21:34;jochen@apache.org;Added the following comment on ListOrderedMap:

*Note* that ListOrderedMap doesn't work with {{IdentityMap}},
{{CaseInsensitiveMap}}, or similar maps that violate the general
contract of {{Map}}. The {{ListOrderedMap}} (or, more precisely,
the underlying {{List}}) is relying on {{equals()}}. This is
fine, as long as the decorated {{Map}} is also based on
{{equals()}}, and {{hashCode()}}, which {{IdentityMap}}, and
{{CaseInsensitiveMap}} don't: The former uses {{==}}, and
the latter uses {{equals()}} on a lowercased key.

Added the following to IdentityMap, and CaseInsensitiveMap:

*Note* This map will violate the detail of various Map and map view
contracts. As a general rule, don't compare this map to other
maps. In particular, you can't use decorators like
{{ListOrderedMap}} on it, which silently assume that these
contracts are fulfilled.
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
CollatingIterator NPE when Comparator is null,COLLECTIONS-331,12428785,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Minor,Fixed,jochen@apache.org,krkoska,krkoska,24/Jun/09 14:32,09/Nov/14 14:31,07/Apr/19 20:37,08/Mar/11 22:33,3.2,,,,,4.0,4.0-alpha1,,Iterator,,,,,,0,,,,"Run the attached Test against commons-collections-3.2.1. While the JavaDoc for CollatingIterator claims 

{{@param comp  the comparator to use to sort, or null to use natural sort order}}

the test fails, because the comparator is null.

Fixing this requires a change in {{org.apache.commons.collections.iterators.CollatingIterator.least()}}: 

{code}
if (comparator.compare(curObject,leastObject) < 0) { ...
{code}

could be replaced with

{code}
int c = comparator==null?((Comparable)curObject).compareTo(leastObject):comparator.compare(curObject,leastObject);
if (c < 0) { ...
{code}


The workaround is to provide a comparator, of course.",,,,,300,300,,0%,300,300,,,,,,,,,25/Jun/09 08:44;krkoska;COLLECTIONS-331.patch;https://issues.apache.org/jira/secure/attachment/12411771/COLLECTIONS-331.patch,24/Jun/09 14:33;krkoska;CollatingIteratorTest.java;https://issues.apache.org/jira/secure/attachment/12411653/CollatingIteratorTest.java,,,,,,,,2.0,,,,,,,,,,,,,,,,,,,2010-03-26 06:35:52.748,,,false,,,,,,,,,,,,,,18672,,,Thu Jul 26 23:07:49 UTC 2012,,,,,,0|i0si3r:,164410,,,,,,,,24/Jun/09 14:33;krkoska;JUnit4 Testcase showing bug,"25/Jun/09 08:44;krkoska;This patch fixes the bug by using ComparableComparator if the comparator is null. 
Testcase is adapted as well.","26/Mar/10 06:35;bayard;Confirm on the bug. 

Issue is that ComparableComparator can't be used if the objects aren't Comparable.

Now that things are generified this won't even compile. Specifically this is that CollatingIterator<E> and ComparableComparator<E extends Comparable<? super E>> don't match.

One option would be to throw exception if not comparable, but use comparable comparator if E is comparable.","08/Mar/11 22:33;jochen@apache.org;Agree with Hen's assessment that the use of Comparable.compareTo might likely cause a bunch of other problems.

I have verified, that this bug exists in every revision since CollatingIterator was verified. In other words, we don't need to care for upwards compatibility, there can't be any code floating around that depends on the use of ""natural sort order"".

Consequently I decided to

* throw an NPE in least() with a message describing the problem, if no Comparator is present. (This meets the current behaviour, so it is upwards compatible.)
* change the documentation of the default constructor to require a call to setComparator
* remove all references to ""natural sort order"" and replace them with the recommendation to use ComparableComparator, if required","26/Jul/12 23:07;hudson;Integrated in commons-collections #69 (See [https://builds.apache.org/job/commons-collections/69/])
    Add change for 3.2.2 also for 4.0 release, fix javadoc for COLLECTIONS-331. (Revision 1366195)

     Result = SUCCESS
tn : http://svn.apache.org/viewvc/?view=rev&rev=1366195
Files : 
* /commons/proper/collections/trunk/src/changes/changes.xml
* /commons/proper/collections/trunk/src/main/java/org/apache/commons/collections/iterators/CollatingIterator.java
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
ConcurrentModificationException using remove from the keySet the LRUMap,COLLECTIONS-330,12428092,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,joehni,joehni,17/Jun/09 09:52,09/Nov/14 14:31,07/Apr/19 20:37,21/Feb/11 19:17,,,,,,4.0,4.0-alpha1,,Collection,,,,,,0,,,,"Even if the access to a LRUMap is synced and the remove method of the iterator is used that has been returned from the keySet of the LRUMap, it is possible to get a ConcurrentModificationException. This does not happen for remove of the iterators returned by the entrySet or values of the LRUMap. See currently not executed unit test in TestLRUMap (marked as TODO for COLLECTION-3).",,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2009-06-17 23:07:00.967,,,false,,,,,,,,,,,,,,18673,,,Mon Feb 21 22:16:33 UTC 2011,,,,,,0|i0si3z:,164411,,,,,,,,"17/Jun/09 22:41;joehni;Actually ""remove"" from the MapIterator does not work either.",17/Jun/09 23:07;sebb@apache.org;It works for me - but there needs to be an iter.next() before the map.get(iter.getValue()).,"18/Jun/09 06:37;joehni;Thanks for heads-up. I ""fixed"" the invalid test, but it fails for me still. You did recognize that you have to rename the two tests with the TODO comment to get them running as unit test?","18/Jun/09 10:46;sebb@apache.org;Your fix was different from mine - I just added iter.next(), so the code became:

{code}
iter.next();
if (map.get(iter.getValue()) == this) {
     iter.remove();
}
{code}

which works fine.

However the current code is:

{code}
String name = (String)iter.next();
if (map.get(name) == this) {
    iter.remove();
}
{code}

which fails.","18/Jun/09 12:50;sebb@apache.org;Note that this does not appear to be a threading issue - the testSynchronizedRemoveFromMapIterator test fails even with only one thread. Similarly for testSynchronizedRemoveFromKeySet.

Perhaps there should be separate single-threaded tests - or at least, the tests should check a single thread first before attempting multiple threads.

BTW, I added some detail to the ConcurrentModificationException, this shows that the check that is failing is 1001!=1000 (single thread test)
i.e. the expectedModCount is one less than the parent.modCount. Looks like one of the methods is not updating expectedModCount correctly.","18/Jun/09 13:20;sebb@apache.org;Also, the tests both still fail even if the iter.remove() call is commented out, but they then fail on the iter.next().

If the map.get() call is commented out, leaving just iter.remove(), the test works fine in single-threaded and multi-threaded mode.

Looks like the get() is not maintaining expectedModCount.","18/Jun/09 14:57;sebb@apache.org;The test testSynchronizedRemoveFromEntrySet also fails if one adds the following to the iterator loop:

map.get(entry.getKey());

The problem is that get() has side effects.","10/Feb/11 23:46;mbenson;Correct, but the contract of the map permits this, as iteration order is based on RU concerns.  Calling {{get()}} restructures the underlying data because the current entry becomes the LRU entry and so the map is modified.  The answer, therefore, is not to call get() when testing iterator behavior per the contract of the map.  Commit forthcoming.",21/Feb/11 22:16;mbenson;resolved with svn r#1069618,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Behavior of constructors CaseInsensitiveMap inconsistent with standard Java HashMap,COLLECTIONS-323,12423444,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Minor,Fixed,jochen@apache.org,mbrak,mbrak,22/Apr/09 08:43,09/Nov/14 14:31,07/Apr/19 20:37,08/Mar/11 23:39,3.2,,,,,4.0,4.0-alpha1,,Map,,,,,,0,,,,"The constructor CaseInsensitiveMap(int initialCapacity) throws an IllegalArgumentException if ""the initial capacity is less than one"". This is inconsistent with the standard Java HashMap constructor HashMap(int initialCapacity), which throws an if IllegalArgumentException if ""the initial capacity is negative"".

Thus:
new HashMap(0) ==> no exception
new CaseInsensitiveMap(0) ==> IllegalArgumentException.

This inconsistency is confusing.


Actions:
- Change Javadoc (this shouldn't be a problem in practice since surely there is no code around depending on the fact that the constructor throws an IllegalArgumentException :-))
- Change code.",Any,,,,86400,86400,,0%,86400,86400,,,,,,,,,08/Jan/11 18:18;miccagiann;patch.tar.gz;https://issues.apache.org/jira/secure/attachment/12467797/patch.tar.gz,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2009-05-20 04:32:12.852,,,false,,,,,,,,,,,,,,18678,,,Thu Jul 26 20:11:49 UTC 2012,,,,,,0|i0si4v:,164415,,,,,,,,"20/May/09 04:32;bayard;Same holds true of:

AbstractHashedMap
AbstractLinkedMap
CaseInsensitiveMap
HashedMap
IdentityMap
LinkedMap
LRUMap",06/Jan/11 19:51;miccagiann;I'm on this one...,06/Jan/11 20:03;miccagiann;A quick question: IllegalArgumentException as far as the capacity of the hash map is concerned should be changed or the load factor should be treated the same since it throws the same exception? What i mean is if we are only interested in capacity or if the load factor should throw the same exception if is a negative number?,"07/Jan/11 10:57;scolebourne;The behaviour should match the JDK classes, whatever that is.",08/Jan/11 18:18;miccagiann;Hope that this patch should solve the problem... Please check it and report any inconsistency or thought that may emerge! Thanks in advance! ,"08/Mar/11 23:39;jochen@apache.org;Applied for all classes mentioned by Hen, except for LRUMap, In the case of LRUMap, this would mean to silently increase the capacity, which is most likely not what the user would expect.
","11/Mar/11 19:02;julien.ayme@gmail.com;Why not for the LRUMap?
If I use the map like this:

{code}
List<Bean> list = ...; // Load list from db
Map<String, Bean> map = new LRUMap(list.size());
for (Bean bean : list) {
    map.put(bean.getUserKey(), bean);
}
{code}
I wouldn't want this code to throw an IAE if the list is empty.
The initial capacity is a hint, not the real initial capacity for the map (see HashMap constructor doc comment).
","12/Mar/11 07:03;jochen@apache.org;The solution used for java.util.HashMap as well as for the others now is to silently increase the map size by 1. This is fine for these maps, where the size doesn't really matter.

In the case of the LRUMap, size is important and the user is explicitly choosing a particular size. Silent increment would imply to violate these explicit wishes. IMO, that's not an option.","12/Mar/11 15:39;julien.ayme@gmail.com;I understand that the size is important for this map. But why couldn't one create a map of size 0? I agree, it is not very useful, but the use case I described above would not put anything in the map anyway.","12/Mar/11 18:29;jochen@apache.org;Quoting from the initial bug report: ""This is inconsistent with the standard Java HashMap constructor HashMap(int initialCapacity),""

I had to choose between consistency (incrementing the size by one) and the current behaviour. The latter made much more sense to me and I can think of no reason why one would intentionally create an LRUMap of size 0. The IllegalArgumentException makes perfect sense to me.
","26/Jul/12 20:11;hudson;Integrated in commons-collections #68 (See [https://builds.apache.org/job/commons-collections/68/])
    Add change for COLLECTIONS-323 to changes.xml. (Revision 1366178)

     Result = UNSTABLE
tn : http://svn.apache.org/viewvc/?view=rev&rev=1366178
Files : 
* /commons/proper/collections/trunk/src/changes/changes.xml
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
ComparableComparator.getInstance() not compilable with jdk-compiler,COLLECTIONS-321,12415464,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,daniel.golesny,daniel.golesny,24/Feb/09 11:10,09/Nov/14 14:31,07/Apr/19 20:37,28/Feb/13 20:24,,,,,,4.0,4.0-alpha1,,Comparator,,,,,,0,,,,"Comparator<Integer> c = ComparableComparator.getInstance();

This line is valid with eclipse (3.4) compiler, but the jdk 1.5.0 compiler returns this error:
    [javac] J:\workspace\ndt\cobolclipse-TRUNK\collections_jdk5_branch\src\java\org\apache\commons\collections\comparators\ComparableComparatorTest.java:23: incompatible types; no instance(s) of type variable(s) E exist so that org.apache.commons.collections.comparators.ComparableComparator<E> conforms to java.util.Comparator<java.lang.Integer>
    [javac] found   : <E>org.apache.commons.collections.comparators.ComparableComparator<E>
    [javac] required: java.util.Comparator<java.lang.Integer>
    [javac] 		Comparator<Integer> c = ComparableComparator.getInstance();
    [javac]                                                                         ^
    [javac] 1 error
",,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2009-09-11 16:14:54.051,,,false,,,,,,,,,,,,,,18680,,,Fri Sep 11 16:14:54 UTC 2009,,,,,,0|i0si53:,164416,,,,,,,,11/Sep/09 16:14;mbenson;In the generics branch you'd use {{ComparableComparator.<Integer> getInstance()}}.  svn rev 738956,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
StaticBucketMap#putall() uses inefficient keySet() iterator when it could use entrySet() iterator,COLLECTIONS-320,12414898,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Minor,Fixed,,sebb@apache.org,sebb@apache.org,16/Feb/09 21:58,09/Nov/14 14:31,07/Apr/19 20:37,28/Feb/13 19:58,,,,,,4.0,4.0-alpha1,,Map,,,,,,0,,,,"StaticBucketMap#putall()  uses inefficient keySet() iterator when it could use entrySet() iterator.

Patch to follow.",,,,,,,,,,,,,,,,,,,16/Feb/09 21:58;sebb@apache.org;StaticBucketMap.patch;https://issues.apache.org/jira/secure/attachment/12400300/StaticBucketMap.patch,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2009-04-23 02:45:51.103,,,false,,,,,,,,,,,,,,18681,,,Thu Apr 23 02:45:51 UTC 2009,,,,,,0|i0si5b:,164417,,,,,,,,"23/Apr/09 02:45;bayard;svn ci -m ""Improving effiency of StaticBucketMap.putAll as per COLLECTIONS-320"" src/java/org/apache/commons/collections/map/StaticBucketMap.java 

Sending        src/java/org/apache/commons/collections/map/StaticBucketMap.java
Transmitting file data .
Committed revision 767768.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
IteratorUtils.getIterator(Object obj) performs redundant null check,COLLECTIONS-319,12414891,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Minor,Fixed,,sebb@apache.org,sebb@apache.org,16/Feb/09 19:35,09/Nov/14 14:31,07/Apr/19 20:37,28/Feb/13 20:24,,,,,,4.0,4.0-alpha1,,Collection,,,,,,0,,,,"IteratorUtils.getIterator(Object obj) performs redundant null check:

{code}
        if (obj == null) {
            return emptyIterator();            
...
        } else if (obj != null && obj.getClass().isArray()) {
            return new ArrayIterator(obj);
{code}

obj cannot be null at that point, so the check can be removed. 
[This will also prevent a false positive in Eclipse which later says tha obj may be null]",,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2009-04-23 02:37:18.031,,,false,,,,,,,,,,,,,,18682,,,Thu Apr 23 02:37:18 UTC 2009,,,,,,0|i0si5j:,164418,,,,,,,,"23/Apr/09 02:37;bayard;svn ci -m ""Fixing unnecessary null check in IteratorUtils per COLLECTIONS-319"" src
Sending        src/java/org/apache/commons/collections/IteratorUtils.java
Transmitting file data .
Committed revision 767766.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
CollectionUtils.size(Object object) has impossible null check,COLLECTIONS-318,12414889,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Minor,Fixed,,sebb@apache.org,sebb@apache.org,16/Feb/09 19:28,09/Nov/14 14:31,07/Apr/19 20:37,28/Feb/13 19:58,,,,,,4.0,4.0-alpha1,,Collection,,,,,,0,,,,"CollectionUtils.size(Object object) has impossible null check:

{code}
    public static int size(Object object) {
        if (object == null) {
            return 0;
        }
...
        } else if (object == null) {
            throw new IllegalArgumentException(""Unsupported object type: null"");
...
{code}

The Javadoc specifically says that null is allowed, so I think the object == null clause needs to be removed - it can never be true, and is just confusing.
",,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2009-04-23 02:39:07.861,,,false,,,,,,,,,,,,,,18683,,,Thu Apr 23 02:39:07 UTC 2009,,,,,,0|i0si5r:,164419,,,,,,,,"23/Apr/09 02:39;bayard;svn ci -m ""Removing unnecessary null check per COLLECTIONS-318"" src
Sending        src/java/org/apache/commons/collections/CollectionUtils.java
Transmitting file data .
Committed revision 767767.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
AbstractHashedMap(Map map) constructor calls overridable non-final method,COLLECTIONS-317,12414881,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Minor,Fixed,,sebb@apache.org,sebb@apache.org,16/Feb/09 16:18,09/Nov/14 14:31,07/Apr/19 20:37,28/Feb/13 20:04,,,,,,4.0,4.0-alpha1,,Map,,,,,,0,,,,"The constructor AbstractHashedMap(Map map) calls the public non-final method putAll() from the same class.

This is likely to cause problems if the method is ever overridden, as the parent may not have been completely initialised when the sub-class method is invoked. 

Possible solution: extract the code into a common private method. Or make the method final.

",,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2009-02-16 16:47:57.653,,,false,,,,,,,,,,,,,,18684,,,Wed May 20 04:30:21 UTC 2009,,,,,,0|i0si5z:,164420,,,,,,,,"16/Feb/09 16:47;mbenson;Another, albeit somewhat--different, option would be to expose the implementation detail of putAll() being called in the javadoc specification of the method.  Then a subclass implementor could simply choose to call a different super constructor if appropriate.","16/Feb/09 19:22;sebb@apache.org;That would be better than nothing, but I would prefer to make it impossible for the user to accidentally mess things up.","20/May/09 04:30;bayard;svn ci -m ""Refactoring putAll to _putAll so the constructor can call the copying in code without running through a subclass' implementation of putAll. Reported in COLLECTIONS-317"" src/

Sending        src/java/org/apache/commons/collections/map/AbstractHashedMap.java
Transmitting file data .
Committed revision 776542.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
LRUMap constructor javadoc and behavior are inconsistent (maxSize cannot be less than 0),COLLECTIONS-316,12414517,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Minor,Fixed,,os111,os111,10/Feb/09 21:55,09/Nov/14 14:31,07/Apr/19 20:37,28/Feb/13 20:04,3.1,,,,,4.0,4.0-alpha1,,Map,,,,,,0,,,,"The LRUMap constructor specifies ""@param maxSize  the maximum size of the map, -1 for no limit""

The first line is then:

        if (maxSize < 1) {
            throw new IllegalArgumentException(""LRUMap max size must be greater than 0"");
        }

There is nothing wrong with allowing a negative maxSize. This way the map can be used to order elements relative to access time. I think the above code should be remove and the javadoc should stay the same.",n/a,,,,60,60,,0%,60,60,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2009-05-20 04:22:33.823,,,false,,,,,,,,,,,,,,18685,,,Wed May 20 04:22:33 UTC 2009,,,,,,0|i0si67:,164421,,,,,,,,"20/May/09 04:22;bayard;Two of the javadocs say it will throw the exception. One of them is the one you quote.

The code before the exception tries to make maxSize be DEFAULT_CAPACITY, so the no limit part would also be wrong.

I've removed the ""-1 means no limit"" from the Javadoc in r776538.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
CollectionUtils.removeAll calls the wrong ListUtils method,COLLECTIONS-315,12413928,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Duplicate,,cheriot,cheriot,03/Feb/09 19:30,01/May/12 12:03,07/Apr/19 20:37,03/Feb/09 20:40,3.2,,,,,,,,Core,,,,,,0,,,,"Using version 3.2.1 as downloaded from maven's public repository.

CollectionUtils.removeAll should call ListUtils.removeAll instead of ListUtils.retainAll.

Currently
{{public static Collection removeAll(Collection collection, Collection remove) {
        return ListUtils.retainAll(collection, remove);
    }}}

Suggested
{{public static Collection removeAll(Collection collection, Collection remove) {
        return ListUtils.*removeAll*(collection, remove);
    }}}",,,,,,,,,,,,,,COLLECTIONS-219,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2012-05-01 12:03:19.396,,,false,,,,,,,,,,,,,,18686,,,Tue May 01 12:03:19 UTC 2012,,,,,,0|i0si6f:,164422,,,,,,,,"01/May/12 12:03;barisacar;Is there any plan for when this will be released? The latest version, 3.2.1, still contains this bug.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Modifications of a SetUniqueList.subList() invalidate the parent list,COLLECTIONS-310,12412112,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Minor,Fixed,,chsemrau,chsemrau,10/Jan/09 13:58,09/Nov/14 14:31,07/Apr/19 20:37,27/Apr/13 11:57,3.2,Nightly Builds,,,,4.0,4.0-alpha1,,List,,,,,,0,,,,"The List returned by SetUniqueList.subList() is again a SetUniqueList. The contract for List.subList() says that the returned list supports all the operations of the parent list, and it is backed by the parent list.

We have a SetUniqueList uniqueList equal to {""Hello"", ""World""}. We get a subList containing the last element. Now we add the element ""Hello"", contained in the uniqueList but not in the subList, to the subList.

What should happen?

Should the subList behave like a SetUniqueList and add the element - meaning that it changes position in the uniqueList because at the old place it gets removed, so now uniqueList equals {""World"", ""Hello""} (which fails)?
Or should the element not be added, because it is already contained in the parent list, thereby violating the SetUniqueList-ness of the subList (which fails)?
I prefer the former behaviour, because modifications should only be made through the subList and not through the parent list (as explained in List.subList()).

What should happen if we replace (using set) the subList element ""World"" with ""Hello"" instead of adding an element?

The subList should contain only ""Hello"", and for the parent list, the old element 0 (now a duplicate of the just set element 1) should be removed (which fails).

And of course the parent list should know what happens to it (specifically, its uniqueness Set) (which fails in the current snapshot).


	public void testSubListAddNew() {
		List uniqueList = SetUniqueList.decorate(new ArrayList());
		uniqueList.add(""Hello"");
		uniqueList.add(""World"");
		List subList = uniqueList.subList(1, 2);

		subList.add(""Goodbye"");

		List expectedSubList = Arrays.asList(new Object[] { ""World"", ""Goodbye"" });
		List expectedParentList = Arrays.asList(new Object[] { ""Hello"", ""World"", ""Goodbye"" });
		assertEquals(expectedSubList, subList);
		assertEquals(expectedParentList, uniqueList);
		assertTrue(uniqueList.contains(""Goodbye"")); // fails
	}

	public void testSubListAddDuplicate() {
		List uniqueList = SetUniqueList.decorate(new ArrayList());
		uniqueList.add(""Hello"");
		uniqueList.add(""World"");
		List subList = uniqueList.subList(1, 2);

		subList.add(""Hello"");

		List expectedSubList = Arrays.asList(new Object[] { ""World"", ""Hello"" });
		List expectedParentList = Arrays.asList(new Object[] { ""World"", ""Hello"" });
		assertEquals(expectedSubList, subList);
		assertEquals(expectedParentList, uniqueList); // fails
	}

	public void testSubListSetDuplicate() {
		List uniqueList = SetUniqueList.decorate(new ArrayList());
		uniqueList.add(""Hello"");
		uniqueList.add(""World"");
		List subList = uniqueList.subList(1, 2);

		subList.set(0, ""Hello"");

		List expectedSubList = Arrays.asList(new Object[] { ""Hello"" });
		List expectedParentList = Arrays.asList(new Object[] { ""Hello"" });
		assertEquals(expectedSubList, subList);
		assertEquals(expectedParentList, uniqueList); // fails
	}
",,,,,,,,,,,,,,,,COLLECTIONS-444,,,18/Feb/13 20:34;t.vahrst;SetUniqueList.java;https://issues.apache.org/jira/secure/attachment/12569854/SetUniqueList.java,18/Feb/13 20:34;t.vahrst;SetUniqueList.patch;https://issues.apache.org/jira/secure/attachment/12569853/SetUniqueList.patch,04/Mar/13 20:35;t.vahrst;SetUniqueList.v2.java;https://issues.apache.org/jira/secure/attachment/12571946/SetUniqueList.v2.java,04/Mar/13 20:35;t.vahrst;SetUniqueListTest.java;https://issues.apache.org/jira/secure/attachment/12571947/SetUniqueListTest.java,18/Feb/13 20:34;t.vahrst;SetUniqueListTest.java;https://issues.apache.org/jira/secure/attachment/12569855/SetUniqueListTest.java,,,,,5.0,,,,,,,,,,,,,,,,,,,2013-01-26 16:30:52.659,,,false,,,,,,,,,,,,,,18691,,,Sat Apr 27 11:57:35 UTC 2013,,,,,,0|i0fth3:,90373,,,,,,,,"10/Jan/09 20:25;chsemrau;It seems that properties of the SetUniqueList.subList are currently not tested: The bulk tests for TestSetUniqueList are disabled.

I managed to enable them by using a copy of BulkTestSubList which is subclassed from TestSetUniqueList instead of AbstractTestList, and which disables extraVerify for itself and the outer test. For the bulkTestListIterator, TestListIterator.supportsSet() must return false (but then still one test fails).

But maybe this should be subject of a different jira issue.
","26/Jan/13 16:30;t.vahrst;As already stated in the javadoc of SetUniqueList, this class does not adhere to the api contract of java.util.List. The class name as well as the implemented interface (java.util.List) implies the behavior of a List, but that is not true. Several methods violate the List contract and state this in its javadocs. 

Furthermore: some javadocs are not clear enough about the contract violation. For example the javadoc of the 'add()' method states a 'violation' of the api because the method may return 'false'. But this method also violates the java.util.List *semantics*, because the specified element is not only added, an other element is possibly removed during the invocation. 

Imagine a generic sort algorithm for lists, which internal moves elements in the list by *first* adding the element at the new position and then removing the element at the old position. This algorithm would probably remove most of the elements in the list... (Btw: this test fails with an UnsupportedOperationException:
{code}
  List<String> list = new ArrayList<String>();
  list.addAll( Arrays.asList(""one"", ""two"", ""three"", ""four"", ""five"", ""six"", ""seven"", ""eight"", ""nine"", ""ten""));
  SetUniqueList<String> uniquelist = SetUniqueList.setUniqueList(list);

  Collections.sort(uniquelist);

{code}

In my opinion this jira issue concerning the subList() behavior cannot be solved in a way that makes the behavior expectable for the user. So instead of providing an implementation which may work in most cases but sometimes fails and describing this strange behavior (it took some time to understand the issue...) in the method's javadoc, I would suggest to throw an UnsupportedOperationException.

I personally would consider removing the whole class. Many developers use the apache commons classes as code reference for their own concrete coding problems and SetUniqueList isn't a good example of the decorator pattern - as stated above. (And in addition violates the liskov substitution principle). The better solution is already described in SetUniqueList's javadoc:

{code}
 * The {@link org.apache.commons.collections.set.ListOrderedSet ListOrderedSet}
 * class provides an alternative approach, by wrapping an existing Set and
 * retaining insertion order in the iterator.
{code}

What do yout think? Any comments?","30/Jan/13 17:09;tn;Hi Thomas,

I agree in general with your observation, but I do not understand your statement 'because the specified element is not only added, an other element is possibly removed during the invocation'.

Looking at the add method, I fail to see how this may happen. The use-case you describe does explicitly call remove, so I wonder how this is related to the previous statement.

This class in general should be used with a lot of care, and only if you know exactly what you are doing, which is probably not very convincing either. I would prefer to keep the class for now, but improve the javadoc wrt the current limitations, which may never be fully resolved.","30/Jan/13 18:07;t.vahrst;Mmmh, I don't understand my own comment any more... Must have been tired. So you are right: the sorting example is nonsense, please ignore it. 

I agree to keep the class - I'll try to write some additions to the javadoc comment for the subList() method to clarify the behavior... ","02/Feb/13 12:47;t.vahrst;I took a deeper look on this issue and the suggested behavior/junit tests and tried to understand the problem(s). It seems, there a two issues with the current implementation regarding modifications of sublists:
# Modifications of sublist items are delegated to the underlying backing list (which is the default sublist implementation) but *not* to the internal set of the parent SetUniqueList.  So a new entry is added to the list, but the contains() method of the parent SetUniqueList returns false
# Modifications of the sublist may result in changes *outside* the range of the sublist. For example adding an element which is not in the sublist but somewhere in the backing list should result in *moving* the item from its current position to the new position defined by the subset. This move may corrupt the internal range offsets of the sublist. 

The first issue seems easy to solve, for example by holding a reference of the parent set in the subset. But if another subset is created based on the first subset, we have to maintain a collections of parent sets.

The second issue is similar to a direct modification of a backing list - which is not supported. The javadoc of sublist states
{quote}
The semantics of the list returned by this method become undefined if the backing list (i.e., this list) is structurally modified in any way other than via the returned list. (Structural modifications are those that change the size of this list, or otherwise perturb it in such a fashion that iterations in progress may yield incorrect results.)
{quote}

To solve this problem, the subList implementation has to track all modifications of the backing list and adjust it's internal range offsets accordingly. For example adding a duplicate item to a sublist, which exists  'in front' of the sublist will result 
- moving the item to the new sublist position 
- decrement the range offsets of the sublist. 

So first of all I wrote a short javadoc comment for the sublist method:
{code}
    /**
     * Returns a view of the portion of this list between the specified 
     * fromIndex, inclusive, and toIndex, exclusive.
     * <p>
     * <i>(Violation)</i> According to the <code>List</code> interface the returned
     * sublist has to be backed by the original list. Because a <code>SetUniqueList</code>
     * requires both a defined ordering of the list items <i>and</i> uniqueness of
     * all list items, modifications cannot garantee consistant behavior of both
     * the backing list and the sub list. It is strongly recommended not to modify
     * the sublist. 
     * <p>
     * 
     * @param fromIndex
     * @param toIndex
     * @return 
     */

{code}

Should we perhaps return the sublist as a UnmodifiableList?



","07/Feb/13 14:48;tn;Right now, when calling subList, a new, independent SetUniqueList is created which is filled with elements from the backing list of the specified range.

The problem comes from the fact that this new SetUniqueList does not check for uniqueness in the backing list, but only in the sublist. If we would create an inner class (see for example ListOrderedMap), which would delegate the calls (after properly adjusting some arguments, e.g. calculate real index) to the backing SeUniqueList we could support the sublist contract.

The order is maintained and the uniqueness is validated by the backing list.

What do you think?",17/Feb/13 20:39;t.vahrst;Many new testcases for sublists.,"17/Feb/13 20:51;t.vahrst;I am trying to create a sublist implementation which conforms to the required functions. The first attachement (SetUniqueListTest.patch) contains many new testcases for sublist, checking this functions. 

I implemented two possible solutions, more of that in the following posts (in the next days). During the coding I realized a further problem concerning ListIterator. ListIterator supports add/set/remove functionality, which means, that a ListIterator based on a sublist needs the corresponding sublist behavior. And ListIterator may start at a specified index, so this  means, that a ListIterator with index > 0 based on a SetUniqueList itself is a subList of the underlying SetUniqueList - with all the necessary behavior. 

So for the first iteration on this issue, I ommited these tests. I will provided them later...","18/Feb/13 20:36;t.vahrst;SetUniqueList.patch contains JUnit Tests and Variant No. 1 for SetUniqueList. I am not sure whether the patch has a correct format (I am not able to re-apply the patch in Netbeans...) so I attached the corresponding java files as well.

Some comment to this solution: 
1. During the implementation I recognized, that the existing implementation of subList() uses the subList() method on the decorated list and then creates a new Set and fills all elements of the sublist into the set. 

Now this issue requires, that a parent list has to be modified on certain invocations on a sublist - for example when adding an element to the sublist which exists in the parent list somewhere outside the range of the sublist. With the current sublist implementation, any attempt to modify a parent list fails with a ConcurrentModifiationException. So we have to reimplement the sublist functionality inside SetUniqueList and can not reuse the service of AbstractListDecorator.

2. When we create a subList on a SetUniqueList, this sublist has to obbey the SetUniqueList contracts. The original parent list will have slightly different behavior when adding or setting values. When we create a second sublist based on the first sublist, this top most list has to provide SetUniqueList semantics.

Example (from JUnit Tests)
{noformat} 
 subList2                    ! e ! f ! g !              offset = 2
 subList1            ! c ! d ! e ! f ! g ! h !          offset = 2
 list        ! a ! b ! c ! d ! e ! f ! g ! h ! i ! j !  offset = 0
             -----------------------------------------
 Index         0   1   2   3   4   5   6   7   8   9

 Adds a 'd' to subList2. This should move the 'd' in subList1 and list in the range of subList2
 Expected result:

 subList2                ! e ! f ! g ! d !              offset = 1
 subList1            ! c ! e ! f ! g ! d ! h !          offset = 2
 list        ! a ! b ! c ! e ! f ! g ! d ! h ! i ! j !  offset = 0
             -----------------------------------------
 Index         0   1   2   3   4   5   6   7   8   9
{noformat} 

(The 'movement' of 'd' causes the ConcurrentModificationException mentioned above.)

Because of this requirements I decided for Variant No. 1, that every SetUniqueList holds its own list and set and maintains a reference to it's parent SetUniqueList and an offset value. The SetUniqueList garantees, that all parent lists are updated according to the required functionality and that all offset values are adjusted if necessary. This solution does not use the sublist functionality of the decorated list but creates allway a new Set *and* List.

I copied the existing code for creating a new Set to also create a new List based on the existing list. 

At this time, there are two things missing:

# a very details javadoc comment for the subList() method, explaining the behavior.
# the implementation for listIterator(). 


... to be continued with variant no. 2 ...






",04/Mar/13 20:35;t.vahrst;2nd variant of modified SetUniqueList and even more Testcases für sublist.,"04/Mar/13 21:02;t.vahrst;SetUniqueListTest.java now contains some new testcases to test the behavior of listiterators of sublists. 

SetUniqueList.v2.java is the 2nd variant I implemented. In contrast to the first attempt, this class does not inherit from AbstractListDecorator but inherits from java.util.AbstractList. It holds a reference to a underlying list which is *shared* with all sublists. So every sublist holds the reference to the underlying list and maintains it's own set and a offset of its element range in the underlying list.

This variant contains support for iterators and listiterators on sublists.

I personally found this solution a bit more elegant than the first variant. 

","17/Mar/13 10:22;tn;Hi Thomas,

I have looked through both variants, but am still undecided.
Generally, I think we should keep the inheritance to AbstractSerializableListDecorator, as the class should remain a decorator. Adding more fields to the actual class also has the down-side that we need to make sure that serialization still works correctly, so I would prefer to create an inner static View class, which is returned when calling subList.

I will further play with your patch, and give you more feedback.

Thanks!","25/Apr/13 19:33;tn;I did take another look at your provided test-cases and I do not agree with the following behavior:

 * adding an element in a subList that is contained in the backing list results in moving the element to the new location

This is not what I would expect, and also the backing list does not do this, e.g. when calling add(obj) where obj is already contained in the list will result in no change at all. I think we should make it clear, that the returned subList is *backed* by a SetUniqueList, thus adding elements that are in the backing list but not in the subList should not be added at all, as they are already present, just not visible in this view.","26/Apr/13 16:14;t.vahrst;Hi Thomas,
Christian Semrau, who reported this issue, provides in the issue description two possible solutions to the inconsistency of sublist. In a nutshell:
When adding a value to a SubList and this value exists in the underlying SetUniqueList,
1. the subList behaves like a SetUniqueList and the existing value is *moved* to the new position - thus breaking the contract of the underlying SetUniqueList.
2. nothing happens because the value already exists - which means that the *sublist* does not behave like a SetUniqueList.

Christian preferred the first solution, so I implemented all JUnit tests (and the proposed changes of SetUniqueList) according to solution no. 1


If we decide to switch to solution no. 2, I would at first change all unit tests according to this solution. Ok?

btw: invoking set() method with a value that exists outside the sublist will move the value to the new position, right? And also: removing a value in a sublist which exists outside the sublist range will remove this value in the underlying SEtUnqiqueList?

(btw 2: did I allready mention that I am not happy at all with our attempt to solve a obviously inconsistent construct? Whether solution No. 1 or 2: I wonder how to write a good javadoc comment for sublist() which describes the behavior in a clear manner... The possibly most simple javadoc could read: ""This method returns a sublist which is umodifiable."" ;-)
","26/Apr/13 18:16;tn;Hi Thomas,

I did not mean to criticize your outstanding effort (and your choice was perfectly reasonable).
Maybe we should really do as you suggest and return an unmodifiable list for 4.0 to be on the safe side (although you put so much effort into this issue).

What do you think?","27/Apr/13 08:38;t.vahrst;Hi Thomas,
oops, I definitly do not feel criticized - I am sorry if my comment sounds this way. In fact this issue is a interesting programming challenge. Regardless of the efforts: I am convinced that SetUniqueList's 'mixture' of List API and Set behavior makes it very difficult to provide a simple, intuitive and consistent implementation of the sublist() method.

So I would appreciate the decision to let sublist() return an unmodifiable list. ","27/Apr/13 11:57;tn;Applied change in r1476557.

Thanks for all the effort so far!",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
CollectionUtils.transform fails when collection is HashMap$Values,COLLECTIONS-308,12411275,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Minor,Won't Fix,,lluismf,lluismf,23/Dec/08 23:32,24/Dec/08 14:19,07/Apr/19 20:37,24/Dec/08 14:19,3.2,,,,,,,,Collection,,,,,,0,,,,"I'm trying to apply a transformation to all values in a map :

		Collection values = map.values();
		CollectionUtils.transform(values, transformer);

Gives a java.lang.UnsupportedOperationException in CollectionUtils line 439.

According to Javadoc the method values of Hashmap ""does not support the add or addAll operations."".


",Ubuntu,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2008-12-24 00:47:31.154,,,false,,,,,,,,,,,,,,18693,,,Wed Dec 24 14:19:57 UTC 2008,,,,,,0|i0si7b:,164426,,,,,,,,"24/Dec/08 00:47;jwcarman;Do you need the transformation to be visible via the map?  Or, are you just looking to take the values from the map, transform them in some way, and then do something with them?  If so, then try:

Collection values = new HashSet(map.values());

and play around with that values collection.  Of course, you can use whatever type of collection you wish (LinkedList, ArrayList, TreeSet, etc.).","24/Dec/08 09:24;scolebourne;There is no way to 'fix' this in commons-collections - its the nature of transform() to alter the input collection.

The only change to make is to add some javadoc.","24/Dec/08 14:19;lluismf;I agree with Stephen's explanation, proceeding to close.
James: I need the map updated as well. I will iterate the keyset, get the value, transform and put.
Thanks for your comments.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"SetUniqueList.subList().contains() method checks against full parent list, not sublist range",COLLECTIONS-307,12408351,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Minor,Fixed,,chsemrau,chsemrau,12/Nov/08 16:59,08/Nov/15 21:12,07/Apr/19 20:37,28/Feb/13 20:03,3.2,,,,,3.2.2,4.0,4.0-alpha1,List,,,,,,0,,,,"The view returned by the subList() method of a SetUniqueList checks contains() against the set of the original list.

As shown by the following test snippet.

		List list = new ArrayList();
		List uniqueList = SetUniqueList.decorate(list);
		uniqueList.add(""Hello"");
		uniqueList.add(""World"");
		List subList = list.subList(0, 0);
		List subUniqueList = uniqueList.subList(0, 0);
		assertFalse(subList.contains(""World"")); // passes
		assertFalse(subUniqueList.contains(""World"")); // fails
",,,,,,,,,,,,,,,,,,,31/Dec/08 09:40;bayard;COLLECTIONS-307.patch;https://issues.apache.org/jira/secure/attachment/12396964/COLLECTIONS-307.patch,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2008-12-29 05:10:43.382,,,false,,,,,,,,,,,,,,18694,,,Mon Jan 05 09:10:18 UTC 2009,,,,,,0|i0si7j:,164427,,,,,,,,12/Nov/08 17:01;chsemrau;The same problem occurs with containsAll().,"29/Dec/08 05:10;bayard;Thanks for the report Christian. The bug is because the subList call doesn't create a new set to represent uniqueness but instead uses the parent list's set. Easy enough to fix if we hardcode the type of set. Harder to do if we want to use the same Set as originally passed in as there's no guaranteed cloning method.

Tempted to do a helper method of:

if instanceof Cloneable
  clone
else if empty Constructor
  construct and use addAll
else use defaultValue (ie: HashSet)","29/Dec/08 07:54;bayard;(Forgot how lame clone is in Java... so that becomes:

if empty Constructor
  create empty instance
else use HashSet
fill either case with addAll",31/Dec/08 09:40;bayard;Two tests and the suggested patch attached.,"05/Jan/09 09:10;bayard;svn ci -m ""Applying my patch from COLLECTIONS-307. Fixes the bug raised by Christian Semrau that SetUniqueList.subList() was not redefining the uniqueness set when creating the sublist. "" src

Sending        src/java/org/apache/commons/collections/list/SetUniqueList.java
Sending        src/test/org/apache/commons/collections/list/TestSetUniqueList.java
Transmitting file data ..
Committed revision 731498.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
SetUniqueList set method use corrupts uniqness,COLLECTIONS-304,12403741,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,raffig,raffig,05/Sep/08 10:43,08/Nov/15 21:27,07/Apr/19 20:37,28/Feb/13 19:38,3.2,,,,,3.2.2,4.0,4.0-alpha1,,,,,,,0,,,,"When set method is used to put element (Strawberry) on list, then it is possible to add the same element (Strawberry) with add method. Also you cannot add element (Lemon) that has been once removed with set method. Reproduction code below:


List<String> list = new LinkedList<String>();
SetUniqueList decoratedList = SetUniqueList.decorate(list);

decoratedList.add(""Apple"");
decoratedList.add(""Lemon"");
decoratedList.add(""Orange"");

System.out.println(decoratedList.toString());

decoratedList.set(1, ""Strawberry"");

System.out.println(decoratedList.toString());

decoratedList.add(1, ""Strawberry"");

System.out.println(decoratedList.toString());

decoratedList.add(1, ""Lemon"");

System.out.println(decoratedList.toString());
",JDK 1.6/Windows/Eclipse Ganymede,,,,,,,,,,,,,,,,,,05/Nov/08 03:56;bayard;COLLECTIONS-304.patch;https://issues.apache.org/jira/secure/attachment/12393351/COLLECTIONS-304.patch,04/Nov/08 00:23;bjorn;Commons-304-test.diff;https://issues.apache.org/jira/secure/attachment/12393274/Commons-304-test.diff,,,,,,,,2.0,,,,,,,,,,,,,,,,,,,2008-11-04 00:23:28.891,,,false,,,,,,,,,,,,,,18697,,,Wed Nov 05 15:48:03 UTC 2008,,,,,,0|i0si7z:,164429,,,,,,,,04/Nov/08 00:23;bjorn;Here's a JUnit test reproducing this. Nice catch. :),"05/Nov/08 03:56;bayard;Adding a fix for this issue, with a slight tweak on Bjorn's unit test. ","05/Nov/08 15:48;bayard;svn ci -m ""Applying Bjorn Townsend's unit test and my fix for COLLECTIONS-304 - fixing SetUniqueList so the set method doesn't let the uniqueness get out of sync""
Sending        src/java/org/apache/commons/collections/list/SetUniqueList.java
Sending        src/test/org/apache/commons/collections/list/TestSetUniqueList.java
Transmitting file data ..
Committed revision 711591.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
ExtendedProperties.convertProperties loses non-String values,COLLECTIONS-299,12398319,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,skitching,skitching,16/Jun/08 11:13,27/Nov/15 21:11,07/Apr/19 20:37,28/Feb/13 19:37,,,,,,,,,Core,,,,,,0,,,,"A Properties object normally has Strings as its values. But it does partially support non-String-typed values via the raw put and get methods inherited from Hashtable. And other Properties methods are aware that the value might not be a String; see documentation for methods propertyNames() and stringPropertyNames() for example.

ExtendedProperties.convertProperties does this:
{code}
for (Enumeration e = props.propertyNames(); e.hasMoreElements();) {
      String s = (String) e.nextElement();
      c.setProperty(s, props.getProperty(s));
}
{code}

Properties.propertyNames() returns the names of all keys in the set, regardless of the associated value's type. But Properties.getProperty(key) returns null if the value type is not a String. The call to c.setProperty invokes setPropertyInternal, which can pass this null value to Hashtable.put, which then throws a NullPointerException.

It's rather puzzling to have a valid (string-key, non-string-value) entry in the Properties object and get a NullPointerException.

Perhaps the call
  props.getProperty(s)
can be changed to
  props.get(s)

Alternately, at least documenting that this method does not support non-string values in the input Properties object would be useful.
",,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2008-06-16 11:46:34.754,,,false,,,,,,,,,,,,,,18702,,,Tue Apr 23 18:57:38 UTC 2013,,,,,,0|i0si93:,164434,,,,,,,,16/Jun/08 11:46;sebb@apache.org;Add code markers to stop reformatting of code section - and conversion of ;\) to ;),04/Nov/08 00:10;bayard;Interestingly this mimics the same issue in java.util.Properties. If you pass a value into its Properties(Properties) constructor then any non-String values are lost. I think the javadoc route is probably best here - especially as the getProperty to get change makes tests fail.,"04/Nov/08 00:16;bayard;I added null-protection to stop the NPE.

svn ci -m ""Adding a test for COLLECTIONS-299 and a fix. Fixes by not adding any non-String values as per java.util.Properties; also adding to the javadoc"" src

Sending        src/java/org/apache/commons/collections/ExtendedProperties.java
Sending        src/test/org/apache/commons/collections/TestExtendedProperties.java
Transmitting file data ..
Committed revision 711140.","23/Apr/13 18:57;tn;Obsolete fix as class ExtendedProperties has been removed.
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Fix case-insensitive string handling,COLLECTIONS-294,12394809,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,bentmann,bentmann,25/Apr/08 14:31,07/Nov/15 21:17,07/Apr/19 20:37,28/Feb/13 19:38,3.2,,,,,3.2.2,4.0,4.0-alpha1,Map,,,,,,0,,,,"For example, the behavior of the {{CaseInsensitiveMap}} is currently platform-dependent, please see [Common Bug #3|http://www.nabble.com/Re%3A-Common-Bugs-p14931921s177.html] for details.",,,,,,,,,,,,,,,,,,,11/May/08 09:30;bentmann;COLLECTIONS-294-CaseInsensitiveMap.patch;https://issues.apache.org/jira/secure/attachment/12381836/COLLECTIONS-294-CaseInsensitiveMap.patch,25/Apr/08 14:31;bentmann;COLLECTIONS-294.patch;https://issues.apache.org/jira/secure/attachment/12380945/COLLECTIONS-294.patch,,,,,,,,2.0,,,,,,,,,,,,,,,,,,,2008-05-10 22:46:01.245,,,false,,,,,,,,,,,,,,18707,,,Mon Feb 16 16:39:07 UTC 2009,,,,,,0|i0si9z:,164438,,,,,,,,"10/May/08 22:46;bayard;Definitely for the ExtendedProperties, it's obviously using English as a Locale.

I'm less convinced by CaseInsensitiveMap. Instead it seems that either:

a) It should have a Locale parameter to the constructor
b) It should be rewritten to be a CaseInsensitiveMap [ie: depend on equalsIgnoreCase], and not a ToLowerCaseMap as it currently is.","11/May/08 09:30;bentmann;Yes, you're right, the map thing is trickier than I realized. Attached is a new patch that makes key comparisons behave as {{equalsIgnoreCase()}} would do (watch out for the extended unit test that fails when using {{String.toLowerCase()}} in {{convertKey()}}).

A question that pops up is whether {{CaseInsensitiveMap}} should have been case-preserving for keys, i.e. store keys in their original case but compare case-insensitively. I mean, there seem to be two different use cases involved here:
# case-insentive key lookup, i.e. {{map.get(""key"") == map.get(""KEY"")}} but possibly {{map.keySet().contains(""Key"")}}
# automatic key normalization to lower/upper case to provide a specific key set view
",01/Jul/08 04:48;bayard;Note: ExtendedProperties patch applied (r655204). I typo'd the key in the comment so it doesn't appear here.,"04/Nov/08 03:58;bayard;svn ci -m ""Applying Benjamin Bentmann's second patch from COLLECTIONS-294, fixing the locale issue in CaseInsensitiveMap by converting each character individually and not using toLowerCase"" src

Sending        src/java/org/apache/commons/collections/map/CaseInsensitiveMap.java
Sending        src/test/org/apache/commons/collections/map/TestCaseInsensitiveMap.java
Transmitting file data ..
Committed revision 711168.","16/Feb/09 16:39;sebb@apache.org;Unfortunately, Locale(String) is Java 1.4+ only, and Collections still targets 1.3.

Replaced with Locale(""tr"","""","""") - which is what Java 1.4 does anyway

URL: http://svn.apache.org/viewvc?rev=744957&view=rev
Log:
COLLECTIONS-294: Replace Locale(""tr"") with Locale(""tr"","""","""") to be Java 1.3 compliant",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Javadoc: incorrect behavior explained for ListUtils.transformedList,COLLECTIONS-288,12391638,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,pbenedict,pbenedict,17/Mar/08 16:34,09/Nov/14 14:31,07/Apr/19 20:37,28/Feb/13 19:38,,,,,,4.0,4.0-alpha1,,List,,,,,,0,,,,"The contract stated for ListUtils.transformedList is wrong. The list is not transformed -- it decorates the existing list and transforms NEW objects -- EXISTING objects are not transformed. 

Compare this to the javadoc found in MapUtils.transformedMap:
""This method returns a new map (decorating the specified map) that will transform any new entries added to it. Existing entries in the specified map will not be transformed. ""

That little missing piece of information messed me up. Just replace ""map"" with ""list"" and append it to the existing LilstUtils javadoc.",,,,,,,,,,,,,,,,COLLECTIONS-348,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2008-03-18 06:10:03.995,,,false,,,,,,,,,,,,,,18712,,,Tue Mar 18 06:10:03 UTC 2008,,,,,,0|i0siav:,164442,,,,,,,,"18/Mar/08 06:10;bayard;svn ci -m ""Stressing that existing objects are not transformed as per Paul's request in COLLECTIONS-288"" src/java/org/apache/commons/collections/ListUtils.java 

Sending        src/java/org/apache/commons/collections/ListUtils.java
Transmitting file data .
Committed revision 638227.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
CollectionUtils.removeAll() calls ListUtils.retainAll(),COLLECTIONS-284,12387501,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Duplicate,,cdeal,cdeal,30/Jan/08 21:01,05/Feb/08 05:47,07/Apr/19 20:37,05/Feb/08 05:47,3.2,,,,,,,,,,,,,,0,,,,"CollectionUtils.removeAll() calls ListUtils.retainAll().  I believe it should actually be 

public static Collection removeAll(Collection collection, Collection remove) {
        return ListUtils.removeAll(collection, remove);
}
",,,,,,,,,,,,,,COLLECTIONS-219,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2008-02-05 05:47:36.85,,,false,,,,,,,,,,,,,,18716,,,Tue Feb 05 05:47:36 UTC 2008,,,,,,0|i0sibj:,164445,,,,,,,,"05/Feb/08 05:47;bayard;Thanks Chuck, this is already fixed in trunk (COLLECTIONS-219).",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
LRUMap: moveToMRU is not invoked for new entry,COLLECTIONS-279,12383383,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Blocker,Duplicate,,someone,someone,28/Nov/07 07:12,27/Nov/15 21:47,07/Apr/19 20:37,28/Feb/13 19:29,3.2,,,,,,,,Map,,,,,,2,,,,"
	@Test
	public void testFirst() {
		LRUMap map = new LRUMap();

		String key = ""key1"";
		String value = ""value1"";

		map.put(key, value);
		Assert.assertEquals(map.get(key), value);
		Assert.assertEquals(map.get(map.firstKey()), value);
		
		key = ""key2"";
		value = ""value2"";
		map.put(key, value);
		// here it fails
		Assert.assertEquals(map.get(map.firstKey()), value);
	}
",,,,,,,,,,,,,,COLLECTIONS-262,,,,,28/Dec/07 13:33;cc_benny;AbstractLinkedMap.java.diff;https://issues.apache.org/jira/secure/attachment/12372293/AbstractLinkedMap.java.diff,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2007-12-28 13:29:59.908,,,false,,,,,,,,,,,,,,18721,,,Sun Mar 16 01:15:33 UTC 2008,,,,,,0|i0sicf:,164449,,,,,,,,"28/Dec/07 13:29;cc_benny;It seems to me that the implementations of
AbstractLinkedMap.firstKey and AbstractLinkedMap.lastKey are
switched.

AbstractLinkedMap.addEntry adds new entries at header.before, so
firstKey should look there for the last entry that was added, not
in header.after.

When I switch the implementations of firstKey and lastKey,
AjaxStateManager from the RichFaces project works (see
<http://jira.jboss.org/jira/browse/RF-1460>).

Of course I don't know if any users of firstKey/lastKey use them
according to the current implementation instead of by the docs.",02/Jan/08 15:51;liujf2k;The fix of COLLECTIONS-262 just switches firstKey() and lastKey()'s Java Doc,"16/Mar/08 01:15;bayard;As Jifeng points out - we're going with the javadoc being in error rather than the implementation. 

getFirstKey returns the first one to be added etc.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
put() and putAll() don't update the getKeys() map,COLLECTIONS-278,12382455,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,henning,henning,13/Nov/07 21:24,27/Nov/15 21:11,07/Apr/19 20:37,28/Feb/13 20:05,3.2,,,,,,,,,,,,,,0,,,,"If you use the put() or putAll() methods of the ExtendedProperties class, it will  not update the contents of the internal keysAsListed map which in turn will return a different list of keys using the getKeys() method than the keySet() method does.

The attached patchs fix this behaviour and add test cases. ",,,,,,,,,,,,,,,,,,,03/Jan/08 04:12;bayard;COLLECTIONS-278.patch;https://issues.apache.org/jira/secure/attachment/12372439/COLLECTIONS-278.patch,03/Jan/08 03:49;bayard;COLLECTIONS-278.patch;https://issues.apache.org/jira/secure/attachment/12372437/COLLECTIONS-278.patch,13/Nov/07 21:25;henning;putall-test-patch;https://issues.apache.org/jira/secure/attachment/12369450/putall-test-patch,13/Nov/07 21:25;henning;putall.patch;https://issues.apache.org/jira/secure/attachment/12369449/putall.patch,,,,,,4.0,,,,,,,,,,,,,,,,,,,2008-01-03 03:49:18.5,,,false,,,,,,,,,,,,,,18722,,,Mon Apr 22 19:47:21 UTC 2013,,,,,,0|i0sicn:,164450,,,,,,,,"03/Jan/08 03:49;bayard;Henning's patch had a lot of whitespace diffs, so here's a version without those changes.","03/Jan/08 04:12;bayard;Henning's patch looks good. I've added javadoc in one last patch, and I've implemented remove(Object);Object as well because it appears to me that this is another area for the same type of bug. ","15/Mar/08 23:22;bayard; svn ci -m ""Applying the latest patch from Henning's report in COLLECTIONS-278 that put() and putAll() don't update the getKeys() map on ExtendedProperties"" src

Sending        src/java/org/apache/commons/collections/ExtendedProperties.java
Sending        src/test/org/apache/commons/collections/TestExtendedProperties.java
Transmitting file data ..
Committed revision 637489.",22/Apr/13 19:47;tn;Obsolete fix as the class has been removed.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
org.apache.commons.collections.ExtendedProperties#combine don't import string properly,COLLECTIONS-271,12380528,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,partizan,partizan,16/Oct/07 12:40,27/Nov/15 21:11,07/Apr/19 20:37,28/Feb/13 19:56,3.2,,,,,,,,Collection,,,,,,1,,,,"When we set property with escaped characters, after combine propertySets we got them unescaped.

Simple Example

ExtendedProperties props = new ExtendedProperties();
props.setProperty(""test"", ""\\\\\\\\192.168.1.91\\\\test"");
props.getProperty(""test""); // => \\192.168.1.91\test

ExtendedProperties props2 = new ExtendedProperties();
props2.combine(props);
props.getProperty(""test""); // => \192.168.1.91\test -- Wrong!",,,,,,,,,,,,,,,,,,,21/Oct/08 17:39;nbubna;COLLECTIONS-271.patch;https://issues.apache.org/jira/secure/attachment/12392590/COLLECTIONS-271.patch,16/Mar/08 01:37;bayard;COLLECTIONS-271.patch;https://issues.apache.org/jira/secure/attachment/12377984/COLLECTIONS-271.patch,16/Oct/07 12:47;partizan;fix.patch;https://issues.apache.org/jira/secure/attachment/12367814/fix.patch,,,,,,,3.0,,,,,,,,,,,,,,,,,,,2008-03-16 01:33:22.987,,,false,,,,,,,,,,,,,,18729,,,Mon Apr 22 19:45:05 UTC 2013,,,,,,0|i0sidr:,164455,,,,,,,,16/Oct/07 12:47;partizan;Possible fix attached,16/Mar/08 01:33;bayard;Bug confirmed - but the fix doesn't pass the unit test so might need something more.,16/Mar/08 01:37;bayard;Unit test and fix attached. Needed to make it super.put and not put in the fix.,"16/Mar/08 01:38;bayard;svn ci -m ""Applying the patch from Alexander Borovsky for COLLECTIONS-271"" src
Sending        src/java/org/apache/commons/collections/ExtendedProperties.java
Sending        src/test/org/apache/commons/collections/TestExtendedProperties.java
Transmitting file data ..
Committed revision 637503.","06/Sep/08 01:14;nbubna;I think your patch for this breaks getKeys() after a combine() call.  It appears to make combine() not track new keys, which breaks both getKeys() and subset().  Because combine() then subset() is broken, Velocity has been experiencing frustratingly mysterious failures for months now.  For more on the symptoms, see:

http://tinyurl.com/5hjxrq

I suspect instead of super.put(), the patch for this should have used clearProperty() followed by addPropertyDirect().  Of course, i haven't tested that...",21/Oct/08 17:39;nbubna;here's a patch that fixes the previous bad patch so that subset() works again.,21/Oct/08 17:45;jwcarman;Is there a test case that shows that subset() is broken as a result of the previously-applied patch?,21/Oct/08 18:02;nbubna;Yep.  That's the first part of the patch i just attached.,"03/Nov/08 22:41;bayard;svn ci -m ""Applying Nathan Bubna's patch from COLLECTIONS-271 to fix the bug introduced in the last patch where getKeys() breaks after a combine() or subset() call. "" src

Sending        src/java/org/apache/commons/collections/ExtendedProperties.java
Sending        src/test/org/apache/commons/collections/TestExtendedProperties.java
Transmitting file data ..
Committed revision 710200.",22/Apr/13 19:45;tn;Obsolete fix as the class has been removed.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Issue with MultiKey when serialized/deserialized via RMI,COLLECTIONS-266,12378004,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Minor,Fixed,,jburet,jburet,11/Sep/07 21:02,07/Nov/15 20:54,07/Apr/19 20:37,28/Feb/13 19:57,3.2,,,,,3.2.2,4.0,4.0-alpha1,KeyValue,,,,,,0,,,,"This is because the hash code of MultiKey is calculated only once. 

So if the MultiKey is deserialized in an other jvm, and if one at least of the subkeys defines its hash code with System.identityHashCode() (for example all the enums does), then the hash code of the MultiKey is no longer valid, and you can't retreive the key in your Map.

I fixed it by making the cached hash code field transient, and by recalculating the hash code during deserialization. ",,,,,,,,,,,,,,,,COLLECTIONS-576,,,13/May/08 11:01;joehni;CC-266-final.patch;https://issues.apache.org/jira/secure/attachment/12381946/CC-266-final.patch,12/Sep/07 17:21;bayard;COLLECTIONS-266.patch;https://issues.apache.org/jira/secure/attachment/12365649/COLLECTIONS-266.patch,11/Sep/07 21:04;jburet;MultiKey.java;https://issues.apache.org/jira/secure/attachment/12365597/MultiKey.java,13/Sep/07 23:16;bayard;TestCollections266.java;https://issues.apache.org/jira/secure/attachment/12365781/TestCollections266.java,13/Sep/07 07:56;jburet;TestCollections266.java;https://issues.apache.org/jira/secure/attachment/12365700/TestCollections266.java,12/Sep/07 23:44;bayard;TestCollections266.java;https://issues.apache.org/jira/secure/attachment/12365680/TestCollections266.java,19/Sep/07 08:10;joehni;collections-testcase-266.diff;https://issues.apache.org/jira/secure/attachment/12366160/collections-testcase-266.diff,,,7.0,,,,,,,,,,,,,,,,,,,2007-09-12 17:21:09.106,,,false,,,,,,,,,,,,,,18734,,,Fri May 30 06:24:13 UTC 2008,,,,,,0|i0sien:,164459,,,,,,,,"11/Sep/07 21:04;jburet;Here is the updated source file.
Hope this help.",12/Sep/07 17:21;bayard;Julien's fix as a patch.,12/Sep/07 17:24;bayard;The patch seems good to me. Need to make a unit test and then apply.,"12/Sep/07 23:44;bayard;While creating the test I realized that the use case that found this problem seems quite rare.

* MultiKey goes into Map. 
* Map gets sent through serialize/deserialize. 
* We have a new map, with a new multikey inside, with a new object inside that, and the multikey has based its hashCode on the old address of the object and not the new one.

If you dig that object out of the map, and then use it to try and get itself back out of the map; then you've got a problem. So definitely a bug of sorts.

But how did you get access to the object in the first place? :)

In my unit test, I transfer the Map, then have to get the key back out of the map to then use in a get request. ie:

        MultiKey mk2 = (MultiKey) map2.keySet().iterator().next();
        assertEquals(TWO, map2.get(mk2));

I find that the test passes for both the old code and your new code. Any idea what I'm doing differently?",12/Sep/07 23:44;bayard;Attaching the unit test.,"13/Sep/07 07:56;jburet;I have updated the test and now it fails before the patch and is successful after.

In the test, the hash code of KEY_266 depends of the current (simulated) JVM (like System.identityHashCode() ).  

HTH","13/Sep/07 23:15;bayard;Thanks Julien.

Digging into it, I was a bit confused by the isJVM1 flag as it makes both the deserialized object and the TEST_266 object have the same hashCode. Then I realized that's probably how enums work, so fits your use case above.

I think this is a special case of a bigger and simpler unit test that uses the natural hashCode of the object (ie: same as System.identityHashCode). The current patch fails for that unit test. I'll attach the test for your thoughts.","14/Sep/07 06:14;joehni;IMHO the key simply violates the contract. Extract from Javadoc to Object.hashCode:

- If two objects are equal according to the equals(Object)  method, then calling the hashCode method on each of the two objects must produce the same integer result

It also states:

- Whenever it is invoked on the same object more than once during an execution of a Java application, the hashCode method must consistently return the same integer, provided no information used in equals comparisons on the object is modified. This integer need not remain consistent from one execution of an application to another execution of the same application.

Without testing it, but if you use this key not as part of a MultiKey, but of a HashMap directly, you might get the same results.","14/Sep/07 07:20;jburet;For Joerg: Here is the code of equals() and hashCode() methods of class Enum in the sun 1.5 jvm:

  
    public final boolean equals(Object other) { 
        return this==other;
    }

    public final int hashCode() {
        return System.identityHashCode(this);
    }

I think (and I hope ;) ) that the class Enum does not violate the hashCode contract - but you can see that the same enum will not have the same hashCode in two different jvms. The conclusion is : never serialize the hashCode (at least for a  modular class like MultiKey).

 And the HashMap will work fine in this case, because in its writeObject() and readObject() methods, the hashCode of each key is not serialized/deserialized: only the key, the value and the size of the map are serialized: It works, I have tested it.

Sorry for the multiple edits, but what I would like is to underline this sentence of the hashCode contract :  ""This integer need not remain consistent from one execution of an application to another execution of the same application.""
   ","14/Sep/07 08:51;joehni;Well, this problem with Enums has a history:

- http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6421053
- http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6373406

However, in the end you're right and the hashCode should not have been stored in the MultiKey in this way. We might solve this by adding a readResolve method:

  private Object readResolve() {
      return new MultiKey(keys, false);
  }

that way we create a new MultiKey with the correct hashCode. Your solution with the transient member will break the serialization compatibility, since you changed the binary layout. Therefore the hashCode member *must* be serialized - otherwise you have to change also the serialVersionUID. But with a private calculateHashCode method and setting the hashCode member not to final, we can implement readResolve different:

  private Object readResolve() {
      calculateHashCode();
      return this;
  }

But our clirr report may still choke about the final.

- Jörg","14/Sep/07 09:49;jburet;If the final modifier is a problem, an other solution could be to add a transient field ""hashCode2"" and no longer use the old field ""hashCode "" in the class (just keep it for compatibility). 

There is no mention of the final keyword in the serialization spec about compatible or incompatible changes:

http://java.sun.com/javase/6/docs/platform/serialization/spec/version.html#5172 ","14/Sep/07 09:57;joehni;Ah, well, the ""final"" modifier was meant as problem for binary compatibility itself, not for binary serialization compatibility ;-)","14/Sep/07 10:12;jburet;Ah ok ;) Well then it should be ok: 

http://java.sun.com/docs/books/jls/second_edition/html/binaryComp.doc.html#45154","17/Sep/07 08:30;scolebourne;Serialization is actually quite clever. You can change a field to transient, and keep the same serialVersionUID without a problem IIRC. And in this case, it doesn't matter if the serialVersionUID is changed, as the current code is broken.","18/Sep/07 18:56;bayard;So... summarizing:

* We want it to remain broken for normal natural hashCodes, as not keeping those in line with the spec is broken.
* We want to fix it for enums though, as they are special - and Julien's test case is good there because it models the specialness with the isJVM1 flag.
* Use Julien's fix because the move to transient doesn't break compat. 

Stephen/Joerg???",19/Sep/07 08:10;joehni;Patch to improve test case by simulating Enum behaviour.,"19/Sep/07 08:21;joehni;1/ You cannot fix natural hash codes in general. It works for Enums since they use always the same instance in the same VM.
2/ I've added a test case that does something similar ... I missed Julian's TC, but yes, that test would be sufficient also
3/ I had complaints against adding the ""transient"". I can run the TestAllPackages suite though and I assume (although I did not find where) that it also contains compatibility tests for serialization, since there are such objects in the data/test directory. This would prove Stephen's comment right that Java serialization can deal with the situation  - at least in one direction. But I doubt it will work in the other direction i.e. an old version of CC can read such a serialized object. Therefore I'd simply remove the final. And IMHO it matters if the serialVersionUID changes, since the current code is only broken for a special use case ;-)",13/May/08 07:22;bayard;Joerg - do you remember enough of this issue to put together a patch for your alternative fix?,13/May/08 11:01;joehni;I've added a new patch that combines all changes for the main source and the test case.,"30/May/08 06:24;bayard; svn ci -m ""Applying Joerg's final patch from COLLECTIONS-266, including the unit test that shows the problem and fixes the problem by making the hashcode transient, and moving the hashcode implementation such that it can be called from the deserialization as well as the hashcode method"" src

Sending        src/java/org/apache/commons/collections/keyvalue/MultiKey.java
Sending        src/test/org/apache/commons/collections/keyvalue/TestMultiKey.java
Transmitting file data ..
Committed revision 661577.",,,,,,,,,,,,,,,,,,,,,,,,,,,
"TreeBag allows uncomparable item to be added, breaking toString",COLLECTIONS-265,12377915,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Minor,Fixed,,dsaff,dsaff,10/Sep/07 19:38,09/Nov/14 14:31,07/Apr/19 20:37,28/Feb/13 20:04,3.2,,,,,4.0,4.0-alpha1,,Bag,,,,,,0,,,,"The following code throws an exception not when the Object is added, but when toString is called:

		TreeBag bag = new TreeBag();
		bag.add(new Object());
		bag.toString();

Trace:

java.lang.ClassCastException: java.lang.Object
	at java.util.TreeMap.compare(TreeMap.java:1093)
	at java.util.TreeMap.getEntry(TreeMap.java:347)
	at java.util.TreeMap.get(TreeMap.java:265)
	at org.apache.commons.collections.bag.AbstractMapBag.getCount(AbstractMapBag.java:116)
	at org.apache.commons.collections.bag.AbstractMapBag.toString(AbstractMapBag.java:581)
[...]

In a client program, toString should never throw an exception--it makes debugging much harder, for one thing.  I believe that TreeBag should defend against the addition of uncomparable objects, so that toString will never throw an exception.",,,,,,,,,,,,,,,,,,,17/Mar/08 04:06;bayard;COLLECTIONS-265.patch;https://issues.apache.org/jira/secure/attachment/12378017/COLLECTIONS-265.patch,08/Jan/08 22:41;hdiwan;TreeBag.pat;https://issues.apache.org/jira/secure/attachment/12372744/TreeBag.pat,,,,,,,,2.0,,,,,,,,,,,,,,,,,,,2007-09-11 13:35:34.747,,,false,,,,,,,,,,,,,,18735,,,Wed Mar 26 06:07:20 UTC 2008,,,,,,0|i0siev:,164460,,,,,,,,"11/Sep/07 13:35;bayard;Maybe the solution is to change the toString so it doesn't try to get the count of the object if not comparable.

How would that be?

Could just be ""Not a Comparable:java.lang.Object@47b480"" or something.","11/Sep/07 18:09;dsaff;It would prevent the exception, but I can think of two other possibilities that seem more orthogonal to existing functionality:

1) A java.util.TreeSet will hold a single uncomparable element, and treat it the same as a single comparable element, until a second element is added.  TreeBag could do the same.  
2) Or, TreeBag could gripe on add, just like both TreeBag and TreeSet do on the addition of a second incomparable object:

		TreeBag bag = new TreeBag();
		Object object = new Object();
		bag.add(object);
		bag.add(object);  // exception thrown here

","18/Sep/07 23:19;bayard;Sorry for the delay David.

For 2) doesn't seem like it would stop the exception - toString dies when one object is added, not two?

For 1), the idea is to have a TreeMap with the comparable data, and a single Object with the uncomparable? Then all methods would need to include the uncomparable object with the comparable when returning? ","19/Sep/07 13:32;dsaff;I prefer #2, but stated it poorly.  I would prefer if the first add of an uncomparable Object raised an exception.  The example code above is the current, somewhat odd behavior: add accepts the object the first time, but rejects it the second.  I think it should reject it the first time for consistency.

I agree that #1 is odd.  It is the de facto behavior of java.util.TreeSet: that's not terribly important to me, but if it is to the maintainers, TreeBag could follow the example.","20/Sep/07 17:59;scolebourne;I would prefer an ""instanceof Comparable"" check on each add().","08/Jan/08 22:41;hdiwan;adds the add method with the following semantics:

public boolean add(Object o) {
   if (o instanceof Comparable) {
      return super.add(o);
  }
  else return false;
}

can this be committed asap as well?","16/Mar/08 02:07;bayard;Returning false because the object was not comparable is not the contract agreed on in the javadoc: 

     * @return <code>true</code> if the object was not already in the <code>uniqueSet</code>

Stephen - were you implying an Exception be thrown? ie) TreeBag will not allow any class that is not Comparable?","16/Mar/08 10:38;scolebourne;Yes, an exception on add() makes most sense. However, if there is a Comparator then the instanceof check should not happen.","17/Mar/08 04:06;bayard;Attaching a test/patch for comments.

Throws an IllegalArgumentException if comparator() returns null and the object is not Comparable.","26/Mar/08 06:07;bayard;svn ci -m ""Applying my patch from COLLECTIONS-265. TreeBag no longer accepts non-Comparable classes when it naturally ordered (ie: no comparator has been set)"" src

Sending        src/java/org/apache/commons/collections/TreeBag.java
Sending        src/java/org/apache/commons/collections/bag/TreeBag.java
Sending        src/test/org/apache/commons/collections/TestTreeBag.java
Sending        src/test/org/apache/commons/collections/bag/TestTreeBag.java
Transmitting file data ....
Committed revision 641166.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
FastTreeMap forgets the comparator,COLLECTIONS-264,12377171,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,hergaty,hergaty,30/Aug/07 16:24,28/Feb/13 19:31,07/Apr/19 20:37,31/Aug/07 09:39,3.2,,,,,,,,Map,,,,,,0,,,,"In line 359 and 582 of the current 3.2 release you should replace
                map = new TreeMap()
with
                map = new TreeMap(map.comparator());

Otherwise the underlaying TreeMap looses ist comparator.",all,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2007-08-31 09:39:59.924,,,false,,,,,,,,,,,,,,18736,,,Fri Aug 31 09:39:59 UTC 2007,,,,,,0|i0sif3:,164461,,,,,,,,"31/Aug/07 09:39;bayard;svn ci -m ""Applying suggested fix from Thomas Louis in COLLECTIONS-264 - the clear() and CollectionView.clear() methods were losing the TreeMap's comparator"" src/

Sending        src/java/org/apache/commons/collections/FastTreeMap.java
Transmitting file data .
Committed revision 571412.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
probably apidoc error: firstKey() and lastKey() in AbstractLinkedMap,COLLECTIONS-262,12377055,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,immars,immars,29/Aug/07 04:10,09/Nov/14 14:31,07/Apr/19 20:37,28/Feb/13 19:28,3.2,,,,,4.0,4.0-alpha1,,Map,,,,,,0,,,,"In the apidoc or source of org.apache.commons.collections.map.AbstractLinkedMap.firstKey(), it is said that this method ""Gets the first key in the map, which is the most recently inserted."", which is exactly the actual behavior of lastKey(), and vice versa. 

So I think there is a typo with this class' javadoc.
",,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2008-01-02 07:23:52.733,,,false,,,,,,,,,,,,,,18738,,,Wed Jan 02 07:23:52 UTC 2008,,,,,,0|i0sifb:,164462,,,,,,,,"02/Jan/08 07:23;bayard;I agree (even wrote a quick test to make sure). I've committed the change to the javadoc.

svn ci -m ""Updating javadoc as per COLLECTIONS-262 - the firstKey and lastKey javadoc methods were back to front for parts of their description"" src/java/org/apache/commons/collections/map/AbstractLinkedMap.java

Sending        src/java/org/apache/commons/collections/map/AbstractLinkedMap.java
Transmitting file data .
Committed revision 608030.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Flat3Map.remove() does not return the correct value when size <= 3,COLLECTIONS-261,12376338,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,os111,os111,18/Aug/07 14:12,08/Nov/15 21:04,07/Apr/19 20:37,20/Aug/07 14:11,3.2,,,,,3.2.2,4.0,,Map,,,,,,0,,,,"        final Flat3Map m = new Flat3Map();
        m.put( new Integer( 1 ), new Integer( 1 ) );
        m.put( new Integer( 0 ), new Integer( 0 ) );
        System.out.println( m.remove( new Integer( 1 ) ) );

The above code will print ""0"" when it should print ""1""","Windows XP, SUN JDK 1.5.0_06",,,,,,,,,,,,,,,,,,20/Aug/07 14:11;bayard;COLLECTIONS-261.patch;https://issues.apache.org/jira/secure/attachment/12364150/COLLECTIONS-261.patch,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2007-08-20 14:11:11.309,,,false,,,,,,,,,,,,,,18739,,,Mon Aug 20 14:11:11 UTC 2007,,,,,,0|i0sifj:,164463,,,,,,,,20/Aug/07 14:11;bayard;Attaching unit test and fix. ,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
CollectionUtils.removeAll() calls ListUtils.retainAll(),COLLECTIONS-257,12372326,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Duplicate,,sjk,sjk,25/Jun/07 10:53,27/Apr/13 21:26,07/Apr/19 20:37,26/Jun/07 15:40,3.2,,,,,4.0,,,Collection,,,,,,0,,,,"    /**
     * Returns a collection containing all the elements in <code>collection</code>
     * that are also in <code>retain</code>. The cardinality of an element <code>e</code>
     * in the returned collection is the same as the cardinality of <code>e</code>
     * in <code>collection</code> unless <code>retain</code> does not contain <code>e</code>, in which
     * case the cardinality is zero. This method is useful if you do not wish to modify
     * the collection <code>c</code> and thus cannot call <code>c.retainAll(retain);</code>.
     * 
     * @param collection  the collection whose contents are the target of the #retailAll operation
     * @param retain  the collection containing the elements to be retained in the returned collection
     * @return a <code>Collection</code> containing all the elements of <code>collection</code>
     * that occur at least once in <code>retain</code>.
     * @throws NullPointerException if either parameter is null
     * @since Commons Collections 3.2
     */
    public static Collection retainAll(Collection collection, Collection retain) {
        return ListUtils.retainAll(collection, retain);
    }

    /**
     * Removes the elements in <code>remove</code> from <code>collection</code>. That is, this
     * method returns a collection containing all the elements in <code>c</code>
     * that are not in <code>remove</code>. The cardinality of an element <code>e</code>
     * in the returned collection is the same as the cardinality of <code>e</code>
     * in <code>collection</code> unless <code>remove</code> contains <code>e</code>, in which
     * case the cardinality is zero. This method is useful if you do not wish to modify
     * the collection <code>c</code> and thus cannot call <code>collection.removeAll(remove);</code>.
     * 
     * @param collection  the collection from which items are removed (in the returned collection)
     * @param remove  the items to be removed from the returned <code>collection</code>
     * @return a <code>Collection</code> containing all the elements of <code>collection</code> except
     * any elements that also occur in <code>remove</code>.
     * @throws NullPointerException if either parameter is null
     * @since Commons Collections 3.2
     */
    public static Collection removeAll(Collection collection, Collection remove) {
        return ListUtils.retainAll(collection, remove);
    }


I guess the later method shoud be:
    public static Collection removeAll(Collection collection, Collection remove) {
        return ListUtils.removeAll(collection, remove);
    }
",,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2007-06-26 15:40:18.684,,,false,,,,,,,,,,,,,,18743,,,Tue Jun 26 15:40:18 UTC 2007,,,,,,0|i0sig7:,164466,,,,,,,,"26/Jun/07 15:40;bayard;Duplicate of COLLECTIONS-219, which has been fixed in trunk. ",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"ListUtils.transformedList(list, transformer) doesn't transform",COLLECTIONS-256,12371294,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Duplicate,,cardsharp,cardsharp,08/Jun/07 22:43,09/Nov/14 14:31,07/Apr/19 20:37,27/Apr/13 21:42,3.2,,,,,4.0,4.0-alpha1,,List,,,,,,0,,,,"The static method ListUtils.transformedList(List list, Transformer trans) does not apply the transformer before returning the list.  I've traced into the code and it falls all the way through to the TransformedCollection constructor which has documentation that states that items existing in the list are NOT transformed.  This yields bizarre unexpected behavior for this method.

Conversely, the ListUtils.predicatedList(List list, Predicate pred) DOES apply the predicate.  These methods are very similar but behave inconsistently.

If the transformer is not applied to the list, the method's usefulness is somewhat limited and causes the user to create an extra unwanted list in some circumstances:

// To transform an existing list
List myList = ... some list to be transformed ...
List transformed = ListUtils.transformedList(new ArrayList(), myTransformer);
transformed.addAll(myList);

I would expect a much shorter implementation such as:

List transformed = ListUtils.transformedList(myList, myTransformer)
",Java 1.5,,,,,,,,,,,,,COLLECTIONS-288,,,,,05/Sep/07 13:37;bayard;COLLECTIONS-256.patch;https://issues.apache.org/jira/secure/attachment/12365172/COLLECTIONS-256.patch,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2007-08-15 05:22:30.219,,,false,,,,,,,,,,,,,,18744,,,Wed Sep 05 13:38:49 UTC 2007,,,,,,0|i0sigf:,164467,,,,,,,,"15/Aug/07 05:22;bayard;Given that javadoc states:

""Returns a transformed list backed by the given list.""

Then this seems like a definite bug that needs fixing.",17/Aug/07 12:47;scolebourne;I think we added another similar factory method to get around this issue IIRC.,"05/Sep/07 10:43;bayard;Yep - MapUtils.transform has the same bug and it was solved by adding TransformedMap.decorateTransform(..).

I'll go ahead and repeat that pattern for List, Collection, Set and Bag. ","05/Sep/07 13:37;bayard;Patch with tests and new methods for:

Buffer
Set
SortedSet
SortedBag
Bag
Collection
List",05/Sep/07 13:38;bayard;Patch applied.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Unused variable in TreeBidiMap.java,COLLECTIONS-255,12371193,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Trivial,Fixed,,bayard,bayard,08/Jun/07 00:32,09/Nov/14 14:31,07/Apr/19 20:37,28/Feb/13 19:55,Nightly Builds,,,,,4.0,4.0-alpha1,,BidiMap,,,,,,0,,,,"Twice in TreeBidiMap there is an entrySet variable that is not used. Rather the entrySet() method returns a new TreeView every time.

We should either:

a) Delete the variable.
b) Use the variable and always return the same TreeView.

I'm thinking a).

[Found via http://opensource.fortifysoftware.com/ ]",,,,,,,,,,,,,,,,,,,13/Sep/07 00:07;bayard;COLLECTIONS-255.patch;https://issues.apache.org/jira/secure/attachment/12365681/COLLECTIONS-255.patch,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2007-06-08 12:36:53.778,,,false,,,,,,,,,,,,,,18745,,,Tue Dec 29 22:36:58 UTC 2009,,,,,,0|i0sign:,164468,,,,,,,,"08/Jun/07 12:36;scolebourne;As a general rule, collections implementations use (b).","13/Sep/07 03:45;bayard;svn ci -m ""Removing the unused variable as mentioned in COLLECTIONS-255 by caching the TreeView object"" src

Sending        src/java/org/apache/commons/collections/bidimap/TreeBidiMap.java
Transmitting file data .
Committed revision 575154.","15/Sep/09 06:01;bayard;During the merge of the generics branch, I had to revert this fix. It needs to be refactored/reapplied in the new generics modified code.","29/Dec/09 22:36;mbenson;! /Users/mbenson/oss/asf/commons/trunks-proper/collections> svn commit -m ""[COLLECTIONS-255] re-address unused cache variable in TreeBidiMap"" src/java/org/apache/commons/collections/bidimap/TreeBidiMap.java 
Sending        src/java/org/apache/commons/collections/bidimap/TreeBidiMap.java
Transmitting file data .
Committed revision 894500.
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
containsKey on MultiHashMap seems incorrect,COLLECTIONS-250,12368186,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Critical,Invalid,jwcarman,ngd,ngd,27/Apr/07 10:24,15/Mar/08 21:36,07/Apr/19 20:37,30/Apr/07 10:56,3.1,3.2,,,,,,,Map,,,,,,0,,,,"
MultiHashMap m = new MultiHashMap();
m.putAll(""key"", Collections.EMPTY_LIST);
System.out.println(m.containsKey(""key"")) 

It says false, when it should have printed true. 

The problem is that the code in MultiHashMap and even MultiValueMap has in putAll():

if (values == null || values.size() == 0) 
{
            return false;
}

This means that they key is never being entered into the Map. This is causing a huge problem because the behaviour has changed.

",,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2007-04-27 19:39:51.64,,,false,,,,,,,,,,,,,,18749,,,Mon Apr 30 10:56:30 UTC 2007,,,,,,0|i0sihj:,164472,,,,,,,,27/Apr/07 19:39;jwcarman;The behavior has changed from what?  The Map API?,"29/Apr/07 20:10;bayard;It seems very correct to me - putAll(key, EMPTY_LIST) is a no-op. I'm not sure what behaviour has changed here - these methods haven't changed since they were added in r131607.","30/Apr/07 10:36;ngd;It's not changed, my mistake. 

Just as in a regular map that containsKey(key) is not equivalent to getValue(key) != null, i.e. after doing a put(key, null), containsKey(key), still returns true, I am expecting something similar. I find it wierd that after doing a putAll(key, LIST), containsKey(key) returns FALSE, it should return an empty list. 

My problem is this (maybe this is not to be discussed here, but I think it is appropriate at least to put the problem forward): I use MultiHashMap (MHM) for caching database results of 1-to-many relationships. Let's say its is a PERSON borrowed BOOKS relation. So, I do one SQL query to fetch all the books for many (not all) persons and then populate the MHM cache (SELECT book_id from BorrowedBooks where person_id in (id1, id2, id3...)). After populating, the MHM has person1->books borrowed by person1, person2->books borrwed by person2 etc. Now, a query comes asking for books borrowed by personX. Since there is no way of asking the MHM whether ""this key has no entries"", if I don't find the personX's key in the MHM, it is unclear if the caching query had fetched personX's id in the original query. If there was a way, of maintaining empty collections in the MHM, then this problem can be solved. 

Also there is no way to put an empty list for a key which I could have used as  workaround.",30/Apr/07 10:54;jwcarman;Just use a set along side the map to keep track of which persons have had their books cached.,30/Apr/07 10:56;jwcarman;I believe we have established that this is the desired functionality.  Changing it now would break other code which relies upon the existing behavior.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"SetUniqueList.addAll(int index, Collection coll) adds to end of list instead of at specified index",COLLECTIONS-249,12367704,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Minor,Fixed,,cyboc,cyboc,20/Apr/07 19:10,07/Nov/15 20:26,07/Apr/19 20:37,28/Feb/13 20:05,3.2,,,,,3.2.2,4.0,4.0-alpha1,List,,,,,,0,,,,"When you call SetUniqueList.addAll(int index, Collection coll), it incorrectly adds the new elements to the end of the list instead of at the specified index.",,,,,,,,,,,,,,,,,,,20/Apr/07 19:37;cyboc;SetUniqueList.patch;https://issues.apache.org/jira/secure/attachment/12355949/SetUniqueList.patch,20/Apr/07 19:30;cyboc;TestSetUniqueList.patch;https://issues.apache.org/jira/secure/attachment/12355948/TestSetUniqueList.patch,,,,,,,,2.0,,,,,,,,,,,,,,,,,,,2007-04-21 13:45:25.144,,,false,,,,,,,,,,,,,,18750,,,Sun Jan 20 20:53:56 UTC 2008,,,,,,0|i0sihr:,164473,,,,,,,,"20/Apr/07 19:30;cyboc;Here is a patch to TestSetUniqueList, which shows the bug. When you run it, the test fails with the following message ""First new element should be at index 0 expected:<2> but was:<1>"". The new unique element was added but it was added in the wrong place.","20/Apr/07 19:37;cyboc;Here is a patch to SetUniqueList, which fixes the bug. In addition, it also includes suggested fixes to the Javadoc comments for addAll(Collection coll) and addAll(int index, Collection coll), which seemed to be incorrect.

After applying the patch, the patched test (see previous attachment) passes.","21/Apr/07 13:45;bayard;
Nice find Joe, patches applied to trunk.

svn ci -m ""Applying Joe Kelly's fix for COLLECTIONS-249 - SetUniqueList.addAll(int, Collection> ) was always inserting at the end of the list"" 

Sending        RELEASE-NOTES.html
Sending        src/java/org/apache/commons/collections/list/SetUniqueList.java
Sending        src/test/org/apache/commons/collections/list/TestSetUniqueList.java
Transmitting file data ...
Committed revision 531027.","21/Dec/07 20:06;cyboc;FYI, I was just browsing collections_jdk5_branch and this bug seems to still exist in that branch. I guess the branch was created before this patch was committed (Oct 16, 2006 vs Apr 21, 2007). I'm not sure if this was the right place to put this comment or if I should have created a new issue -- sorry in advance, if this is the wrong place.","20/Jan/08 20:53;shammah;No worries about the generics branch.  At some point, the changes to the trunk will be merged into the branch.  I will most likely do this after each trunk release, to make tracking and merging easier.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
LoopingListIterator behaves unexpected on next and previous mixed,COLLECTIONS-246,12365343,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Blocker,Invalid,,fhefter,fhefter,20/Mar/07 09:07,28/Feb/13 19:52,07/Apr/19 20:37,26/Apr/08 15:17,3.2,,,,,,,,Iterator,,,,,,0,,,,"Using ArrayList as the backing list. 
This combination at least returns unexpected results as you can see in the testcase below.
I used this for a list navigator in a web frontend and had trouble with users.
I suspect java.util.AbstrList$ListItr (role of ""cursor"" var seems to be wrong implemented ) to cause this problem. If so maybe we have to implement it in a different way.

Testcase (it runs without hassle but the comments show whats wrong):
-------------------------------------------
import java.util.ArrayList;
import junit.framework.TestCase;
import org.apache.commons.collections.iterators.LoopingListIterator;

public class SelectionControllerTest extends TestCase {
    public void testSelectorForApache() {
        ArrayList al = new ArrayList();
        al.add(""0""); al.add(""1""); al.add(""2"");
        LoopingListIterator it = new  LoopingListIterator(al);
        assertEquals(""0"", it.next()); // This is OK
        // here I am on ""0""
        assertEquals(""0"", it.previous()); // Wrong ! This should be 2!
        //      here I am on ""0"" too! This is wrong.
        assertEquals(""2"", it.previous());
        assertEquals(""1"", it.previous());
        assertEquals(""0"", it.previous());
        assertEquals(""2"", it.previous());
        // here I am on ""2"" 
        assertEquals(""2"", it.next()); // Wrong ! This should be 0!
        // here I am on ""2"" too! This is wrong.
        assertEquals(""0"", it.next()); 
        assertEquals(""1"", it.next());
        // here I am on ""1""         
        assertEquals(""1"", it.previous()); // Wrong ! This should be 0!
    }
}
-------------------------------------------

Thanks for your help.","JDK 1.4.2_12 
Common Collections 3.2",,,,,,,,,,,,,,,,,,17/Mar/08 09:35;fhefter;LoopingListIterator.java;https://issues.apache.org/jira/secure/attachment/12378024/LoopingListIterator.java,11/Nov/07 22:12;davemeikle;LoopingListIterator.java;https://issues.apache.org/jira/secure/attachment/12369333/LoopingListIterator.java,12/Nov/07 09:55;fhefter;LoopingListIteratorTest.java;https://issues.apache.org/jira/secure/attachment/12369355/LoopingListIteratorTest.java,,,,,,,3.0,,,,,,,,,,,,,,,,,,,2007-03-20 23:12:03.341,,,false,,,,,,,,,,,,,,18753,,,Sat Apr 26 15:17:51 UTC 2008,,,,,,0|i0sii7:,164475,,,,,,,,20/Mar/07 23:12;shammah;This ticket makes sense - it's similar to COLLECTIONS-239,"17/Apr/07 14:56;bayard;Yeah, this one is interesting. In COLLECTIONS-239, the way it works is (afaik) by design and so that one should be a WONTFIX.

In this case, I think the same kind of problem exists. The statement of 'here I am on ""0""' in inaccurate, instead 'here' is the space between ""0"" and ""1"", not one of the elements. If we think of things as existing at an element and not the space between, then the example above begins pointing at ""2"", and in the non looping case it begins pointing at a null value that is prior to the list. That feels very odd.

I can see why these semantics don't give people what they want. Pointing at elements, while confusing at the boundaries, does make more sense in their use cases. I wonder if it would all be simpler if we didn't have the bad two-in-one next() previous() methods but used getNext() and moveToNext() semantics.

",12/Nov/07 09:55;fhefter;Testcase for the expected result,"12/Nov/07 09:58;fhefter;After I made the new test cases I found some problems with Daves implementation.
Please test my changes and report to me.
It would be the best if you show me failing test cases that I can fix then.
","12/Nov/07 11:27;fhefter;I don't want to make a new attachment for a small but useful addition. Maybe the next editor can add these lines then:
---------------------------------------------------------------------------------------------------
     /**
     * Just indicates the selection of the first entry in the list. 
     * This is good to indicate that the start of the list has been reached.
     * @return
     * @version initial Frank Hefter 2007-11-12
     */
    public boolean isFirst() {
        return currentIndex<=0;
    }

    /**
     * Just indicates the selection of the last entry in the list. 
     * This is good to indicate that the end of the list has been reached.
     * @return
     * @version initial Frank Hefter 2007-11-12
     */
    public boolean isLast() {
        return currentIndex>=list.size()-1;
    }
---------------------------------------------------------------------------------------------------
",17/Mar/08 09:35;fhefter;This is the bug free version with the additional methods.,17/Mar/08 09:38;fhefter;The attached version is working and has been tested.,17/Mar/08 15:09;bayard;Reopening as the suggested fix hasn't been applied to SVN.,"18/Mar/08 13:29;fhefter;Hallo Henri,

I'm not able to check in the changes into SVN since my connections here at work are very restrictive and at home I have no computer with a dev system set up.
Could you or someone else check in the changes for me?

Just copy all and past.

Thanks, 
  Frank






","26/Mar/08 05:57;bayard;I don't see us changing LoopingListIterator itself. The question is whether we add a different type of Iterator. It would also mean a different kind of OrderedIterator.

I'm suspecting this is a WONTFIX, accepting it as a facet of the design.","02/Apr/08 06:28;bayard;
The basic case that I think that has to be expected is:

{code:java}
Object o1 = it.next();
Object o2 = it.previous();

assertTrue(o1 == o2) 
{code}

"".next()"" moves the current position. So it's right for the it.previous() to return ""0"" and not ""2"". 

Previously I suggested that a different approach of getNext and moveToNext might be useful, but that would a) confuse by adding a duplicate layer and b) would not match the Collections API java.util.Iterator pattern. So I don't think there's anything to do here - the iterators work to the same pattern as the JDK's Iterator.","02/Apr/08 08:34;fhefter;For my opinion this test case is to simple and can't be compared with the more complex swap over at the beginning and the end of this LoopingList (thats the error I ment btw. !).

You simply take a java.util.Iterator test. But this ignores the abilities of this class comletely.

Again, please give me test cases that are better than mine. 

Also your test works with this fix, too. So it is an iterator? Right?

Just for the case: I don't care about the implementation. Just my tests have to apply.
So we can focus on the tests and make them more complexe. 

Is there a LoopIterator pattern somewhere? If not: Let's create it !","06/Apr/08 02:40;bayard;Can you restate your failing test? Looking at the description, I was taking it as:

{code:java}
ArrayList al = new ArrayList(); 
al.add(""0""); 
al.add(""1""); 
al.add(""2""); 
LoopingListIterator it = new LoopingListIterator(al); 
assertEquals(""0"", it.next()); // This is OK 
// here I am on ""0"" 
assertEquals(""0"", it.previous()); // Wrong ! This should be 2! 
{code}

Your statement here is incorrect - the answer should be 0 not 2. This is the base of your misunderstanding - you are not ""on 0"", you are ""before 0"". I think that's a part of the java.util.Iterator concept; and that we shouldn't implement an alternative to java.util.Iterator as it would lead to having to write lots of code.","14/Apr/08 11:55;fhefter;1. it.next() returns ""0"" this means the iterator is ON (not before or after) ""0""
2. it.previous() should return the value before ""0"" - this is ""2""

There is no before or after! What for ?

Following you opinion a  
it.next() 
it.previous 
it.next() 
it.previous 
it.next() 
a.s.o. 
should always return the same value. I would like to see these commands as buttons that navigate through a list. Would a user that presses these buttons expect to stay at the same place? For sure not.

I think thats the mistake of your thinking. A command has to move the iterator. The former error was that I was not able to predict that.
","15/Apr/08 11:31;scolebourne;Could everyone please read the javadoc for ListIterator.
http://java.sun.com/javase/6/docs/api/java/util/ListIterator.html#previous()

next() followed by previous() return the same value.","26/Apr/08 15:17;bayard;Thanks Stephen, closing this as the current behaviour matches ListIterator.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
MultiValueMap should implement Serializable,COLLECTIONS-240,12360935,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Blocker,Fixed,,wouterv,wouterv,20/Jan/07 14:09,09/Nov/14 14:31,07/Apr/19 20:37,28/Feb/13 20:04,3.2,,,,,4.0,4.0-alpha1,,Map,,,,,,11,,,,"Collection classes should be serializable as they are frequently used in model classes which need to be serializable, for example in a HttpSession object within a servlet container cluster.",,,,,,,,,,,,,,,,COCOON-2151,,,17/Mar/08 05:28;bayard;COLLECTIONS-240.patch;https://issues.apache.org/jira/secure/attachment/12378019/COLLECTIONS-240.patch,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2007-05-03 19:38:28.485,,,false,,,,,,,,,,,,,,18759,,,Fri May 23 06:45:21 UTC 2008,,,,,,0|i0seq7:,163862,,,,,,,,03/May/07 19:38;bayard;+1,04/May/07 11:15;joerg.heinicke@gmx.de;I second this since I use the deprecated MultiHashMap and can't migrate my code since I need the serialization.,"23/Aug/07 16:53;bayard;An easy change to make (obviously); but TestMultiHashMap doesn't extend AbstractTestMap and get the automatic Serialization testing, so need to either a) duplicate said testing or b) figure out how to make MultiHashMap fit the TestMap contract. 12 Failures and 4 errors for a simple try.","18/Sep/07 11:02;alanmehio;I found a bug in the in the method below from a related  test class; however, this has been fixed in the latest svn at 

http://svn.apache.org/viewvc/commons/proper/collections/trunk/src/java/org/apache/commons/collections/map/MultiValueMap.java?revision=560660


public boolean putAll(Object key, Collection values) {

   if (coll.size() > 0) {

                 coll = createCollection(values.size()); 
                 boolean result = coll.addAll(values);
                // only add if non-zero size to maintain class state
                getMap().put(key, coll);
                result = false;  // here  should be true since collection has been changed 
                // returns true for a none zero one 
            }
            return result;
}


Another issue which  I have noticed is the code line 
 coll = createCollection(values.size());  

the method  
 protected Collection createCollection(int size) {
        return (Collection) collectionFactory.create();
    }

does not use the  ""size"";  I am guessing the method signature is left because of backward compatibility

It would be nice it we can create the correct size for the ArrayList instead of the default one which is 10 
when we add the collection to the newly created ArrrayList  as below

coll = createCollection(values.size()); 
                 boolean result = coll.addAll(values);

this will give better code optimization 




I think MultiValueMap should implement Serializable ( can be serialized)


Regards,
Alan Mehio

","21/Sep/07 11:29;alanmehio;<quoted-statemen>
It would be nice it we can create the correct size for the ArrayList instead of the default one which is 10 
</quoted-statement>


This will not optimize the code since the ArrayList ; please refere to the below methods in the ArrayList based on 
the constructor with empty array size i.e new ArrayList();

 public boolean addAll(Collection<? extends E> c) {
	Object[] a = c.toArray();
        int numNew = a.length;
	ensureCapacity(size + numNew);  // Increments modCount
        System.arraycopy(a, 0, elementData, size, numNew);
        size += numNew;
	return numNew != 0;
    } 


public boolean add(E o) {
	ensureCapacity(size + 1);  // Increments modCount!!
	elementData[size++] = o;
	return true;
    }


 public void ensureCapacity(int minCapacity) {
	modCount++;
	int oldCapacity = elementData.length;
	if (minCapacity > oldCapacity) { 
	    Object oldData[] = elementData;
	    int newCapacity = (oldCapacity * 3)/2 + 1;
    	    if (newCapacity < minCapacity)
		newCapacity = minCapacity;
	    elementData = (E[])new Object[newCapacity];
	    System.arraycopy(oldData, 0, elementData, 0, size);
	}
    }



Cheers
Alan Mehio
London, UK

","27/Nov/07 02:20;joerg.heinicke@gmx.de;The Cocoon team had to revert back code changes to MultiHashMap due to missing serializability as mentioned in the linked issue. This issue seems to bug a lot of people ;)

PS: Alan, please write up new logs for your findings instead of reusing this one since it is really only about implementing Serializable.","27/Nov/07 07:01;wouterv;I think it is time this bug receives the attention it needs (see the cocoon issues) ;-)
","17/Mar/08 05:28;bayard;I've started work on this. Here is the current state.

The fullCollection obj file is presumably bad as I'm making no effort to fill it. There are 11 failures and 3 errors. 

The failures are generally due to hashCodes not matching before and after serialization - I think. The errors are NullPointerExceptions.

It's a start :)","10/Apr/08 19:14;davemeikle;Most of the errors are down to the hashCode being different. This is because the MultiValueMap in the test is wrapping values up in an ArrayList where as the comparison map is expecting the raw value.

I am trying to use the existing base test to correct this by means of overriding some methods to some success but have been hit by a laptop screen failure! Will get the code of and see where I get too.

Dave","16/May/08 07:28;bayard;Right. First step is getting MultiValueMap on the test structure. That has 11 errors; regardless of serialization being used. So either a) that gets fixed, or b) just write a different bit of serialization testing. Very tempted by the latter by this stage.","16/May/08 08:11;bayard;I've gone ahead and made MultiValueMap serializable:

http://svn.apache.org/viewvc?view=rev&revision=656960

Any review would be very welcome. ",23/May/08 06:45;bayard;No comments - closing as fixed.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
In LinkIterator hasPrevious() is not working properly for the first entry,COLLECTIONS-239,12360661,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Won't Fix,,mic,mic,17/Jan/07 09:26,27/Apr/13 21:25,07/Apr/19 20:37,26/Mar/08 05:36,3.2,,,,,,,,Iterator,,,,,,0,,,,"In hasPrevious() method of LinkIterator 'next' field is used, that is not correct  - method returns 'true' for the first entry. 'last' field should be used insted.","Windows XP, jdk-1.5.0_02",,,,,,,,,,,,,,,COLLECTIONS-246,,,06/Feb/07 20:12;bayard;COLLECTIONS-239-test.patch;https://issues.apache.org/jira/secure/attachment/12350491/COLLECTIONS-239-test.patch,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2007-01-29 23:18:32.705,,,false,,,,,,,,,,,,,,18760,,,Thu Jul 26 23:07:49 UTC 2012,,,,,,0|i0sijb:,164480,,,,,,,,"29/Jan/07 23:18;bayard;Looking at trunk, the actual code is:

            return (next.before != parent.header);

Not the most semantically clear, but the following test appears to pass quite happily:

    // http://issues.apache.org/jira/browse/COLLECTIONS-239
    public void testCollections239() {
        LinkedMap map = new LinkedMap();
        map.put(""1"", ""1"");
        map.put(""2"", ""2"");
        map.put(""3"", ""3"");
        map.put(""4"", ""4"");

        OrderedIterator itr = (OrderedIterator) map.values().iterator();
        assertFalse( itr.hasPrevious() );
        for( int i=0; i < 4; i++) {
            assertTrue( itr.hasNext() );
            Object ignore = itr.next();
            assertTrue( itr.hasPrevious() );
        }

        assertFalse( itr.hasNext() );
    }

So I think this is resolvable as ""cannot reproduce"". Do you have a test case that fails?",05/Feb/07 17:12;bayard;Going ahead with the 'cannot reproduce'. Please feel free to reopen the issue.,"06/Feb/07 11:33;mic;Why OrderedIterator should rely on 'next' field? Current(last returned) entry is in 'last' field. 
Semantically in java.util.Iterator hasNext() referes to last returned value.
My use case is: I need to iterate through map values in JSP and construct a table with command to move up &down. My code is:
  for (OrderedIterator I = (OrderedIterator)map.values().iterator(); I.hasNext();)
  {
     /* next() is the only method that can return current value, but it moves iterator cursor to the next entry
     so hasPrevious returns true. In order to get it right i need to remember it first in separate field like these*/
   // boolean hasPrevious = I.hasPrevious();
     String s = (String) I.next();%>
     <tr><td><%=s%></td><td><%if(I.hasPrevious()){%><input type=""button"" value=""UP"" onClick=""...""/><%}%></td>...</tr><%
   
  }
","06/Feb/07 11:51;mic;Semantically hasNext() referes to last returned value ('last' field) (in java.util.Iterator ). 
Why hasPrevious() should use 'next' field (in LinkIterator)?
","06/Feb/07 20:12;bayard;I think I see. Your report is that hasPrevious() should still return false after the first element.

I've attached a unit test that shows that this is a problem. Thanks for reopening.","06/Feb/07 20:27;bayard;(grr's at firefox 2 for losing a long reply).

I'm still thinking we should resolve this as not to be fixed. Here's why:

OrderedIterator oi = ...;
oi.next();
oi.previous();
oi.next();
oi.previous();
// back at the start

If hasPrevious() was to return false after moving passed the first element, then the above would not be possible. Looking at the Javadoc for OrderedIterator, the previous() method does need to indicate that movement happens, and the class Javadoc could do with a note on this subject - that hasPrevious() returns true after calling the first next().",26/Mar/08 05:36;bayard;Closing this as WONTFIX. I think it's burnt into the semantics of how the class works and this is a side-effect.,"26/Jul/12 20:11;hudson;Integrated in commons-collections #68 (See [https://builds.apache.org/job/commons-collections/68/])
    [COLLECTIONS-239] Use of generic Equator in EqualPredicate. (Revision 1366174)

     Result = UNSTABLE
tn : http://svn.apache.org/viewvc/?view=rev&rev=1366174
Files : 
* /commons/proper/collections/trunk/src/changes/changes.xml
* /commons/proper/collections/trunk/src/main/java/org/apache/commons/collections/functors/EqualPredicate.java
","26/Jul/12 23:07;hudson;Integrated in commons-collections #69 (See [https://builds.apache.org/job/commons-collections/69/])
    [COLLECTIONS-239] to keep backwards compatibility, do not use DefaultEquator in case no equator is specific, but rather use the original equals method. (Revision 1366185)

     Result = SUCCESS
tn : http://svn.apache.org/viewvc/?view=rev&rev=1366185
Files : 
* /commons/proper/collections/trunk/src/main/java/org/apache/commons/collections/functors/EqualPredicate.java
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
MultiValueMap: behavior of entrySet().iterator() is not the expected one,COLLECTIONS-237,12358457,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,nika,nika,12/Dec/06 18:09,09/Nov/14 14:31,07/Apr/19 20:37,27/Apr/13 11:09,3.2,,,,,4.0,4.0-alpha1,,Map,,,,,,1,,,,"The entrySet() method of the MultiValueMap delegates the entrySet() call to the decorated map, which is HashMap by default. The default hashmap iterator is used, which causes the iterator to return one Map.Entry for every key. The value returned for the key is an ArrayList, and not the value of the entry which was put into the map.

The expected behavior would be the iterator to return the whole set of entries in the map, which requires iteration over the different array lists contained in the decorated map.",,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2006-12-12 21:57:18.0,,,false,,,,,,,,,,,,,,18762,,,Sat Apr 27 11:09:45 UTC 2013,,,,,,0|i0ftk7:,90387,,,,,,,,"12/Dec/06 21:57;bayard;
Given that we flatten values(), it makes a lot of sense to return a flattened entrySet() and not an unflattened one; however entrySet() returns a Set which to me implies that there should not be a duplicated key,value pair. MultiValueMap doesn't stop the value having dupes so it's entirely possible.

So, that seems that either:

1/ We define entrySet as matching keySet and mark this issue WONTFIX.
2/ We define entrySet as matching values and make sure our Map.Entry classes do not equal each other.
3/ We define entrySet as matching unique key-values pairs - so that:

keySet().size() <= entrySet().size() <= values().size()

Anyone have thoughts on which should be done?

Bear in mind that 2+3 both involve backwards compat issues if people are expecting 1.","21/Sep/07 11:10;alanmehio;<quoted-statement>
The value returned for the key is an ArrayList, and not the value of the entry which was put into the map
</quoted-statement>
What if we overload the method below 

public Iterator iterator(Object key) 
           
with 

   public Iterator iterator() {
       return getMap().entrySet().iterator();
    }


otherwise I am in favour of point one 
<point-one>
1/ We define entrySet as matching keySet and mark this issue WONTFIX.
</point-one>


Regards,
Alan Mehio
London, UK



",19/Mar/08 06:49;bayard;+1 to the iterator() idea. Needs to be coded up with unit test for anyone that wants to dive in.,"13/May/08 05:12;bayard;#1 gets the vote. On iterator....

Shouldn't the iterator() be returning a flattened iteration of values from all of the contained ArrayLists; and also be generating ConcurrentModificationException in some fun way?

I don't think this will be simple to implement, so pushing up to 3.4.","16/May/08 06:22;bayard;Ironically, this is the same bug that causes errors with the serialization tests in COLLECTIONS-240. containsAll fails because the elements are now all inside arraylists.","05/Nov/10 00:46;modsiw;I have a possible solution (perhaps unacceptable) that was coded for in-house use.

In this solution, MultiMap.entrySet returns a flattened ""set"" that violates the general contract of set by allowing two Entry that are .equals . It behaves as an IdentitySet, similar to th keys of java.util.IdentityHashMap .

Another note is that the set supports .remove and if all values for a key are removed, the key is also removed. I'm unsure if the removal of the key is desired. It would be trivial to change.

If this solution is desired for the library, I'll work it up as a proper patch.","27/Apr/13 11:09;tn;In r1476553, I have implemented the #iterator() method as suggested and clarified the javadoc for #entrySet().

The Map.Entry objects returned by iterator() do not support setValue(Object), but I guess this is ok for now.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
CollectionUtils.filter filters the inverse of what it is documented to filter,COLLECTIONS-236,12356271,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Invalid,,lwexler,lwexler,21/Nov/06 14:12,22/Nov/06 16:26,07/Apr/19 20:37,22/Nov/06 16:26,3.2,,,,,,,,Collection,,,,,,0,,,,"The documentation states that when the predicate returns *false* the item will be removed.
The implementation removes those items that return true.

",,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2006-11-22 16:26:12.0,,,false,,,,,,,,,,,,,,18763,,,Wed Nov 22 16:26:12 UTC 2006,,,,,,0|i0sijr:,164482,,,,,,,,"21/Nov/06 14:25;lwexler;Please close this bug as incorrect.  My sincere apologies for being too hasty.
",22/Nov/06 16:26;bayard;Reporter requested this bug be closed.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
MultiValueMap put and putAll do not return the correct values,COLLECTIONS-228,12354197,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Minor,Fixed,scolebourne,scolebourne,scolebourne,28/Oct/06 12:14,07/Nov/15 20:47,07/Apr/19 20:37,28/Feb/13 20:25,3.2,,,,,3.2.2,4.0,4.0-alpha1,Map,,,,,,0,,,,"MultiValueMap put and putAll do not return the correct values.

putAll(Object, Collection) should return true if the map is changed. But if the key is new then this behaviour fails.

put(Object, Object) should return the added value if the map is changed. But if the key is new then this behaviour fails.

This was hidden because the test case referred to MultiHashMap and not MultValueMap.",,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,18771,,,2006-10-28 12:14:56.0,,,,,,0|i0silj:,164490,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
CollectionUtils removeAll is actually retainAll,COLLECTIONS-222,12348239,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Duplicate,,seabamirum,seabamirum,18/Aug/06 17:43,18/Aug/06 19:01,07/Apr/19 20:37,18/Aug/06 19:01,3.2,,,,,,,,Collection,,,,,,0,,,,"The removeAll(Collection collection, Collection remove) method calls ListUtils.retainAll(collection, remove)
instead of ListUtils.removeAll(Collection collection, Collection remove)

Should be an easy fix",,,,,,,,,,,,,,COLLECTIONS-219,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2006-08-18 18:08:48.0,,,false,,,,,,,,,,,,,,18777,,,Fri Aug 18 18:08:48 UTC 2006,,,,,,0|i0sim7:,164493,,,,,,,,18/Aug/06 18:08;mbenson;duplicate of COLLECTIONS-219,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"CompositeCollection, CompositeMap, CompositeSet should implement Serializable",COLLECTIONS-221,12347852,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Minor,Fixed,,denespal,denespal,12/Aug/06 17:10,09/Nov/14 14:31,07/Apr/19 20:37,28/Feb/13 20:08,3.2,,,,,4.0,4.0-alpha1,,Collection,Map,Set,,,,1,,,,"These classes should implement Serializable as usually all generial collection classes do. (At least I cannot think of a reason why they shouldn't and currently their usage is quite limited, like in RMI or http-sessions.)",,,,,,,,,,,,,,,,,,,13/May/08 06:52;bayard;COLLECTIONS-221.patch;https://issues.apache.org/jira/secure/attachment/12381931/COLLECTIONS-221.patch,,,,,,,,,1.0,,,,,,,,,,,,,,,,,,,2007-05-03 19:39:30.228,,,false,,,,,,,,,,,,,,18778,,,Tue May 13 06:53:50 UTC 2008,,,,,,0|i0simf:,164494,,,,,,,,03/May/07 19:39;bayard;+1,"29/Sep/07 17:07;alanmehio;+1
Can somebody mention one reason why these classes( CompLsiteCollection, CompositeMap, CompositeSet) should not be Serializabel if the  ArrayList, HashSet, LinkedHashSet, HashMap, TreeMap and so on ... 
are Serializable.


Regards,
Alan Mehio
London, UK
",13/May/08 06:52;bayard;Patch to make these serializable. Patch doesn't include the binary .obj files as it only supports text.,"13/May/08 06:53;bayard;svn ci -m ""Applying my patch from COLLECTIONS-221 - making the CompositeMap, CompositeSet and CompositeCollection serializable. The only difference from the patch is that the creation of the obj files in TestCompositeMap is commented out""

Adding  (bin)  data/test/CompositeCollection.emptyCollection.version3.3.obj
Adding  (bin)  data/test/CompositeCollection.fullCollection.version3.3.obj
Adding  (bin)  data/test/CompositeMap.emptyCollection.version3.3.obj
Adding  (bin)  data/test/CompositeMap.fullCollection.version3.3.obj
Adding  (bin)  data/test/CompositeSet.emptyCollection.version3.3.obj
Adding  (bin)  data/test/CompositeSet.fullCollection.version3.3.obj
Sending        src/java/org/apache/commons/collections/collection/CompositeCollection.java
Sending        src/java/org/apache/commons/collections/map/CompositeMap.java
Sending        src/test/org/apache/commons/collections/collection/TestCompositeCollection.java
Adding         src/test/org/apache/commons/collections/map/EmptyMapMutator.java
Sending        src/test/org/apache/commons/collections/map/TestCompositeMap.java
Adding         src/test/org/apache/commons/collections/set/EmptySetMutator.java
Sending        src/test/org/apache/commons/collections/set/TestCompositeSet.java
Transmitting file data .............
Committed revision 655751.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Serialization/Deserialization doesn't work well with empty buffers.,COLLECTIONS-220,12347430,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Minor,Fixed,,jlhuertas,jlhuertas,07/Aug/06 13:53,27/Nov/15 21:11,07/Apr/19 20:37,28/Feb/13 20:08,3.2,,,,,,,,Buffer,,,,,,1,,,,"When I serialize the queue to disk an it has elements, all works ok, but when I serialize an empty queue I have some problems when I create a new object using the serialized file.

When I deserialize the queue it has a 'buffer' with size 1 (with null content), 'tail' and 'head' fields are 0 (they are declared transient). So, when I try to add a new object to the queue, the sentence:

 Object[] tmp = new Object[((buffer.length - 1) * 2) + 1];

Is executed in the add() method to increase the buffer length, but the buffer remains with the same size! (buffer.length = 1 --> (1 - 1) * 2 + 1 = 1). So, the object is added and when the tail is going to be incremented, it is reset to 0!! 

    private int increment(int index) {
        index++;
        if (index >= buffer.length) {
            index = 0;
        }
        return index;
    }


So it is impossible to add new elements after an empty queue has been serialized / deserialized.

I attach a simple TestCase where this is proved. The example works when you use XMLEncoder to serialize the buffer but doesn't work if you use ObjectOutputStream or XStream.",,,,,,,,,,,,,,,,,,,07/Aug/06 13:53;jlhuertas;ASF.LICENSE.NOT.GRANTED--SerializationTest.java;https://issues.apache.org/jira/secure/attachment/12338277/ASF.LICENSE.NOT.GRANTED--SerializationTest.java,29/Dec/06 00:27;davemeikle;COLLECTIONS-200.patch;https://issues.apache.org/jira/secure/attachment/12348027/COLLECTIONS-200.patch,16/Mar/08 00:24;bayard;COLLECTIONS-220.patch;https://issues.apache.org/jira/secure/attachment/12377983/COLLECTIONS-220.patch,,,,,,,3.0,,,,,,,,,,,,,,,,,,,2006-12-29 00:27:02.0,,,false,,,,,,,,,,,,,,18779,,,Mon Apr 22 19:07:49 UTC 2013,,,,,,0|i0simn:,164495,,,,,,,,29/Dec/06 00:27;davemeikle;Proposed Patch to fix Object Serialization Problem,03/May/07 19:43;bayard;Nice simple patch. +1. ,"16/Mar/08 00:24;bayard;Attaching a unit test for this, along with Dave's previously attached fix.","16/Mar/08 00:25;bayard;svn ci -m ""Applying a unit test for COLLECTIONS-220. AbstractTestObject is refactored to provide a utility method that serializes and then deserializes. Dave Meikle's fix for said unit test is also applied. "" src

Sending        src/java/org/apache/commons/collections/buffer/UnboundedFifoBuffer.java
Sending        src/test/org/apache/commons/collections/AbstractTestObject.java
Sending        src/test/org/apache/commons/collections/buffer/TestUnboundedFifoBuffer.java
Transmitting file data ...
Committed revision 637495.","22/Apr/13 19:07;tn;The Buffer interface/implementations have been removed, thus this fix is obsolete.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
The CollectionUtils.removeAll method calls the ListUtils.retainAll method instead of the ListUtils.removeAll method.,COLLECTIONS-219,12347178,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,scolebourne,toml,toml,02/Aug/06 17:37,07/Nov/15 19:51,07/Apr/19 20:37,28/Feb/13 20:25,3.2,,,,,3.2.2,4.0,4.0-alpha1,Core,,,,,,0,,,,The CollectionUtils.removeAll method calls the ListUtils.retainAll method instead of the ListUtils.removeAll method.,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2006-08-02 20:23:07.0,,,false,,,,,,,,,,,,,,18780,,,Sat Nov 07 19:51:56 UTC 2015,,,,,,0|i0k3uv:,115442,,,,,,,,"02/Aug/06 20:23;scolebourne;Fixed in svn 348013, thanks",08/Sep/11 10:26;szczerb;Is there any hope for a 3.2.2 bugfix release?,18/Nov/13 12:28;strug;I question myself why there is no 3.2.2. bugfix release?,"18/Nov/13 12:55;tn;There are plans to actually do this, but the priority is currently on releasing 4.0","07/Nov/15 19:51;jochen@apache.org;The actual problem seems to me to be a gap in the test suite.
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Flat3Map.Entry.setValue() overwrites other Entry values,COLLECTIONS-217,12346193,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Critical,Fixed,scolebourne,mattbishop,mattbishop,18/Jul/06 17:42,08/Nov/15 20:21,07/Apr/19 20:37,18/Jul/06 22:02,3.2,,,,,3.2.2,4.0,,Map,,,,,,1,,,,"Flat3Map's Entry objects will overwrite other Entry's values if Entry.setValue() is called on one.  It should only overwrite the Entry at hand.

I've looked at the source, and the case statement incorrectly falls through, rather than returning like it should:

Flat3Map.java, lines 646-660:

        public Object setValue(Object value) {
            if (canRemove == false) {
                throw new IllegalStateException(AbstractHashedMap.SETVALUE_INVALID);
            }
            Object old = getValue();
            switch (nextIndex) {
                case 3: 
                    parent.value3 = value;
                case 2:
                    parent.value2 = value;
                case 1:
                    parent.value1 = value;
            }
            return old;
        }

With this code, if I set the value of the third item in the EntrySet, then all three values are set to the new value.
","JDK 1.4, WinXP",,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2006-07-18 20:20:47.0,,,false,,,,,,,,,,,,,,18782,,,Tue Jul 18 22:02:11 UTC 2006,,,,,,0|i0sin3:,164497,,,,,,,,"18/Jul/06 20:20;matt@thebishops.org;This should really be the Map component, but I don't have edit rights.",18/Jul/06 22:02;scolebourne;Fixed in revision 423264,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
ExtendedProperties - field include should be non-static and private,COLLECTIONS-214,12344554,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,scolebourne,sebb@apache.org,sebb@apache.org,18/Jun/06 18:54,27/Apr/13 21:32,07/Apr/19 20:37,18/Jul/06 22:44,3.2,,,,,,,,,,,,,,0,,,,"The field ""include"" in ExtendedProperties is currently static and protected, yet has instance get/set accessors.

Given that there are accessors, it seems unnecessary for the field to be protected - it could be private.

The field should also surely be non-static - or the accessors should be made static, if the field really is supposed to be shared among instances.",,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2006-07-18 22:44:33.0,,,false,,,,,,,,,,,,,,18785,,,Sat Apr 27 21:32:50 UTC 2013,,,,,,0|i0sinr:,164500,,,,,,,,"18/Jul/06 22:44;scolebourne;Fixed in rv 423272

Added a private instance variable and deprecated the static variable.
Altered the get and set methods to use the instance variable falling back to the static variable as a default.",27/Apr/13 21:32;tn;Fix obsolete as the class has been removed.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
[collections][PATCH] CollectionUtils.getFreq optimization,COLLECTIONS-136,12340950,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,janekdb@yahoo.co.uk,janekdb@yahoo.co.uk,09/Sep/03 03:59,15/Mar/08 21:36,07/Apr/19 20:37,15/Mar/08 21:36,Nightly Builds,,,,,,,,,,,,,,0,,,,"The attached patch improves the performance of CollectionUtils.getFreq(Object,
Map) by using a test in place of a thrown exception.

The effect of the change was measured with the class below. These are the times
for the Sun JDK 1.4.1_03 on Red Hat Linux 8.0

pre-optimization:   122534
post-optimization:  104637

The patch reduced the time to run the test to 85% of the original.

The also patch removes a catch of NoSuchElementException which, as far as I can
tell, was unnecessary in the original code.

This is the test class:

import org.apache.commons.collections.CollectionUtils ;

import java.util.*;

public class CollectionUtilsTest {


    Set a ;
    Set b ;
    Set c ;

    Collection cols []  ;

    long startMillis ;
    void init () {

	a = new HashSet () ;
	for ( int i = 1 ; i <= 10000 ; i++ ) {
	    a.add ( new Integer ( i ) ) ;
	}

	b = new HashSet () ;
	for ( int i = 5001 ; i <= 15000 ; i++ ) {
	    b.add ( new Integer ( i ) ) ;
	}

	c = new HashSet () ;
	for ( int i = 10001 ; i <= 20000 ; i++ ) {
	    c.add ( new Integer ( i ) ) ;
	}

	cols = new Collection [] { a, b, c } ;

	startMillis = System.currentTimeMillis () ;
    }


    void run () {

	for ( int i = 0 ; i < 3 ; i++ ) {
	    for ( int j = 0 ; j < 3 ; j++ ) {
		CollectionUtils.union ( cols [ i ], cols [ j ] ) ;
		CollectionUtils.intersection ( cols [ i ], cols [ j ] ) ;
		CollectionUtils.disjunction ( cols [ i ], cols [ j ] ) ;
		CollectionUtils.subtract ( cols [ i ], cols [ j ] ) ;
	    }
	}

    }


    void report () {

	System.out.println ( ""Elapsed millis: "" + ( System.currentTimeMillis () -
startMillis ) ) ;
    }



    public static void main ( String  [] arg ) {

	CollectionUtilsTest t = new CollectionUtilsTest () ;

	t.init () ;
	t.run () ;
	t.report () ;

    }
}","Operating System: other
Platform: Other",,,,,,,,,,,,,,,,,,09/Sep/03 04:00;janekdb@yahoo.co.uk;ASF.LICENSE.NOT.GRANTED--CollectionUtils-replace-try-catch-with-test.path;https://issues.apache.org/jira/secure/attachment/12332511/ASF.LICENSE.NOT.GRANTED--CollectionUtils-replace-try-catch-with-test.path,,,,,,,,,1.0,,,,,,,,,,,,,,,,23004.0,,,2003-09-10 04:56:13.0,,,false,,,,,,,,,,,,,,18862,,,Wed Sep 10 04:56:13 UTC 2003,,,,,,0|i0sj3r:,164572,,,,,,,,"09/Sep/03 04:00;janekdb@yahoo.co.uk;Created an attachment (id=8106)
Patch to improve the performance of CollectionUtils.getFreq
","10/Sep/03 04:56;scolebourne@joda.org;patch applied, thanks",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
[PATCH] SwitchTransformer doc/impl inconsistent,COLLECTIONS-135,12343009,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Trivial,Fixed,,gudnabrsam@yahoo.com,gudnabrsam@yahoo.com,05/Apr/06 05:38,15/Mar/08 21:36,07/Apr/19 20:37,15/Mar/08 21:36,Nightly Builds,,,,,,,,,,,,,,0,,,,"TransformerUtils says that a null defaultTransformer will return null; this is
consistent with the switchTransformer tests under TestTransformerUtils. 
However, the SwitchTransformer constructor's javadoc says that a null
defaultTransformer means nop, which is incorrect.  Not that it matters, but NOP
would have been more intuitive IMHO, but what's done is done and passing
NOPTransformer.INSTANCE or TransformerUtils.nopTransformer() is no big deal.","Operating System: other
Platform: Other",,,,,,,,,,,,,,,,,,05/Apr/06 05:41;gudnabrsam@yahoo.com;ASF.LICENSE.NOT.GRANTED--switchxform.patch.txt;https://issues.apache.org/jira/secure/attachment/12334099/ASF.LICENSE.NOT.GRANTED--switchxform.patch.txt,,,,,,,,,1.0,,,,,,,,,,,,,,,,39207.0,,,2006-04-11 06:23:41.0,,,false,,,,,,,,,,,,,,18863,,,Tue Apr 11 06:23:41 UTC 2006,,,,,,0|i0sj3z:,164573,,,,,,,,"05/Apr/06 05:41;gudnabrsam@yahoo.com;Same goes for getInstance(.,.,.)","05/Apr/06 05:41;gudnabrsam@yahoo.com;Created an attachment (id=18024)
suggested javadoc patch
","11/Apr/06 06:23;scolebourne@joda.org;Patch applied, thanks",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
[collections] Error in deserialization of full BoundedFifoBuffer,COLLECTIONS-134,12342722,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Duplicate,,apachebugz@tkuhn.de,apachebugz@tkuhn.de,17/Nov/05 07:52,15/Mar/08 21:36,07/Apr/19 20:37,15/Mar/08 21:36,3.1,,,,,,,,,,,,,,0,,,,"If a BoundedFifoBuffer is serialized and then deserialized the value of the end
attribute is set to the max size of the Buffer which is a fault and causes an
ArrayIndexOutOfBoundException during add(object). In this case the value of end
must be set to 0 in the deserialization.","Operating System: All
Platform: All",,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,37539.0,,,2005-11-22 08:43:45.0,,,false,,,,,,,,,,,,,,18864,,,Tue Nov 22 08:43:45 UTC 2005,,,,,,0|i0sj47:,164574,,,,,,,,"17/Nov/05 08:11;apachebugz@tkuhn.de;Actually the exception thrown is not an ArrayIndexOutOfBoundsException as statet
in my report but an BufferOverflowException as expected. The problem with the
faulty ArrayIndexOutOfBoundsException occours if you first call remove() and
then add(object) on the deserialized Buffer. (I never used BoundedFifoBuffer by
itself but had the problem with a CircularFifoBuffer wich first calls a remove()
on the full Buffer during add.)","22/Nov/05 08:43;scolebourne@joda.org;

*** This bug has been marked as a duplicate of 31433 ***",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
JavaDoc for ListUtils and FactoryUtils missing,COLLECTIONS-133,12340347,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Incomplete,,cob@atp.dk,cob@atp.dk,04/Oct/02 20:16,15/Mar/08 21:36,07/Apr/19 20:37,15/Mar/08 21:36,,,,,,,,,,,,,,,0,,,,"ListUtils and FactoryUtils are missing from the currently accessable commons 
collection javadoc.
Maybe there are other classes missing?","Operating System: other
Platform: Other",,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,13288.0,,,2002-11-25 04:35:33.0,,,false,,,,,,,,,,,,,,18865,,,Mon Nov 25 04:35:33 UTC 2002,,,,,,0|i0sj4f:,164575,,,,,,,,"25/Nov/02 04:35;scolebourne@joda.org;ListUtils is available on-line at 
http://jakarta.apache.org/commons/collections/api/index.html.

FactoryUtils no longer exists.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Input streams are never closed in ExtendedProperties,COLLECTIONS-132,12341343,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,lbe.tech@spree.de,lbe.tech@spree.de,17/Mar/04 20:59,15/Mar/08 21:36,07/Apr/19 20:37,15/Mar/08 21:36,3.0,,,,,,,,,,,,,,0,,,,"If I read a file with ExtendedProperties the OS cannot remove this file as long
as my JVM is running because it has still a handle on that file.","Operating System: other
Platform: Other",,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,27737.0,,,2004-03-18 05:12:01.0,,,false,,,,,,,,,,,,,,18866,,,Thu Mar 18 05:12:01 UTC 2004,,,,,,0|i0sj4n:,164576,,,,,,,,"18/Mar/04 05:12;scolebourne@joda.org;Change made to CVS, to close the file handle opened in the constructor. 
Hopefully this should solve your problem.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
performing get(Object) operations inside of an iteration produces an infinite loop,COLLECTIONS-131,12340220,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,morgand@apache.org,morgand@apache.org,09/May/02 01:03,15/Mar/08 21:36,07/Apr/19 20:37,15/Mar/08 21:36,,,,,,,,,,,,,,,0,,,,"I just ""fixed"" LRUMap, which was not promoting get(Object) operations correctly.
However, now if you perform a get(Object) within an iteration of the 
keySet(), it will keep promoting values to the top and producing an
infinite loop.  This needs to be fixed, by making the collection throw a
ConcurrentModificationException, or by fixing the behaviour in some other way.","Operating System: other
Platform: Other",,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,8913.0,,,2002-06-10 06:16:22.0,,,false,,,,,,,,,,,,,,18867,,,Mon Jun 10 06:16:22 UTC 2002,,,,,,0|i0sj4v:,164577,,,,,,,,"10/Jun/02 06:16;mas@apache.org;SequencedHashMap now has fail-fast iterators which LRUMap picks up because it is
a subclass.  So, I believe this bug is fixed.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
[collections] CollectionUtils.cardinality should be made smarter about Bag,COLLECTIONS-130,12341423,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,jon.schewe@honeywell.com,jon.schewe@honeywell.com,27/Apr/04 21:37,15/Mar/08 21:36,07/Apr/19 20:37,15/Mar/08 21:36,3.0,,,,,,,,,,,,,,0,,,,"I see that Bag implementations have a getCount() method that one would presume
is more efficient than iterating over the objects in the Collection.  Why
doesn't CollectionUtils.cardinality() take advantage of this?","Operating System: other
Platform: Other",,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,28629.0,,,2004-04-28 03:03:28.0,,,false,,,,,,,,,,,,,,18868,,,Wed Apr 28 03:03:28 UTC 2004,,,,,,0|i0sj53:,164578,,,,,,,,"27/Apr/04 21:38;jon.schewe@honeywell.com;The simple change for this would be:
public static int cardinality(Object obj, final Collection col) {
  if(col instanceof Bag) {
    return ((Bag)col).getCount(obj);
   } else {
     //put the current body here
   }
}","28/Apr/04 03:03;scolebourne@joda.org;Not done previously because no-one thought of it.

Special cases for Set and Bag have been added.

Thanks",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
[collections] Flat3Map.equals() bug,COLLECTIONS-129,12342242,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,stachoo@carrot-search.com,stachoo@carrot-search.com,15/May/05 01:27,15/Mar/08 21:36,07/Apr/19 20:37,15/Mar/08 21:36,,,,,,,,,,,,,,,0,,,,"Flat3Map.equals() fails a simple test:

    public void testEquals()
    {
        Flat3Map map = new Flat3Map();
        map.put(""a"", ""testA"");
        map.put(""b"", ""testB"");
        Flat3Map mapClone = new Flat3Map();
        mapClone.put(""a"", ""testB"");
        mapClone.put(""b"", ""testA"");
        
        assertFalse(""Maps should not be equal"", map.equals(mapClone));
    }

The code of Flat3Map.equals() is:

   public boolean equals(Object obj) {
        if (obj == this) {
            return true;
        }
        if (delegateMap != null) {
            return delegateMap.equals(obj);
        }
        if (obj instanceof Map == false) {
            return false;
        }
        Map other = (Map) obj;
        if (size != other.size()) {
            return false;
        }
        if (size > 0) {
            Object otherValue = null;
            switch (size) {  // drop through
                case 3:
                    if (other.containsKey(key3) == false) {
                        otherValue = other.get(key3);
                        if (value3 == null ? otherValue != null :
!value3.equals(otherValue)) {
                            return false;
                        }
                    }
                case 2:
                    if (other.containsKey(key2) == false) {
                        otherValue = other.get(key2);
                        if (value2 == null ? otherValue != null :
!value2.equals(otherValue)) {
                            return false;
                        }
                    }
                case 1:
                    if (other.containsKey(key1) == false) {
                        otherValue = other.get(key1);
                        if (value1 == null ? otherValue != null :
!value1.equals(otherValue)) {
                            return false;
                        }
                    }
            }
        }
        return true;
    }

while it should probably be:

   public boolean equals(Object obj) {
        if (obj == this) {
            return true;
        }
        if (delegateMap != null) {
            return delegateMap.equals(obj);
        }
        if (obj instanceof Map == false) {
            return false;
        }
        Map other = (Map) obj;
        if (size != other.size()) {
            return false;
        }
        if (size > 0) {
            Object otherValue = null;
            switch (size) {  // drop through
                case 3:
                    if (other.containsKey(key3)) {
                        otherValue = other.get(key3);
                        if (value3 == null ? otherValue != null :
!value3.equals(otherValue)) {
                            return false;
                        }
                    }
                case 2:
                    if (other.containsKey(key2)) {
                        otherValue = other.get(key2);
                        if (value2 == null ? otherValue != null :
!value2.equals(otherValue)) {
                            return false;
                        }
                    }
                case 1:
                    if (other.containsKey(key1)) {
                        otherValue = other.get(key1);
                        if (value1 == null ? otherValue != null :
!value1.equals(otherValue)) {
                            return false;
                        }
                    }
            }
        }
        return true;
    }

--
Stanislaw Osinski
http://www.carrot-search.com","Operating System: Windows XP
Platform: PC",,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,34917.0,,,2005-05-15 18:24:10.0,,,false,,,,,,,,,,,,,,18869,,,Sun May 15 18:24:10 UTC 2005,,,,,,0|i0sj5b:,164579,,,,,,,,"15/May/05 18:24;scolebourne@joda.org;Fix in SVN revision 170210, thanks for the report",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"[collections] IteratorChain - if first iterator empty, doesn't care about next ones.",COLLECTIONS-128,12341197,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,amorfis,amorfis,10/Jan/04 21:27,15/Mar/08 21:36,07/Apr/19 20:37,14/Jul/06 12:04,2.1,,,,,,,,,,,,,,1,,,,"If first Iterator in IteratorChain is empty, and next ones contain some
elements, first call to hasNext() on IteratorChain returns false. It should
return true if there are elements in other Iterators.","Operating System: All
Platform: PC",,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,26038.0,,,2004-01-10 22:35:48.0,,,false,,,,,,,,,,,,,,18870,,,Fri Jul 14 12:04:41 UTC 2006,,,,,,0|i0sj5j:,164580,,,,,,,,10/Jan/04 22:35;scolebourne@joda.org;Fixed in CVS already (duplicate report).,"22/Sep/04 18:04;droutsis@ebs.gr;I think this still applies. Witness following test code:

List emptyList = new ArrayList();
List nonEmptyList = new ArrayList();
nonEmptyList.add(new Object());
IteratorChain it = new IteratorChain(new Iterator[]
  {emptyList.iterator(), nonEmptyList.iterator()});
System.out.println(""Next? "" + it.hasNext()); // prints false
System.out.println(""Next again? "" + it.hasNext()); // prints true

Have tried this with both 3.0 and 3.1 releases.","23/Sep/04 05:20;scolebourne@joda.org;Tested against CVS and 3.0 and could not reproduce. Suggest you check your 
classpath for a rogue 2.1 jar file.

No action taken, call closed.",14/Jul/06 12:04;bayard;Reopen/reclose to deal with migration bug.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
[collections] Strong reference not really cleared in TestReference*Map testcases,COLLECTIONS-127,12342217,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,guilhem@kaffe.org,guilhem@kaffe.org,01/May/05 02:21,15/Mar/08 21:36,07/Apr/19 20:37,15/Mar/08 21:36,,,,,,,,,,,,,,,0,,,,"It seems TestReference*Map fail to remove completely the strong references in  
testPurgeValues because some optimization may be done for local variables by a  
JIT compiler. It may be seen with CVS head of the kaffe VM. I suggest to modify  
the testcases using the attached patch. It makes sure that no optimized local  
variables are still on the stack. The bug is present in the head of SVN tree 
(2005-04-30). It is fully reproduceable on kaffe VM (2005-04-30) with JIT3/x86.","Operating System: All
Platform: All",,,,,,,,,,,,,,,,,,01/May/05 02:26;guilhem@kaffe.org;ASF.LICENSE.NOT.GRANTED--ref-collection.patch;https://issues.apache.org/jira/secure/attachment/12333496/ASF.LICENSE.NOT.GRANTED--ref-collection.patch,,,,,,,,,1.0,,,,,,,,,,,,,,,,34689.0,,,2005-05-08 02:28:51.0,,,false,,,,,,,,,,,,,,18871,,,Sun May 08 02:28:51 UTC 2005,,,,,,0|i0sj5r:,164581,,,,,,,,"01/May/05 02:26;guilhem@kaffe.org;Created an attachment (id=14884)
Introduce an auxiliary function for building weak references

If you use an auxiliary function to build the weak references and the map you
make sure that no optimization of the stack is possible. At the exit of
buildRefMap you only have weak references on the stack.","08/May/05 02:28;scolebourne@joda.org;Patch applied, thanks
SVN revision 169101",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
[patch] JDK 1.4.1 compil error / TestHashMap.java  does not define makeEmptyMap() in org.apache.commons.collections.TestMap,COLLECTIONS-126,12340273,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Incomplete,,jari.aalto@cante.net,jari.aalto@cante.net,23/Jul/02 23:14,15/Mar/08 21:36,07/Apr/19 20:37,15/Mar/08 21:36,Nightly Builds,,,,,,,,,,,,,,0,,,,"Environment:

Win32 W2kSp2 / cygwin
Win32 JDK 1.4.1
CVS ant
CVS jakarta-commons

There is problem with compiling. See attached patch, which I AM NOT
SURE if it is correct solution. At least it builds without this error.

- jari

root@W2KPICASSO:/cygdrive/d/java/apache/cvs/jakarta-commons/collections$ ant.bat
Buildfile: build.xml

init:

build-java:

build-test:
    [javac] Compiling 62 source files to D:\java\apache\cvs\jakarta-
commons\collections\dist\classes
    [javac] D:\java\apache\cvs\jakarta-
commons\collections\src\test\org\apache\commons\collections\TestHashMap.java:74:
 org.apache.commons.collections.TestHashMap should be declared abstract; it 
does not define makeEmptyMap() in org.apache.commons.collections.TestMap
    [javac] public class TestHashMap extends TestMap
    [javac]        ^
    [javac] 1 error

BUILD FAILED
file:d:/java/apache/cvs/jakarta-commons/collections/build.xml:216: Compile 
failed; see the compiler error output for details.

Total time: 20 seconds

==========================================================================

root@W2KPICASSO:/cygdrive/d/java/apache/cvs/jakarta-commons/collections$ diff -
u src/test/org/apache/commons/collections/TestHashMap.java.orig 
src/test/org/apache/commons/collections/TestHashMap.java
--- src/test/org/apache/commons/collections/TestHashMap.java.orig       2001-07-
15 01:33:28.000000000 +0300
+++ src/test/org/apache/commons/collections/TestHashMap.java    2002-07-23 
13:45:34.000000000 +0300
@@ -94,6 +94,11 @@
         return (hm);
     }
 
+    public Map makeEmptyMap()
+    {
+        return makeMap();
+    }
+
     protected HashMap map = null;
 
     public void setUp()","Operating System: All
Platform: PC",,,,,,,,,,,,,,,,,,23/Jun/03 23:49;janekdb@yahoo.co.uk;ASF.LICENSE.NOT.GRANTED--object-creation-reduction.txt;https://issues.apache.org/jira/secure/attachment/12331994/ASF.LICENSE.NOT.GRANTED--object-creation-reduction.txt,,,,,,,,,1.0,,,,,,,,,,,,,,,,11092.0,,,2002-08-10 07:56:55.0,,,false,,,,,,,,,,,,,,18872,,,Mon Jun 23 23:52:06 UTC 2003,,,,,,0|i0sj5z:,164582,,,,,,,,"10/Aug/02 07:56;pjack@sfaf.org;The TestHashMap.java file was removed from the repository on 2002/06/18
05:41:11, because it is no longer needed.  ","23/Jun/03 23:49;janekdb@yahoo.co.uk;Created an attachment (id=6938)
This patch replaces creation of Boolean objects with references to TRUE and FALSE
",23/Jun/03 23:52;janekdb@yahoo.co.uk;Please ignore attachment (id=6938). It was attached to the wrong bug.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
[collections] [PATCH] MapUtils JavaDoc fixes,COLLECTIONS-125,12340946,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Minor,Fixed,,janekdb@yahoo.co.uk,janekdb@yahoo.co.uk,08/Sep/03 04:35,15/Mar/08 21:36,07/Apr/19 20:37,15/Mar/08 21:36,Nightly Builds,,,,,,,,,,,,,,0,,,,"The attached patch modifies some documentation tags and fixes the code example
for MapUtils.lazySortedMap.","Operating System: other
Platform: Other",,,,,,,,,,,,,,,,,,08/Sep/03 04:37;janekdb@yahoo.co.uk;ASF.LICENSE.NOT.GRANTED--MapUtils-JavaDoc.patch;https://issues.apache.org/jira/secure/attachment/12332506/ASF.LICENSE.NOT.GRANTED--MapUtils-JavaDoc.patch,,,,,,,,,1.0,,,,,,,,,,,,,,,,22972.0,,,2003-09-10 04:08:55.0,,,false,,,,,,,,,,,,,,18873,,,Wed Sep 10 04:08:55 UTC 2003,,,,,,0|i0sj67:,164583,,,,,,,,"08/Sep/03 04:37;janekdb@yahoo.co.uk;Created an attachment (id=8094)
JavaDoc fixes for MapUtils v 1.32
","10/Sep/03 04:08;scolebourne@joda.org;Patch applied, thanks",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
[collections][PATCH] SetUniqueList breaks when swapping entries,COLLECTIONS-124,12342021,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,thomas.dunham@reuters.com,thomas.dunham@reuters.com,29/Jan/05 04:15,15/Mar/08 21:36,07/Apr/19 20:37,15/Mar/08 21:36,3.1,,,,,,,,,,,,,,0,,,,"If you create a SetUniqueList with two entries a and b:
[a,b]
Then you do:
Object a = l.get(0);
l.set(0, b)
l.add(0, a);
You expect to have swapped the two entries. But you get
[b]
Which seems to be wrong.","Operating System: All
Platform: PC",,,,,,,,,,,,,,,,,,29/Jan/05 04:34;thomas.dunham@reuters.com;ASF.LICENSE.NOT.GRANTED--code.patch;https://issues.apache.org/jira/secure/attachment/12333369/ASF.LICENSE.NOT.GRANTED--code.patch,29/Jan/05 04:18;thomas.dunham@reuters.com;ASF.LICENSE.NOT.GRANTED--setUniqBug.txt;https://issues.apache.org/jira/secure/attachment/12333367/ASF.LICENSE.NOT.GRANTED--setUniqBug.txt,29/Jan/05 04:34;thomas.dunham@reuters.com;ASF.LICENSE.NOT.GRANTED--test.patch;https://issues.apache.org/jira/secure/attachment/12333368/ASF.LICENSE.NOT.GRANTED--test.patch,,,,,,,3.0,,,,,,,,,,,,,,,,33294.0,,,2005-02-04 09:13:50.0,,,false,,,,,,,,,,,,,,18874,,,Fri Feb 04 09:13:50 UTC 2005,,,,,,0|i0sj6f:,164584,,,,,,,,"29/Jan/05 04:18;thomas.dunham@reuters.com;Created an attachment (id=14128)
This TestCase shows the problem from outwith the packages.
","29/Jan/05 04:34;thomas.dunham@reuters.com;Created an attachment (id=14129)
This patch to TestSetUniqueList exposes the bug.
","29/Jan/05 04:34;thomas.dunham@reuters.com;Created an attachment (id=14130)
This patch to SetUniqueList passes the tests
","04/Feb/05 09:13;scolebourne@joda.org;Patches applied, thanks",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
[collections] StaticBucketMap#containsKey(final Object key) can return illegal value.,COLLECTIONS-123,12342724,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,ujihara@aurora.dti.ne.jp,ujihara@aurora.dti.ne.jp,20/Nov/05 18:18,15/Mar/08 21:36,07/Apr/19 20:37,15/Mar/08 21:36,3.1,,,,,,,,,,,,,,0,,,,"org.apache.commons.collections.map.StaticBucketMap#containsKey(""any string"") 
can return true by mistake when null key is containing in buckets.
I think containsKey(Object) method has to be modified like the following.

    public boolean containsKey(final Object key) {
        int hash = getHash(key);

        synchronized (locks[hash]) {
            Node n = buckets[hash];

            while (n != null) {
-                if (n.key == null || (n.key != null && n.key.equals(key))) {
+                if ((n.key == null && key == null) || (n.key != null && 
n.key.equals(key))) {
                    return true;
                }

                n = n.next;
            }
        }
        return false;
    }

Kazuya Ujihara","Operating System: Windows XP
Platform: All",,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,37567.0,,,2005-11-23 07:28:49.0,,,false,,,,,,,,,,,,,,18875,,,Wed Nov 23 07:28:49 UTC 2005,,,,,,0|i0sj6n:,164585,,,,,,,,23/Nov/05 07:28;scolebourne@joda.org;Thanks for the bug report and fix. Applied on SVN.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
[collections] CircularFifoBuffer not really Serializable,COLLECTIONS-122,12341754,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,kalle.gustafsson@compingo.se,kalle.gustafsson@compingo.se,27/Sep/04 14:24,15/Mar/08 21:36,07/Apr/19 20:37,15/Mar/08 21:36,3.1,,,,,3.2,,,,,,,,,0,,,,"Create a CircularFifoBuffer of size N. Serialize and deserialize a couple of
times. When adding element N+1, an error occurs. (OutOfMemoryError in our
testing environment, ArrayIndexOutOfBounds when running the code snippet.)

The error can be reproduced by running the following code snippet in a scrapbook
page in WebSphere Studio 5.1.2 (default JRE) on Windows XP (The error occurs at
the third add operation):

org.apache.commons.collections.buffer.CircularFifoBuffer b = new
org.apache.commons.collections.buffer.CircularFifoBuffer(2);

b.add(""a"");

java.io.ByteArrayOutputStream bos = new java.io.ByteArrayOutputStream();
new java.io.ObjectOutputStream(bos).writeObject(b);

org.apache.commons.collections.buffer.CircularFifoBuffer b2 =
(org.apache.commons.collections.buffer.CircularFifoBuffer) new
java.io.ObjectInputStream(new
java.io.ByteArrayInputStream(bos.toByteArray())).readObject();

b2.add(""b"");

bos = new java.io.ByteArrayOutputStream();
new java.io.ObjectOutputStream(bos).writeObject(b2);

b = (org.apache.commons.collections.buffer.CircularFifoBuffer) new
java.io.ObjectInputStream(new
java.io.ByteArrayInputStream(bos.toByteArray())).readObject();

b.add(""c"");

bos = new java.io.ByteArrayOutputStream();
new java.io.ObjectOutputStream(bos).writeObject(b);

b2 = (org.apache.commons.collections.buffer.CircularFifoBuffer) new
java.io.ObjectInputStream(new
java.io.ByteArrayInputStream(bos.toByteArray())).readObject();","Operating System: Solaris
Platform: Sun",,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,31433.0,,,2004-10-17 05:26:53.0,,,false,,,,,,,,,,,,,,18876,,,Tue Nov 22 08:43:46 UTC 2005,,,,,,0|i0sj6v:,164586,,,,,,,,"17/Oct/04 05:26;scolebourne@joda.org;Thanks for this bug report.

This problem only occurs when serializing a full BoundedFifoBuffer or 
CircularFifoBuffer. CVS is now fixed.",22/Nov/05 08:43;scolebourne@joda.org;*** COM-2570 has been marked as a duplicate of this bug. ***,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
[Collections] Improvements to maven build,COLLECTIONS-121,12342614,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,carlos,carlos,11/Oct/05 08:07,15/Mar/08 21:36,07/Apr/19 20:37,15/Mar/08 21:36,,,,,,,,,,,,,,,0,,,,"Improvements to project.xml updating deprecated tags and making it easier for
maven 2 users.","Operating System: other
Platform: Other",,,,,,,,,,,,,,,,,,11/Oct/05 08:07;carlos;ASF.LICENSE.NOT.GRANTED--collections.patch;https://issues.apache.org/jira/secure/attachment/12333840/ASF.LICENSE.NOT.GRANTED--collections.patch,,,,,,,,,1.0,,,,,,,,,,,,,,,,37012.0,,,,,,false,,,,,,,,,,,,,,18877,,,Tue Oct 11 08:07:45 UTC 2005,,,,,,0|i0sj73:,164587,,,,,,,,"11/Oct/05 08:07;carlos;Created an attachment (id=16646)
A patch for current code in svn
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
BeanMap.toString() causes infinite loop on circular object graph,COLLECTIONS-120,12340667,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,mhawthorne@alumni.pitt.edu,mhawthorne@alumni.pitt.edu,17/Apr/03 04:46,15/Mar/08 21:36,07/Apr/19 20:37,15/Mar/08 21:36,2.1,,,,,,,,,,,,,,0,,,,This problem is similar to the one in [lang]'s ToStringBuilder.,"Operating System: Linux
Platform: Other",,,,,,,,,,,,,,,,,,19/Apr/03 00:09;mohankishore@yahoo.com;ASF.LICENSE.NOT.GRANTED--Patch.txt;https://issues.apache.org/jira/secure/attachment/12332236/ASF.LICENSE.NOT.GRANTED--Patch.txt,,,,,,,,,1.0,,,,,,,,,,,,,,,,19096.0,,,2003-04-18 07:28:30.0,,,false,,,,,,,,,,,,,,18878,,,Sat Apr 19 06:33:57 UTC 2003,,,,,,0|i0sj7b:,164588,,,,,,,,"18/Apr/03 07:28;rwaldhoff@apache.org;Any thoughts on what the proper behavior should be?  Output nothing for the
second reference?  Output something like what the default Object.toString does?","18/Apr/03 20:38;mhawthorne@alumni.pitt.edu;I definitely think that it should output something.  Maybe the default
Object.toString() content, along with an indicator that the object was already
printed out earlier in the process?","19/Apr/03 00:09;mohankishore@yahoo.com;Created an attachment (id=5891)
Proposed implementation - will it help?
","19/Apr/03 00:12;mohankishore@yahoo.com;Have added a proposed implementation. It should help where the cyclic behavior 
is due to the values (or keys) pointing to parent list/map. If the embeded 
objects toString methods are implemented in a manner that causes cyclic loop, 
imho, we cant do anything about it.

btw, my proposal is not specific to this class - might be moved to a more 
generic class, and the list/map implementations can use the utility method.","19/Apr/03 06:00;rwaldhoff@apache.org;My mistake.  I had assumed BeanMap defined some specific toString() method.  Why
don't we just drop down to bean.toString() or ""Map<"" + bean.toString() + "">"" or
something like that?","19/Apr/03 06:15;mohankishore@yahoo.com;BeanMap< bean.toString() > sounds good to me.

JDK collection classes dont check for cyclic references either...
Ran a test program:
        Map m = new HashMap();
        m.put(""1"", ""One"");
        m.put(""2"", m);
        m.put(""3"", ""Three"");
        System.out.println(m);

Output:
Exception in thread ""main"" java.lang.StackOverflowError
        at java.util.AbstractMap.toString(AbstractMap.java:559)
        at java.lang.String.valueOf(String.java:2013)
        at java.lang.StringBuffer.append(StringBuffer.java:365)
        at java.util.AbstractMap.toString(AbstractMap.java:562)
        at java.lang.String.valueOf(String.java:2013)
        at java.lang.StringBuffer.append(StringBuffer.java:365)
        at java.util.AbstractMap.toString(AbstractMap.java:562)
        ...
",19/Apr/03 06:33;rwaldhoff@apache.org;BeanMap< bean.toString() > it is.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
[collections] Misnamed method in FixedOrderComparator: getUnkownObjectBehavior,COLLECTIONS-119,12340939,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,janekdb@yahoo.co.uk,janekdb@yahoo.co.uk,31/Aug/03 08:45,15/Mar/08 21:36,07/Apr/19 20:37,15/Mar/08 21:36,Nightly Builds,,,,,,,,,,,,,,0,,,,"The method is probably meant to be getUnknownObjectBehavior()

From the class:

FixedOrderComparator {

    ...

    /** 
     * Gets the behavior for comparing unknown objects.
     */
    public int getUnkownObjectBehavior() {
        return unknownObjectBehavior;
    }

    ...
}","Operating System: other
Platform: Other",,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,22844.0,,,2003-08-31 21:40:45.0,,,false,,,,,,,,,,,,,,18879,,,Sun Aug 31 21:40:45 UTC 2003,,,,,,0|i0sj7j:,164589,,,,,,,,"31/Aug/03 21:40;scolebourne@joda.org;Change made, thanks",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
[collections] LRUMap.removeLRU(LinkEntry) is passed wrong link entry,COLLECTIONS-118,12341405,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,msage@kelvinconnect.com,msage@kelvinconnect.com,16/Apr/04 20:51,15/Mar/08 21:36,07/Apr/19 20:37,15/Mar/08 21:36,3.0,,,,,,,,,,,,,,0,,,,"The following program attempts to add 3 entries (a,b,c) to an LRUMap with max 
size two.

The contents of the LRUMap are always correct but when the LRUMap fills up it 
removes entry ""a"" but passes entry ""b"" to the removeLRU method.

run:
     [java] [a]
     [java] [a, b]
     [java] Remove lru b
     [java] [b, c]

import org.apache.commons.collections.map.LRUMap;

public class LRUMapTest {
    public static void main (String[] args) {
	LRUMap map = new LRUMap(2) {
		protected boolean removeLRU(LinkEntry entry) {
		    System.out.println(""Remove lru ""+entry.getKey());
		    return true;
		}
	    };
	map.put(""a"",""a"");
	System.out.println(map.keySet());
	map.put(""b"",""b"");
	System.out.println(map.keySet());
	map.put(""c"",""c"");
	System.out.println(map.keySet());
    }
}","Operating System: Windows XP
Platform: PC",,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,28433.0,,,2004-04-17 06:55:59.0,,,false,,,,,,,,,,,,,,18880,,,Sat Apr 17 06:55:59 UTC 2004,,,,,,0|i0sj7r:,164590,,,,,,,,"17/Apr/04 06:55;scolebourne@joda.org;Quite true, good catch. Bug fixed in CVS, thanks.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
[collections][PATCH] correct misspelling in RELEASE-NOTES.html,COLLECTIONS-117,12342835,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Trivial,Fixed,,gudnabrsam@yahoo.com,gudnabrsam@yahoo.com,06/Jan/06 02:45,15/Mar/08 21:36,07/Apr/19 20:37,15/Mar/08 21:36,Nightly Builds,,,,,,,,,,,,,,0,,,,s/COMPATABILITY/COMPATIBILITY/,"Operating System: other
Platform: Other",,,,,,,,,,,,,,,,,,06/Jan/06 02:46;gudnabrsam@yahoo.com;ASF.LICENSE.NOT.GRANTED--relnotes.patch.txt;https://issues.apache.org/jira/secure/attachment/12333972/ASF.LICENSE.NOT.GRANTED--relnotes.patch.txt,,,,,,,,,1.0,,,,,,,,,,,,,,,,38140.0,,,2006-01-07 06:38:50.0,,,false,,,,,,,,,,,,,,18881,,,Sat Jan 07 06:38:50 UTC 2006,,,,,,0|i0sj7z:,164591,,,,,,,,"06/Jan/06 02:46;gudnabrsam@yahoo.com;Created an attachment (id=17343)
release notes patch
",07/Jan/06 06:38;scolebourne@joda.org;Thanks,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
[collections] Getting rid of some javadoc warn messages (3.2-dev),COLLECTIONS-116,12341769,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Minor,Fixed,,public@ecopatz.de,public@ecopatz.de,04/Oct/04 06:07,15/Mar/08 21:36,07/Apr/19 20:37,15/Mar/08 21:36,3.2,,,,,3.2,,,,,,,,,0,,,,"Salut. 

Just called javadoc to create the java documentation and wondered about
some warnings, though everything seemed to be at the right place:

Tag @link: can't find removeLRU(LinkEntry) in
org.apache.commons.collections.map.LRUMap
Tag @link: can't find moveToMRU(LinkEntry) in
org.apache.commons.collections.map.LRUMap

""LinkEntry"" is a static class in AbstractLinkedMap, LRUMap derives from
AbstractLinkedMap. Why javadoc does not know about ""LinkEntry"" then, while
java itself does?

The solution comes from the javadoc-API:

""Nested classes must be specified as outer.inner, not simply inner, for all forms.""

(http://java.sun.com/j2se/1.4.2/docs/tooldocs/solaris/javadoc.html#@see)

That is the reason, why javadoc spews warnings, when {@link
#removeLRU(LinkEntry)} is used. 

The correct code will look like this then:

{@link #removeLRU(AbstractLinkedMap.LinkEntry)}

Actually i have found this only in collections.map.LRUMap, its really a minor
thing. But even Eclipse gave me the ""wrong"" code...

Thanks for the collections, we use them intensily here :-)

Ciao.","Operating System: other
Platform: Other",,,,,,,,,,,,,,,,,,18/Oct/04 05:17;public@ecopatz.de;ASF.LICENSE.NOT.GRANTED--AbstractInputCheckedMapDecorator-javadocfix.txt;https://issues.apache.org/jira/secure/attachment/12333148/ASF.LICENSE.NOT.GRANTED--AbstractInputCheckedMapDecorator-javadocfix.txt,07/Oct/04 05:03;public@ecopatz.de;ASF.LICENSE.NOT.GRANTED--BooleanComparator-javadocfix.txt;https://issues.apache.org/jira/secure/attachment/12333141/ASF.LICENSE.NOT.GRANTED--BooleanComparator-javadocfix.txt,07/Oct/04 03:41;public@ecopatz.de;ASF.LICENSE.NOT.GRANTED--LRUMap-javadocfix.txt;https://issues.apache.org/jira/secure/attachment/12333140/ASF.LICENSE.NOT.GRANTED--LRUMap-javadocfix.txt,07/Oct/04 06:35;public@ecopatz.de;ASF.LICENSE.NOT.GRANTED--MultiKeyMap-javadocfix.txt;https://issues.apache.org/jira/secure/attachment/12333144/ASF.LICENSE.NOT.GRANTED--MultiKeyMap-javadocfix.txt,07/Oct/04 06:31;public@ecopatz.de;ASF.LICENSE.NOT.GRANTED--ReferenceIdentityMap-javadocfix.txt;https://issues.apache.org/jira/secure/attachment/12333142/ASF.LICENSE.NOT.GRANTED--ReferenceIdentityMap-javadocfix.txt,07/Oct/04 06:31;public@ecopatz.de;ASF.LICENSE.NOT.GRANTED--ReferenceMap-javadocfix.txt;https://issues.apache.org/jira/secure/attachment/12333143/ASF.LICENSE.NOT.GRANTED--ReferenceMap-javadocfix.txt,07/Oct/04 06:44;public@ecopatz.de;ASF.LICENSE.NOT.GRANTED--SingletonMap-javadocfix.txt;https://issues.apache.org/jira/secure/attachment/12333145/ASF.LICENSE.NOT.GRANTED--SingletonMap-javadocfix.txt,18/Oct/04 05:15;public@ecopatz.de;ASF.LICENSE.NOT.GRANTED--TreeBidiMap-javadocfix.txt;https://issues.apache.org/jira/secure/attachment/12333146/ASF.LICENSE.NOT.GRANTED--TreeBidiMap-javadocfix.txt,18/Oct/04 05:16;public@ecopatz.de;ASF.LICENSE.NOT.GRANTED--TreeList-javadocfix.txt;https://issues.apache.org/jira/secure/attachment/12333147/ASF.LICENSE.NOT.GRANTED--TreeList-javadocfix.txt,9.0,,,,,,,,,,,,,,,,31519.0,,,2004-10-17 04:43:55.0,,,false,,,,,,,,,,,,,,18882,,,Tue Jan 04 08:54:15 UTC 2005,,,,,,0|i0sj87:,164592,,,,,,,,"07/Oct/04 03:41;public@ecopatz.de;Created an attachment (id=12970)
replacing javadoc statements in two methods
","07/Oct/04 05:02;public@ecopatz.de;The next patch is related to the BooleanComparator class.

Some public methods in that class refer in their javadoc comments to the private
variable 'trueFirst'.

Since the default package access in the build.xml is set to ""protected"", the
javadoc generator will not see this private variable and gives warnings. The
result is incomplete documentation (broken sentences...)

But hey, there is the public method #sortsTrueFirst, to which these methods can
refer to.

So, this simple beauty patch just rewrites the javadoc comments a bit.

","07/Oct/04 05:03;public@ecopatz.de;Created an attachment (id=12972)
BooleanComparator: Little rewrite of javadoc comments to avoid refering to a private variable
","07/Oct/04 06:26;public@ecopatz.de;The following three patches touches MultiKeyMap, ReferenceIdentityMap and
ReferenceMap.

Just added full qualified names to linked classes, if they havent been
explicitely imported from the source files.
","07/Oct/04 06:31;public@ecopatz.de;Created an attachment (id=12973)
ReferenceIdentityMap: Adding full qualified names to classes, which have not been imported explictely
","07/Oct/04 06:31;public@ecopatz.de;Created an attachment (id=12974)
ReferenceMap: Adding full qualified names to classes, which have not been imported explictely
","07/Oct/04 06:34;public@ecopatz.de;Ups, i was wrong. The 3rd patch, the one for MultiKeyMap, fixes the javadoc code
for the method putAll(Map), that referenced non existing parameters.

","07/Oct/04 06:35;public@ecopatz.de;Created an attachment (id=12975)
MultiKeyMap: Fixed wrong parameters in javadoc for method putAll
","07/Oct/04 06:44;public@ecopatz.de;Created an attachment (id=12976)
SingletonMap: Fixes javadoc for constructor SingletonMap(MapEntry)
","17/Oct/04 04:43;scolebourne@joda.org;Thanks for these javadoc patches, documentation patches are always useful!","18/Oct/04 05:13;public@ecopatz.de;Salve.

If i may re-open the bug.

I have changed the property 'javadoc.access' from the value 'protected' to 
'private' to see, if javadoc runs clean now. Just got some other warnings.

The first ""fix"" is for 'TreeBidiMap.java' in 'collections/bidimap'. I have
changed the parameter name from 'index' to 'type' in the javadoc code from three
methods, because the variable is named 'type' there.

The second ""fix"" is for 'AbstractInputCheckedMapDecorator.java'. Just removed
the javadoc tag '@param value' for the method 'isSetValueChecking', since this
method has no parameter at all. 

The third ""fix"" is for 'TreeList.java' in 'collections/list'. But here it is a
bit ambigious. The comment for the field 'AVLNode current' from the inner class
'TreeListIterator' mentions the method #getLastNodeReturned(). There is no such
method, thats why the javadoc warning raises. Will such a method ever be written
there to access 'current'? For example, the 'LinkedListIterator' in
'AbstractLinkedList' has such a method. I 

Okay, whatever, i dont see a note, that this method will come. So i just deleted
the comment about #getLastNodeReturned()

=;","18/Oct/04 05:15;public@ecopatz.de;Created an attachment (id=13126)
TreeBidiMap: Changing @param index to @param type in some methods
","18/Oct/04 05:16;public@ecopatz.de;Created an attachment (id=13127)
TreeList: Removing the mention of #getLastNodeReturned, because there is no such method (yet?) in the TreeListIterator
","18/Oct/04 05:17;public@ecopatz.de;Created an attachment (id=13128)
AbstractInputCheckedMapDecorator: Removed @param value in isSetValueChecking, because this method has no argument
","04/Jan/05 08:54;scolebourne@joda.org;Patches applied, thanks.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Flat3Map doesn't implement Serializable,COLLECTIONS-115,12341367,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,manik@surtani.org,manik@surtani.org,25/Mar/04 22:39,14/Jul/06 05:44,07/Apr/19 20:37,14/Jul/06 05:44,3.0,,,,,3.1,,,,,,,,,0,,,,"A very useful hish performance map.  Sadly I cannot use it in my J2EE env
because it isn't seriabilable and hence cannot be a parameter in any remote calls.

Is there a specific reason as to why this isn't Serializable, or was this
something that was overlooked?","Operating System: Linux
Platform: All",,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,27946.0,,,2004-04-01 07:20:57.0,,,false,,,,,,,,,,,,,,18883,,,Fri Apr 02 03:15:04 UTC 2004,,,,,,0|i0sj8f:,164593,,,,,,,,"01/Apr/04 07:20;scolebourne@joda.org;Serialization is usually more complex than just adding 'implements 
Serializable'. In this case, a dedicated read/write was needed. Its done on CVS 
now anyway ;-)","01/Apr/04 18:40;manik@surtani.org;Stephen,

I just had a look at the latest source in CVS (Rev. 1.14), and the 3 hashes,
keys and values are all marked as transient.  Would this cause any problems when
reading the Map back from a serialized stream?

Cheers,
Manik

","02/Apr/04 03:15;scolebourne@joda.org;There are dedicated readObject() and writeObject() methods, plus unit tests. 
See the Sun serialization tutorials for more details.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
[collections] Build Warnings when building under JDK 1.5,COLLECTIONS-114,12342334,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,willpugh,willpugh,23/Jun/05 03:36,15/Mar/08 21:36,07/Apr/19 20:37,15/Mar/08 21:36,Nightly Builds,,,,,,,,,,,,,,0,,,,"When I build under JDK 1.5 on MacOSX, I get a bunch of warnings.  Almost all of
them are a result of some APIs moving over to using varargs.  Here is an example
of some of the warnings.  The fixes in just about all cases was to cast a null
to either (Method[]) or (Object[]).  in one place a temporary array new String[]
{ ... } had to be changed to new Object[] { ... }

    [javac] Compiling 271 source files to
/Users/willpugh/projects/beanutils2/collections2/collections/target/classes
/Users/willpugh/projects/beanutils2/collections2/collections/src/java/org/apache/commons/collections/functors/PrototypeFactory.java:62:
warning: non-varargs call of varargs method with inexact argument type for last
parameter;
cast to java.lang.Class for a varargs call
cast to java.lang.Class[] for a non-varargs call and to suppress this warning
            Method method = prototype.getClass().getMethod(""clone"", null);
                                                                    ^
/Users/willpugh/projects/beanutils2/collections2/collections/src/java/org/apache/commons/collections/functors/PrototypeFactory.java:119:
warning: non-varargs call of varargs method with inexact argument type for last
parameter;
cast to java.lang.Class for a varargs call
cast to java.lang.Class[] for a non-varargs call and to suppress this warning
                iCloneMethod = iPrototype.getClass().getMethod(""clone"", null);
                        
. . .","Operating System: other
Platform: Other",,,,,,,,,,,,,,,,,,23/Jun/05 03:37;willpugh;ASF.LICENSE.NOT.GRANTED--fixWarnings;https://issues.apache.org/jira/secure/attachment/12333593/ASF.LICENSE.NOT.GRANTED--fixWarnings,,,,,,,,,1.0,,,,,,,,,,,,,,,,35474.0,,,2005-06-26 01:41:28.0,,,false,,,,,,,,,,,,,,18884,,,Sun Jun 26 01:41:28 UTC 2005,,,,,,0|i0sj8n:,164594,,,,,,,,"23/Jun/05 03:37;willpugh;Created an attachment (id=15518)
Patch file with fixes
","26/Jun/05 01:41;scolebourne@joda.org;Applied in SVN 201765

Note however, that we don't have formal JDK1.5 tests/compilation, so these
errors may re-occur.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
[collections] ExtendedProperties#convertProperties doesn't inherit defaults.,COLLECTIONS-113,12341867,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,shinobu,shinobu,13/Nov/04 00:44,02/May/13 02:28,07/Apr/19 20:37,15/Mar/08 21:36,3.1,,,,,,,,,,,,,,0,,,,"ExtendedProperties#convertProperties() uses props.keys() instead of 
props.propertyNames(), causing the defaults properties to be discarded.","Operating System: other
Platform: Other",,,,,,,,,,,,,,,,,VELOCITY-333,13/Nov/04 00:49;shinobu;ASF.LICENSE.NOT.GRANTED--ExtendedProperties.defaults.patch;https://issues.apache.org/jira/secure/attachment/12333232/ASF.LICENSE.NOT.GRANTED--ExtendedProperties.defaults.patch,01/Dec/04 17:51;shinobu;ASF.LICENSE.NOT.GRANTED--ExtendedProperties.defaults.test.patch;https://issues.apache.org/jira/secure/attachment/12333233/ASF.LICENSE.NOT.GRANTED--ExtendedProperties.defaults.test.patch,,,,,,,,2.0,,,,,,,,,,,,,,,,32204.0,,,2005-05-23 08:05:19.0,,,false,,,,,,,,,,,,,,18885,,,Mon May 23 08:05:19 UTC 2005,,,,,,0|i0sj8v:,164595,,,,,,,,"13/Nov/04 00:49;shinobu;Created an attachment (id=13418)
Patch to fix bug.
","01/Dec/04 17:51;shinobu;Created an attachment (id=13605)
Patch for the test.
","23/May/05 08:05;scolebourne@joda.org;Patches applied, thanks",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
[collections] [PATCH] fixes some @author hrefs or removes the link markup,COLLECTIONS-112,12340944,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Minor,Fixed,,janekdb@yahoo.co.uk,janekdb@yahoo.co.uk,07/Sep/03 06:43,15/Mar/08 21:36,07/Apr/19 20:37,15/Mar/08 21:36,Nightly Builds,,,,,,,,,,,,,,0,,,,"The attached patches are mutually exclusive and either fix some hrefs in some
@author tags which are missing 'mailto:' prefixes or (to match a recently
applied collections patch) remove the link markup altogether.","Operating System: other
Platform: Other",,,,,,,,,,,,,,,,,,07/Sep/03 06:45;janekdb@yahoo.co.uk;ASF.LICENSE.NOT.GRANTED--href-mailto-patch.txt;https://issues.apache.org/jira/secure/attachment/12332503/ASF.LICENSE.NOT.GRANTED--href-mailto-patch.txt,07/Sep/03 06:47;janekdb@yahoo.co.uk;ASF.LICENSE.NOT.GRANTED--href-no-mailto-patch.txt;https://issues.apache.org/jira/secure/attachment/12332504/ASF.LICENSE.NOT.GRANTED--href-no-mailto-patch.txt,,,,,,,,2.0,,,,,,,,,,,,,,,,22962.0,,,2003-09-07 15:51:36.0,,,false,,,,,,,,,,,,,,18886,,,Sun Sep 07 15:51:36 UTC 2003,,,,,,0|i0sj93:,164596,,,,,,,,"07/Sep/03 06:45;janekdb@yahoo.co.uk;Created an attachment (id=8084)
Adds missing 'mailto:' prefixes
","07/Sep/03 06:47;janekdb@yahoo.co.uk;Created an attachment (id=8085)
Removes HTML markup from @author tags
","07/Sep/03 15:51;scolebourne@joda.org;Patch applied, thanks",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
IteratorChain skips over elements in iterator,COLLECTIONS-111,12342870,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Cannot Reproduce,,jo@jogiles.co.nz,jo@jogiles.co.nz,21/Jan/06 10:12,28/Feb/13 19:52,07/Apr/19 20:37,19/Mar/08 06:52,3.1,,,,,,,,Iterator,,,,,,0,,,,"Hi there,
When using the IteratorChain class to add multiple iterators, it appears that
using itChain.hasNext() and itChain.next() skips a number of elements in the
iterator at each step.

Given a single iterator of 7 elements, and using the following code:

private IteratorChain buildIterator() {
// this iterator contains the children of the current object only
Iterator it = getChildren(p);
		
// we use an IteratorChain to add multiple iterators together without the
overhead of copying
IteratorChain itChain = new IteratorChain(it);

return itChain;
}

and then simply
IteratorChain it = treeModel.getAllTreeNodes(obj);
	
// FIXME this only prints one or two of the results, which is a bug!
while (it.hasNext())
    System.out.println("": "" + it.next().getClass());

I put in 7 elements, but only get 2 out - the 2nd and the last elements. It
appears that through my debugging that the nextClause variable is updated even
when the hasNext() function is called.

Also, if I put 7 system.out.println statements, all elements are printed as normal.","Operating System: Windows XP
Platform: PC",,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,38341.0,,,2006-01-21 10:52:04.0,,,false,,,,,,,,,,,,,,18887,,,Wed Mar 19 06:52:30 UTC 2008,,,,,,0|i0sj9b:,164597,,,,,,,,"21/Jan/06 10:24;jo@jogiles.co.nz;As an update, I have just downloaded and tried using Collections 2.1.1 - that
works as expected. I will investigate the differences and try to post a patch.","21/Jan/06 10:34;jo@jogiles.co.nz;(In reply to comment #0)
Replacing the updateCurrentIterator() method from the 3.1 package with the one
from 2.1 fixes this bug. Can someone investigate whether this is possible and
let me know?",21/Jan/06 10:52;scolebourne@joda.org;Can you build a test case to demonstrate the problem? Thanks,"21/Jan/06 11:05;jo@jogiles.co.nz;(In reply to comment #3)
Hi there - I have tried - and I can't reproduce it outside of my environment.
But as I say, I now have two snapshots in my system, and I replace the method in
3.1 with the one from 2.1, it works exactly as expected.

However, doing so causes the current test cases to fail in two areas:
testFurstIteratorIsEmptyBug()
testEmptyChain()

My simple test case works under both 3.1 or 2.1.1 however. It is:
    public void testSize() {
    	// we know that the size is 6 elements, so lets ensure that is correct
    	Iterator iter = makeFullIterator();
    	int i = 0;
    	while (iter.hasNext()) {
    		++i;
    		iter.next();
    	}
    	
    	assertEquals(6, i);
    }","26/Jan/06 09:37;scolebourne@joda.org;There have been changes to the method updateCurrentIterator() between these
versions that we need, so we can't just reverse the change. I'd love to fix any
bug that can be identified cleanly. For now though I'm placing this in NEEDINFO
awaiting a test case.",19/Jul/06 21:55;scolebourne;Still awaiting a test case against 3.2,15/Aug/07 05:30;bayard;If it's a bug that couldn't be recreated outside a particular environment... I'm suspicious that it's a threading issue.,"11/Sep/07 17:35;bayard;Here's the 2.1.1 to trunk diff for that method:

{code:java}
     protected void updateCurrentIterator() {
         if (currentIterator == null) {
-            currentIterator = (Iterator) iteratorChain.get(0);
+            if (iteratorChain.isEmpty()) {
+                currentIterator = EmptyIterator.INSTANCE;
+            } else {
+                currentIterator = (Iterator) iteratorChain.get(0);
+            }
             // set last used iterator here, in case the user calls remove
             // before calling hasNext() or next() (although they shouldn't)
             lastUsedIterator = currentIterator;
-            return;
         }

-        if (currentIteratorIndex == (iteratorChain.size() - 1)) {
-            return;
-        }
-
-        while (currentIterator.hasNext() == false) {
-            ++currentIteratorIndex;
+        while (currentIterator.hasNext() == false && currentIteratorIndex < iteratorChain.size() - 1) {
+            currentIteratorIndex++;
             currentIterator = (Iterator) iteratorChain.get(currentIteratorIndex);
-
-            if (currentIteratorIndex == (iteratorChain.size() - 1)) {
-                return;
-            }
         }
     }
{code}","11/Sep/07 17:56;bayard;The first block of code is a bit of protection that stops an IndexOutOfBoundsException. It's not possible to enter updateIteratorChain() without lockChain() having been called, so it's not possible for the iterator to be empty and then get values later. This initial bit of code looks good.

Then a return statement is removed. With the return statement, an empty iterator would be considered to be full, so removing this return statement makes sense. It does mean that there's a new code path to go through the first time. Jonathan does report that the first element doesn't return, which might point to this return statement; but he also reports other later elements are missing which doesn't. 

The following changes are one change. An if statement is rolled into the while loop below it. It's the biggest change, but it seems to be fine. 

The new code path means that:

a) An empty iterator is passed down to the while loop. Its hasNext() is false and currentIteratorIndex (=0) is not less than size-1 (=-1). So the while loop is not entered and the method returns as before.

b) The first iterator in the array is at its beginning. In Jonthan's case its hasNext is true, and currentIteratorIndex (=0) is not less than size-1 (0). The while loop is not entered and the method returns as before. The alternative to Jonathan's case would be an empty iterator, but that would also not enter the while loop due to the second clause.

So none of the code changes would appear to cause any problems, and things would appear to be thread safe because they are read-only at that time - unless more than one thing is reading the iterator.

That's the only explanation I can see - that there was another thread that was sometimes reading the other iterator. It doesn't match to Jonathan's report of 2.1.1 being fine and 3.1 being bad.

I've been looking at trunk and not 3.1. Looking at the diff between 3.1 and trunk, the only change has been protection in remove() against calling updateCurrentIterator() unless the currentIterator is null. As the report only has the one iterator in the chain, I can't see this bug leading to elements vanishing. updateIteratorChain doesn't do element moving, just iterators.

So... I'm all for closing this as Cannot Reproduce. ","19/Mar/08 06:52;bayard;As per my previous investigation, closing this as Cannot Reproduce.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Bug in CollectionUtils,COLLECTIONS-109,12340249,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,macbelgium@toughguy.net,macbelgium@toughguy.net,24/Jun/02 15:12,15/Mar/08 21:36,07/Apr/19 20:37,15/Mar/08 21:36,,,,,,,,,,,,,,,0,,,,"Hi,

there is a bug in CollectionUtils. If you pass in a Collection object which is 
not an instance of List to the CollectionUtils.index() methods, the method 
doesn't work: it just returns the given Collection instead of the i-th value in 
the Collection.

I've already reported this (including a patch) to the commons-dev mailinglist, 
but there was no reaction, that's why I'm trying it this way.

Here is the patch (if possible, I will also add an attachment including this 
patch)

regards,
Maarten

cvs diff -u CollectionUtils.java 
Index: CollectionUtils.java
===================================================================
RCS file: /home/cvspublic/jakarta-
commons/collections/src/java/org/apache/commons/collections/CollectionUtils.java
,v
retrieving revision 1.8
diff -u -r1.8 CollectionUtils.java
--- CollectionUtils.java	12 Jun 2002 03:59:15 -0000	1.8
+++ CollectionUtils.java	18 Jun 2002 12:23:34 -0000
@@ -500,6 +500,17 @@
                 }
             }
         }
+        else if(obj instanceof Collection) {
+            Iterator iterator = ((Collection)obj).iterator();
+            while(iterator.hasNext()) {
+                idx--;
+                if(idx == -1) {
+                    return iterator.next();
+                } else {
+                    iterator.next();
+                }
+            }
+        }
         return obj;
     }","Operating System: All
Platform: All",,,,,,,,,,,,,,,,,,24/Jun/02 15:13;macbelgium@toughguy.net;ASF.LICENSE.NOT.GRANTED--CollectionUtils.patch;https://issues.apache.org/jira/secure/attachment/12331977/ASF.LICENSE.NOT.GRANTED--CollectionUtils.patch,,,,,,,,,1.0,,,,,,,,,,,,,,,,10168.0,,,2002-08-10 07:38:36.0,,,false,,,,,,,,,,,,,,18889,,,Sat Aug 10 07:38:36 UTC 2002,,,,,,0|i0sj9r:,164599,,,,,,,,"24/Jun/02 15:13;macbelgium@toughguy.net;Created an attachment (id=2162)
The patch as an attachment
","10/Aug/02 07:38;pjack@sfaf.org;Applied slightly modified version of the given patch.  Also wrote up a small but
better-than-nothing unit test for CollectionUtils.index(Object, Object).",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
[collections] [RFE] RemoveElementTransformer,COLLECTIONS-108,12341612,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Won't Fix,,cote@computer.org,cote@computer.org,05/Aug/04 01:23,15/Mar/08 21:36,07/Apr/19 20:37,15/Mar/08 21:36,,,,,,,,,,,,,,,0,,,,"There is transformer remove a element from a Set (modifing the original ser). 
If I write proper javadoc and test case, could it be included in commons
collections.","Operating System: All
Platform: All",,,,,,,,,,,,,,,,,,05/Aug/04 01:24;cote@computer.org;ASF.LICENSE.NOT.GRANTED--RemoveElementTransformer.java;https://issues.apache.org/jira/secure/attachment/12333025/ASF.LICENSE.NOT.GRANTED--RemoveElementTransformer.java,05/Aug/04 01:25;cote@computer.org;ASF.LICENSE.NOT.GRANTED--TestRemoveElementTransformer.java;https://issues.apache.org/jira/secure/attachment/12333026/ASF.LICENSE.NOT.GRANTED--TestRemoveElementTransformer.java,,,,,,,,2.0,,,,,,,,,,,,,,,,30477.0,,,2004-10-17 06:01:11.0,,,false,,,,,,,,,,,,,,18890,,,Sun Oct 17 06:01:11 UTC 2004,,,,,,0|i0sj9z:,164600,,,,,,,,"05/Aug/04 01:24;cote@computer.org;Created an attachment (id=12334)
The proposed transformer
","05/Aug/04 01:25;cote@computer.org;Created an attachment (id=12335)
the test case
","17/Oct/04 06:01;scolebourne@joda.org;Thanks for your submission.

The aim of the functor package in [collections] is to provide basic functors, 
not application specific ones. Whilst I can understand that this transformer 
manipulates collections objects, I don't believe that it is a truly basic 
functor suitable for collections.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
[collections] AbstractMapBag.BagIterator.remove broken,COLLECTIONS-107,12342373,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,scolebourne@joda.org,scolebourne@joda.org,15/Jul/05 08:07,15/Mar/08 21:36,07/Apr/19 20:37,15/Mar/08 21:36,3.1,,,,,,,,,,,,,,0,,,,"I can't get in to CVS to see if this is fixed, but there is a bug in 
AbstractMapBag in 3.1: BagIterator.remove() does not properly remove the 
last instance of a given item; the result is infinite looping.  Here is a 
patch.

-steve

Steve Clark
ECOS Development Group
steve_clark@fws.gov
(970)226-9291


--- AbstractMapBag.java.orig    2005-07-14 11:14:33.708373173 -0600
+++ AbstractMapBag.java 2005-07-14 11:15:30.566623793 -0600
@@ -221,7 +221,7 @@
                 throw new IllegalStateException();
             }
             MutableInteger mut = (MutableInteger) current.getValue();
-            if (mut.value > 0) {
+            if (mut.value > 1) {
                 mut.value--;
                 parent.size--;
             } else {","Operating System: All
Platform: All",,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,35747.0,,,,,,false,,,,,,,,,,,,,,18891,,,Fri Jul 15 08:12:10 UTC 2005,,,,,,0|i0sja7:,164601,,,,,,,,"15/Jul/05 08:12;scolebourne@joda.org;The proposed patch fixed half the problem.

Full fix and test case committed in svn r219131.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
[collections] test failures for subclasses of AbstractBidiMapDecorator and friends,COLLECTIONS-106,12341178,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,heuermh@acm.org,heuermh@acm.org,30/Dec/03 05:59,15/Mar/08 21:36,07/Apr/19 20:37,15/Mar/08 21:36,,,,,,,,,,,,,,,0,,,,"The attached test case fails for a class that extends
AbstractOrderedBidiMapDecorator:

Testcase: testFirstKey took 0.04 sec
	FAILED
expected:<foo> but was:<again>
junit.framework.AssertionFailedError: expected:<foo> but was:<again>
	at
org.apache.commons.collections.bidimap.AbstractTestOrderedBidiMap.testFirstKey(AbstractTestOrderedBidiMap.java:102)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at
sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)

Testcase: testFirstKeyTestcase: testLastKey took 0 sec
	FAILED
expected:<all> but was:<you>
junit.framework.AssertionFailedError: expected:<all> but was:<you>
	at
org.apache.commons.collections.bidimap.AbstractTestOrderedBidiMap.testLastKey(AbstractTestOrderedBidiMap.java:119)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at
sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)

Testcase: testLastKeyTestcase: testNextKey took 0.05 sec
	FAILED
expected:<we'll> but was:<gee>
junit.framework.AssertionFailedError: expected:<we'll> but was:<gee>
	at
org.apache.commons.collections.bidimap.AbstractTestOrderedBidiMap.testNextKey(AbstractTestOrderedBidiMap.java:141)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at
sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)

Testcase: testNextKeyTestcase: testPreviousKey took 0 sec
	FAILED
expected:<gosh> but was:<again>
junit.framework.AssertionFailedError: expected:<gosh> but was:<again>
	at
org.apache.commons.collections.bidimap.AbstractTestOrderedBidiMap.testPreviousKey(AbstractTestOrderedBidiMap.java:176)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at
sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)

Testcase: testPreviousKeyTestcase: testBidiPut took 0 sec
Testcase: testBidiGetKey took 0 sec
Testcase: testBidiGetKeyInverse took 0 sec
Testcase: testBidiInverse took 0 sec
	FAILED
Inverse of inverse is not equal to original. expected same:<{key1=value1,
key2=value2, key3=value3}> was not:<{key1=value1, key2=value2, key3=value3}>
junit.framework.AssertionFailedError: Inverse of inverse is not equal to
original. expected same:<{key1=value1, key2=value2, key3=value3}> was
not:<{key1=value1, key2=value2, key3=value3}>
	at
org.apache.commons.collections.bidimap.AbstractTestBidiMap.testBidiInverse(AbstractTestBidiMap.java:232)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at
sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)

The testBidiInverse test also fails for classes that extend
AbstractBidiMapDecorator and AbstractSortedBidiMapDecorator (not attached).","Operating System: All
Platform: All",,,,,,,,,,,,,,,,,,30/Dec/03 06:00;heuermh@acm.org;ASF.LICENSE.NOT.GRANTED--AbstractOrderedBidiMapDecoratorTest.java;https://issues.apache.org/jira/secure/attachment/12332669/ASF.LICENSE.NOT.GRANTED--AbstractOrderedBidiMapDecoratorTest.java,,,,,,,,,1.0,,,,,,,,,,,,,,,,25811.0,,,2003-12-31 06:00:14.0,,,false,,,,,,,,,,,,,,18892,,,Wed Dec 31 06:00:14 UTC 2003,,,,,,0|i0sjaf:,164602,,,,,,,,"30/Dec/03 06:00;heuermh@acm.org;Created an attachment (id=9743)
test case for AbstractOrderedBidiMapDecorator
","31/Dec/03 06:00;scolebourne@joda.org;This test has been added to collections, with three fixes

- enable setValue
- special handling for inverse
- setup confirmed collection as TreeMap",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
StaticBucketMap.remove(Object) incorrectly handles key comparison,COLLECTIONS-105,12340558,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,leo.sutic@inspireinfrastructure.com,leo.sutic@inspireinfrastructure.com,18/Feb/03 02:15,15/Mar/08 21:36,07/Apr/19 20:37,15/Mar/08 21:36,2.1,,,,,,,,,,,,,,0,,,,"I've found a bug in the StaticBucketMap class, the remove(Object)
method:

    /**
     *  Implements {@link Map#remove(Object)}.
     */
    public Object remove( Object key )
    {
        int hash = getHash( key );

        synchronized( m_locks[ hash ] )
        {
            Node n = m_buckets[ hash ];
            Node prev = null;

            while( n != null )
            {
HERE>>>>>>>>>   if( n.key == null || ( n.key != null && n.key.equals(
key ) ) )  <<<<<<<<<<<<<<<<<<
                {
                    // Remove this node from the linked list of nodes.
                    if( null == prev )
                    {
                        // This node was the head, set the next node to
be the new head.
                        m_buckets[ hash ] = n.next;
                    }
                    else
                    {
                        // Set the next node of the previous node to be
the node after this one.
                        prev.next = n.next;
                    }
                    m_locks[hash].size--;
                    return n.value;
                }

                prev = n;
                n = n.next;
            }
        }

        return null;
    }

The test is:

                if( n.key == null || ( n.key != null && n.key.equals(
key ) ) )

should be:

                if( n.key == key || ( n.key != null && n.key.equals( key
) ) )

which is how it works in get(Object), containsKey(Object) etc. and which
is correct. We have a match if the keys match using == OR if they are
equal according to equals().","Operating System: other
Platform: Other",,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,17139.0,,,2003-02-23 00:37:05.0,,,false,,,,,,,,,,,,,,18893,,,Sun Feb 23 00:37:05 UTC 2003,,,,,,0|i0sjan:,164603,,,,,,,,"23/Feb/03 00:37;scolebourne@joda.org;Fixed in CVS head, thanks",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
[collections] Only last element is removeable when CircularFifoBuffer is full,COLLECTIONS-104,12341996,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,amir@mathforum.org,amir@mathforum.org,13/Jan/05 03:30,15/Mar/08 21:36,07/Apr/19 20:37,15/Mar/08 21:36,3.1,,,,,,,,,,,,,,0,,,,"If the circular fifo buffer is full and you remove an item, that is not the last
one, it breaks.

code example:

import java.io.*;
import org.apache.commons.collections.buffer.*;

class Stub {
    public static void main(String[] args) {
        CircularFifoBuffer fifo = new CircularFifoBuffer(5);
        System.out.println(fifo);

        fifo.add(new String(""1""));
        System.out.println(fifo);

        fifo.add(new String(""2""));
        System.out.println(fifo);

        fifo.add(new String(""3""));
        System.out.println(fifo);

        fifo.add(new String(""4""));
        System.out.println(fifo);

        System.out.println(""adding 5"");
        fifo.add(new String(""5""));
        System.out.println(fifo);

        String six = new String(""6"");
        System.out.println(""adding 6"");
        fifo.add(six);
        System.out.println(fifo);

/* uncomment the following block to avoid problem
        System.out.println(""fifo.isFull?:""+fifo.isFull());
        System.out.println(""removing 6"");
        fifo.remove(new String(""6""));
        System.out.println(fifo);
*/

        System.out.println(""fifo.isFull?:""+fifo.isFull());

        System.out.println(""removing 3"");
        fifo.remove(new String(""3""));
        System.out.println(fifo);

        System.out.println(""removing 4"");
        fifo.remove(new String(""4""));
        System.out.println(fifo);

        System.out.println(""clearing"");
        fifo.clear();
        System.out.println(""removing 4"");
        fifo.remove(new String(""4""));
        System.out.println(fifo);

    }
}



==============

output busted:

[]
[1]
[1, 2]
[1, 2, 3]
[1, 2, 3, 4]
adding 5
[1, 2, 3, 4, 5]
adding 6
[2, 3, 4, 5, 6]
fifo.isFull?:true
removing 3
Exception in thread ""main"" java.lang.ArrayIndexOutOfBoundsException: -1
        at
org.apache.commons.collections.buffer.BoundedFifoBuffer$1.remove(BoundedFifoBuffer.java:347)
        at java.util.AbstractCollection.remove(AbstractCollection.java:255)
        at Stub.main(Stub.java:40)","Operating System: Linux
Platform: PC",,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,33071.0,,,2005-01-14 23:16:38.0,,,false,,,,,,,,,,,,,,18894,,,Thu Feb 09 01:05:37 UTC 2006,,,,,,0|i0sjav:,164604,,,,,,,,"13/Jan/05 06:12;amir@mathforum.org;It seems like I incorrectly stated the problem.

It turns out the error can happen when the buffer is not full also.

My new theory is that you can only remove an item from a non-boundary position
if there has not been a shift (shift=adding N+1 items to a buffer of size N).

In these examples the buffer is not full when the remove(object) is called.
As you can see the size of the buffer remains the same (6) however in the second
example a 7th item is added which causes a shift.

[]
[1]
[1, 2]
[1, 2, 3]
[1, 2, 3, 4]
adding 5
[1, 2, 3, 4, 5]
adding 6
[1, 2, 3, 4, 5, 6]
removing
[2, 3, 4, 5, 6]
fifo.isFull?:false
removing 4
[2, 3, 5, 6]
removing 4
[2, 3, 5, 6]

=======

[]
[1]
[1, 2]
[1, 2, 3]
[1, 2, 3, 4]
adding 5
[1, 2, 3, 4, 5]
adding 6
[1, 2, 3, 4, 5, 6]
adding 7
[2, 3, 4, 5, 6, 7]
removing
[3, 4, 5, 6, 7]
fifo.isFull?:false
removing 4
Exception in thread ""main"" java.lang.ArrayIndexOutOfBoundsException: -1
        at
org.apache.commons.collections.buffer.BoundedFifoBuffer$1.remove(BoundedFifoBuffer.java:347)
        at java.util.AbstractCollection.remove(AbstractCollection.java:255)
        at Stub.main(Stub.java:51)


Thanks,
Amir","14/Jan/05 23:16;phil@steitz.com;Thank you for reporting this.  Looks like the problem is in BoundedFifoBuffer. 
IIUC how this field is supposed to be maintained, the end field is not being
updated correctly. ","16/Jan/05 07:52;phil@steitz.com;The problem was in BoundedFifoBuffer's iterator.remove method.  The shift
operation was not correctly incrementing / decrementing array indexes.  Changes
have been committed to fix this. Should be fixed in the nightly build starting
1/15/05.",09/Feb/06 01:05;gudnabrsam@yahoo.com;*** COM-2741 has been marked as a duplicate of this bug. ***,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
SoftRefHashMap is all kinds of wonky,COLLECTIONS-103,12340235,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,pjack@sfaf.org,pjack@sfaf.org,03/Jun/02 13:12,14/Jul/06 05:45,07/Apr/19 20:37,14/Jul/06 05:33,2.0,,,,,2.1,,,,,,,,,1,,,,"Many methods in SoftRefHashMap do not conform the the java.util.Map 
specification.  After you populate a SoftRefHashMap using its put or putAll 
method, it transforms the values into SoftReferences.  The get() method 
correctly re-translates the SoftReferences back into the actual object values, 
unless they've been garbage collected.

However, the entrySet() collection view does NOT perform this reverse 
translation; iterating over an entry set gives you Map.Entry with SoftReference 
values.  Since the equals() and hashCode() methods rely on iterating over the 
entry set, equals() and hashCode() are broken in SoftRefHashMap.

Also, it's odd that after I put(key,value), containsValue(value) will return 
true, yet I won't be able to find the value in the entry set.

Also, invoking setValue() on a Map.Entry in the entrySet will correctly update 
the map with a new value; however, the old value is not returned as per the Map 
specification.

Also, the values() and entrySet() collection views are not backed by the map; 
alterations to the map are not reflected in any existing values() or entrySet() 
collection views.

Also, containsKey(Object) is wierd.  If I put(key,value), and the value is 
subsequently garbage collected, containsValue(value) will return false, yet 
containsKey(key) will still return true.

Creating a values() collection view creates hard references to the map's 
values, essentially ruining the point of the class (so long as the values() 
collection view exists, the map does not function as a memory-aware cache).

Finally, iterating over keySet() and entrySet() is wonky.  Mappings might have 
been removed by the garbage collector, but the iterators will still return an 
object for the mapping.  So keySet()'s iterator will return keys for values 
that aren't there anymore, and entrySet()'s iterator will return Map.Entries 
with keys that map to null instead of values.","Operating System: All
Platform: All",,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,9571.0,,,,,,false,,,,,,,,,,,,,,18895,,,Tue Aug 13 01:26:26 UTC 2002,,,,,,0|i0sjb3:,164605,,,,,,,,"08/Jun/02 06:49;pjack@sfaf.org;Actually the values() method doesn't work at all.  It always raises a 
ClassCastException, because the underlying map's values() collection is 
incorrectly cast to a Set.
",13/Aug/02 01:26;pjack@sfaf.org;Deprecated SoftRefHashMap in favor of new ReferenceMap.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Bag interface violates Collection contract,COLLECTIONS-102,12340233,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Minor,Fixed,,pjack@sfaf.org,pjack@sfaf.org,29/May/02 02:49,15/Mar/08 21:36,07/Apr/19 20:37,14/Jul/06 12:05,,,,,,,,,,,,,,,1,,,,"The following methods as defined by the Bag interface violate their 
corresponding definitions in the Collection interface:

add(Object), addAll(Collection)
  The Collection interface specifies that the add method should return true if 
the collection changes as a result of the call.  Since a bag's size always 
increases as a result of an add operation, Bag.add should always return true.  
The bag interface specifies that add(Object) will only return true if the 
object was not already in the unique set.
  
remove(Object)
  The Collection interface states that only one occurrence of a given object 
should be removed as a result of this method.  The Bag interface specifies that 
all occurrences will be removed.

removeAll(Collection)
retainAll(Collection)
containsAll(Collection)
  The Collection specification does not respect cardinality for these methods; 
the Bag interface does.

The add, addAll and remove methods can be fixed easily, and code relying on the 
old behavior can be rewritten simply using existing Bag methods:

   boolean r = bag.add(obj)

can be replaced with:

   boolean r = !bag.contains(obj);
   bag.add(obj)

And

   boolean r = bag.remove(obj)

can be replaced with

   boolean r = bag.remove(obj, bag.getCount(obj));

The existing bulk operations could be implemented with static utility methods 
in CollectionUtils (or possibly BagUtils), which would allow a smooth migration 
path for code that relies on the current bulk operation behavior.","Operating System: All
Platform: All",,,,,,,,,,,,,,,,,,04/Jun/02 07:42;pjack@sfaf.org;ASF.LICENSE.NOT.GRANTED--bug9467_patch.diff;https://issues.apache.org/jira/secure/attachment/12331968/ASF.LICENSE.NOT.GRANTED--bug9467_patch.diff,,,,,,,,,1.0,,,,,,,,,,,,,,,,9467.0,,,2006-07-14 12:05:30.0,,,false,,,,,,,,,,,,,,18896,,,Fri Jul 14 12:05:30 UTC 2006,,,,,,0|i0sjbb:,164606,,,,,,,,"04/Jun/02 07:42;pjack@sfaf.org;Created an attachment (id=1998)
Patch for this bug that makes Bag conform to Collection contract.
","13/Aug/02 01:28;pjack@sfaf.org;Updated documentation so that the violations are clearly marked.  Will fix in a
later release.",14/Jul/06 12:05;bayard;Reopen/reclose to deal with migration bug.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
[collections] CursorableLinkedList iteration broken with previous,COLLECTIONS-101,12342378,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,scolebourne@joda.org,scolebourne@joda.org,16/Jul/05 23:14,15/Mar/08 21:36,07/Apr/19 20:37,15/Mar/08 21:36,3.1,,,,,,,,,,,,,,0,,,,"With a CursorableLinkedList, if you perform a Next, Next, Previous on an
iterator/cursor, then remove the last object returned by index from the list,
you will leave the cursor in an invalid state.

You should at this point not be able to call remove/set on the iterator, but you
can.","Operating System: All
Platform: All",,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,35766.0,,,,,,false,,,,,,,,,,,,,,18897,,,Sat Jul 16 23:20:50 UTC 2005,,,,,,0|i0sjbj:,164607,,,,,,,,16/Jul/05 23:20;scolebourne@joda.org;Fixed in svn rv219330,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
[collections] IteratorChain bug with empty iterators.,COLLECTIONS-100,12341134,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Incomplete,,andrus-jk@objectstyle.org,andrus-jk@objectstyle.org,03/Dec/03 13:11,15/Mar/08 21:36,07/Apr/19 20:37,15/Mar/08 21:36,2.1,,,,,,,,,,,,,,0,,,,"Haven't tried this with nightly builds, but 2.1 collections have the follwoing
problem: when the first iterator in a chain is empty, first call to ""hasNext""
returns false, on second and subsequent calls, ""true"" is returned again as it
should. Here is an example:

        List emptyList = new ArrayList();
        List nonEmptyList = new ArrayList();
        nonEmptyList.add(new Object());
        
        IteratorChain it = new IteratorChain(new Iterator[]
{emptyList.iterator(), nonEmptyList.iterator()});
        System.out.println(""Next? "" + it.hasNext()); // prints false
        System.out.println(""Next again? "" + it.hasNext()); // prints true

Cheers,
Andrus","Operating System: All
Platform: All",,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,25154.0,,,2003-12-05 01:11:16.0,,,false,,,,,,,,,,,,,,18898,,,Sat Dec 06 02:06:16 UTC 2003,,,,,,0|i0sjbr:,164608,,,,,,,,"05/Dec/03 01:11;amamment;A test for this bug (below) in TestIteratorChain has been present since 
version 1.3 of the testcase (currently on version 1.6).  It looks like to 
checks the same condition you point out and it does pass in the current 
build.  Please take a look and reopen the bug if there's a difference I've 
missed.  

    public void testFirstIteratorIsEmptyBug() {
        List empty = new ArrayList();
        List notEmpty = new ArrayList();
        notEmpty.add(""A"");
        notEmpty.add(""B"");
        notEmpty.add(""C"");
        IteratorChain chain = new IteratorChain();
        chain.addIterator(empty.iterator());
        chain.addIterator(notEmpty.iterator());
        assertTrue(""should have next"",chain.hasNext());
        assertEquals(""A"",chain.next());
        assertTrue(""should have next"",chain.hasNext());
        assertEquals(""B"",chain.next());
        assertTrue(""should have next"",chain.hasNext());
        assertEquals(""C"",chain.next());
        assertTrue(""should not have next"",!chain.hasNext());
    }
","06/Dec/03 01:48;klavergne@comcast.net;I have found the same problem. I took the test that you submitted here and tried 
it with commons-collections 2.1. It failed on the first line checking the 
hasNext() on the empty iterator. Here are the results of the test:

There was 1 failure:
1) testFirstIteratorIsEmptyBug(org.apache.commons.collections.iterators.
TestIteratorChain) junit.framework.AssertionFailedError: should have next
    at org.apache.commons.collections.iterators.TestIteratorChain.
testFirstIteratorIsEmptyBug(TestIteratorChain.java:189)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.
java:39)
    at sun.reflect.DelegatingMethodAccessorImpl.
invoke(DelegatingMethodAccessorImpl.java:25)
FAILURES!!!","06/Dec/03 02:06;amamment;True enough....  Sorry I wasn't clear enough when I closed the bug.  This bug 
has been closed since 2.1 Collectiosn was released.  The current nightly 
builds, leading up to the 3.0 release (when I'm not sure) have resolved this 
issue.  

If you look in the CVS repository, that test is not part of TestIteratorChain 
as of the 2.1 release.  It has since been added (I cut and past the text from 
that class).

",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
[PATCH] Apidoc fix for MapUtils.java,COLLECTIONS-99,12340802,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Minor,Fixed,,janekdb@yahoo.co.uk,janekdb@yahoo.co.uk,20/Jun/03 07:36,15/Mar/08 21:36,07/Apr/19 20:37,15/Mar/08 21:36,Nightly Builds,,,,,,,,,,,,,,0,,,,This patch fixes two {@link} tags.,"Operating System: All
Platform: All",,,,,,,,,,,,,,,,,,20/Jun/03 07:37;janekdb@yahoo.co.uk;ASF.LICENSE.NOT.GRANTED--MapUtils-apidoc.txt;https://issues.apache.org/jira/secure/attachment/12332371/ASF.LICENSE.NOT.GRANTED--MapUtils-apidoc.txt,,,,,,,,,1.0,,,,,,,,,,,,,,,,20933.0,,,2003-06-20 14:53:32.0,,,false,,,,,,,,,,,,,,18899,,,Fri Jun 20 14:53:32 UTC 2003,,,,,,0|i0sjbz:,164609,,,,,,,,"20/Jun/03 07:37;janekdb@yahoo.co.uk;Created an attachment (id=6901)
A patch that fixes two {@link} tags
","20/Jun/03 14:53;scolebourne@joda.org;Patch applied,
thanks",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
[collections] BlockingBuffer Should Include Cause Exception When Throwing BufferUnderflowException,COLLECTIONS-98,12342074,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,sethladd,sethladd,23/Feb/05 06:22,15/Mar/08 21:36,07/Apr/19 20:37,15/Mar/08 21:36,3.0,,,,,,,,,,,,,,0,,,,"The code for BlockingBuffer throws BufferUnderflowException when a
InterruptedException is thrown.  But, the original InterruptedException is not
included or wrapped by the new BufferUnderflowException.  This makes it
difficult to determine if the thread was truly interrupted.

I believe the commons project has support for wrapping exception (to support
older JVMs).  This would be very helpful to support.

For instance, line 141 of the 3.0 version of BlockingBuffer.

Thanks!","Operating System: All
Platform: All",,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,33700.0,,,2005-05-15 18:36:21.0,,,false,,,,,,,,,,,,,,18900,,,Tue May 17 02:48:24 UTC 2005,,,,,,0|i0sjc7:,164610,,,,,,,,15/May/05 18:36;scolebourne@joda.org;Stack trace included,17/May/05 02:48;sethladd;Thanks!,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
[collections][PATCH] JavaDoc fixes for iterators,COLLECTIONS-97,12340958,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Minor,Fixed,,janekdb@yahoo.co.uk,janekdb@yahoo.co.uk,11/Sep/03 04:50,15/Mar/08 21:36,07/Apr/19 20:37,15/Mar/08 21:36,Nightly Builds,,,,,,,,,,,,,,0,,,,"The attached patch fixes three typos in ComparatorChain, FixedOrderComparator
and TransformingComparator.","Operating System: other
Platform: Other",,,,,,,,,,,,,,,,,,11/Sep/03 04:52;janekdb@yahoo.co.uk;ASF.LICENSE.NOT.GRANTED--comparators-JavaDoc.patch;https://issues.apache.org/jira/secure/attachment/12332516/ASF.LICENSE.NOT.GRANTED--comparators-JavaDoc.patch,,,,,,,,,1.0,,,,,,,,,,,,,,,,23087.0,,,2003-09-17 15:42:09.0,,,false,,,,,,,,,,,,,,18901,,,Wed Sep 17 16:03:43 UTC 2003,,,,,,0|i0sjcf:,164611,,,,,,,,"11/Sep/03 04:52;janekdb@yahoo.co.uk;Created an attachment (id=8143)
patch fixing three typos in the o.a.c.collections.iterators package
","17/Sep/03 15:42;scolebourne@joda.org;You meant comparators package of course...
Thanks",17/Sep/03 16:03;janekdb@yahoo.co.uk;...yes I did! Thanks!,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
debug and verbose print in MapUtils only handles String keys,COLLECTIONS-96,12341206,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,mpg@mpgsoftware.com,mpg@mpgsoftware.com,14/Jan/04 10:22,15/Mar/08 21:36,07/Apr/19 20:37,15/Mar/08 21:36,2.1,,,,,,,,,,,,,,0,,,,"In MapUtils, if the key is e.g., Integer, fails with a ClassCastException:

        for ( Iterator iter = map.entrySet().iterator(); iter.hasNext(); ) {
            Map.Entry entry = (Map.Entry) iter.next();
==>            String childKey = (String) entry.getKey();
            Object childValue = entry.getValue();
            if ( childValue instanceof Map ) {
                verbosePrint( out, childKey, (Map) childValue );
            }

Should not be cast to a String, just use Object, and it works.
Same thing goes for the less verbose sister method, debugPrint
Thanks,
Matt","Operating System: other
Platform: All",,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,26115.0,,,2004-01-15 04:52:14.0,,,false,,,,,,,,,,,,,,18902,,,Thu Jan 15 04:52:14 UTC 2004,,,,,,0|i0sjcn:,164612,,,,,,,,15/Jan/04 04:52;scolebourne@joda.org;Fixed already in CVS,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
[collections] fails the method TransformedMap.transformedMap,COLLECTIONS-95,12341674,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,tirso.canela@altana.es,tirso.canela@altana.es,31/Aug/04 19:41,15/Mar/08 21:36,07/Apr/19 20:37,15/Mar/08 21:36,3.0,,,,,,,,,,,,,,0,,,,"This methods instance a TransformedMap but it doesn't do anything.
The method transformMap must be called internally.","Operating System: other
Platform: Other",,,,,,,,,,,,,,,,,,01/Sep/04 23:23;tirso.canela@altana.es;ASF.LICENSE.NOT.GRANTED--Test.java;https://issues.apache.org/jira/secure/attachment/12333088/ASF.LICENSE.NOT.GRANTED--Test.java,,,,,,,,,1.0,,,,,,,,,,,,,,,,30959.0,,,2004-09-01 08:20:08.0,,,false,,,,,,,,,,,,,,18903,,,Sun Jul 17 02:57:32 UTC 2005,,,,,,0|i0sjcv:,164613,,,,,,,,"01/Sep/04 08:20;scolebourne@joda.org;Can you supply some code that doesn't work, such as a test case? Or a longer 
explanation? Thanks","01/Sep/04 23:23;tirso.canela@altana.es;Created an attachment (id=12593)
Test Case
","01/Sep/04 23:24;tirso.canela@altana.es;Sorry, my english  is very bad.

PROBLEM: I think Method MapUtils.transformedMap fails because method 
TransformedMap.transformedMap fails too, because internally the constructor 
TransformerMap takes the parameters but it doesnÂ´t perform anything with them.

See Attachment Test Case:

I want to add 5 to each one of the members of  the Map:

1) FIRST TEST: DOESNÂ´T WORKS (because internally the constructor TransformerMap 
takes the parameters but it doesnÂ´t perform anything with them.)


2) SECOND TEST: IT WORKS, but i think that it is not a correct solution or i 
donÂ´t understand the MapUtils.transformedMap philosophia.


3) One possible solution could be changing TrasformerMap constructor like this:

    protected TransformedMap(Map map, Transformer keyTransformer, Transformer 
valueTransformer) {
        super(map);
        this.keyTransformer = keyTransformer;
        this.valueTransformer = valueTransformer;
         
        //New
        transformMap(map);
}

4) Another possible solution could be changing the method 
TransformedMap.transformMap from protected to public.




    



","17/Jul/05 02:57;scolebourne@joda.org;The MapUtils method is functioning correctly. It is not supposed to transform
existing contents of the map. Instead, it supplies a new map that will transform
from then onwards. I have added comments to clarify.

I have also added a new factory method to TransformedMap and
TransformedSortedMap - decorateTransform - that will create the new map and
transform any existing contents. You will want to use this new factory method.

svn rv219347

BTW, your English is great! And a test case always helps.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
[collections] New feature: Extend ReferenceMap with IdentityMap functionality (WeakIdentityHashMap),COLLECTIONS-94,12341226,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,bugzillaspam@malakov.com,bugzillaspam@malakov.com,29/Jan/04 06:22,15/Mar/08 21:36,07/Apr/19 20:37,15/Mar/08 21:36,,,,,,,,,,,,,,,0,,,,"Hello All,

I would like to ask your opinion on providing IdentityMap features to 
ReferenceMap. (I am particularly interested in WeakIdentityHashMap)


Object cache is often implemented using ReferenceMap (WeakHashMap). This class 
delegates decision on when to de-cache an objects on
Java GC.

In many systems Java objects that represent database instances use database 
identity: methods Object.equals(Object) and
Object.hashCode() are redefined to use database identity (identity defined in 
terms of object table + object primary keys).

When traditional java.util.Map is used to implement database caches different 
instances of the same database objects present a problem: instances override 
each other. Class  java.util.IdentityHashMap (Apache Collections 3.0: 
IdentityMap) can be used to solve this problem - this approach uses 
System.identityHashCode() to obtain reference hashCode and Java comparison 
operator to compare keys (and values).

What I need is functionality of IdentityMap combined with WeakReference-based 
keys.

Is it possible to extend ReferenceMap with an ability to use reference identity 
instead of object identity? I can send you my prototype if you are interested 
(it adds about ten lines of code to ReferenceMap).



Here are some links to Sun's bug parade pages that describe similar feature 
request for Java's java.util.WeakHashMap:

http://developer.java.sun.com/developer/bugParade/bugs/4809420.html
http://developer.java.sun.com/developer/bugParade/bugs/4500542.html

P.S. There is a need for this feature in Apache DB-OJB project.

All the Best,
Andy","Operating System: All
Platform: All",,,,,,,,,,,,,,,,,,29/Jan/04 23:02;bugzillaspam@malakov.com;ASF.LICENSE.NOT.GRANTED--ReferenceMap.java;https://issues.apache.org/jira/secure/attachment/12332716/ASF.LICENSE.NOT.GRANTED--ReferenceMap.java,29/Jan/04 23:04;bugzillaspam@malakov.com;ASF.LICENSE.NOT.GRANTED--TestReferenceMap.java;https://issues.apache.org/jira/secure/attachment/12332717/ASF.LICENSE.NOT.GRANTED--TestReferenceMap.java,,,,,,,,2.0,,,,,,,,,,,,,,,,26503.0,,,2004-03-16 08:24:44.0,,,false,,,,,,,,,,,,,,18904,,,Wed Apr 28 04:47:34 UTC 2004,,,,,,0|i0sjd3:,164614,,,,,,,,"29/Jan/04 23:02;bugzillaspam@malakov.com;Created an attachment (id=10146)
Here is my prototype of this feature. I used collections 2.1 version of reference map as a base.
","29/Jan/04 23:04;bugzillaspam@malakov.com;Created an attachment (id=10147)
Simple junit test (can be easily merged with existing TestReferenceMap)
","16/Mar/04 08:24;scolebourne@joda.org;Adding Identity behaviour to ReferenceMap is a good extension for 
[collections]. However, I think it probably warrants a dedicated class as 
ReferenceMap has over-complicated constructors as is. I would also like to see 
if ReferenceMap can extend AbstractHashedMap.","01/Apr/04 08:09;scolebourne@joda.org;ReferenceMap now extends AbstractHashedMap, next step is to create a subclass 
for identity behaviour",28/Apr/04 04:47;scolebourne@joda.org;ReferenceIdentityMap now committed to the CVS,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
[collections] When the AbstractHashedMap is serialized and deserialized the data array doubles its size,COLLECTIONS-93,12342150,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,mcesar@hmsolucoes.com.br,mcesar@hmsolucoes.com.br,02/Apr/05 03:19,15/Mar/08 21:36,07/Apr/19 20:37,14/Jul/06 12:04,3.1,,,,,,,,,,,,,,1,,,,"In the method ""AbstractHashMap#doReadObject"", the method call ""threshold =
calculateThreshold(data.length, loadFactor);"" is after the ""put(key, value);"".
The ""put"" method uses the threshold to check the capacity of the data array.
In this checking, the threshold is zero, leading to a resize of the data array.
At each serialization/deserialization the size of the data array doubles.","Operating System: Windows XP
Platform: PC",,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,34265.0,,,2005-05-08 03:05:25.0,,,false,,,,,,,,,,,,,,18905,,,Fri Jul 14 12:04:24 UTC 2006,,,,,,0|i0sjdb:,164615,,,,,,,,08/May/05 03:05;scolebourne@joda.org;Change made in SVN revision 169102,14/Jul/06 12:04;bayard;Reopen/reclose to deal with migration bug.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
MultiHashMap.values() isn't backed by Map,COLLECTIONS-92,12340236,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,pjack@sfaf.org,pjack@sfaf.org,03/Jun/02 15:30,15/Mar/08 21:36,07/Apr/19 20:37,15/Mar/08 21:36,,,,,,,,,,,,,,,0,,,,"The values() collection of MultiHashMap isn't backed by the map; changes to the 
map are not reflected in a values() collection, and changes to the values() 
collection are not reflected in the map.  

Though MultiHashMap deliberately violates the Map contract in other ways, there 
seems to be no legimate reason for it to violate the values() contract; since 
values() can be implemented according to contract, it probably should be.","Operating System: All
Platform: All",,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,9573.0,,,2002-11-02 03:37:56.0,,,false,,,,,,,,,,,,,,18906,,,Mon Nov 25 03:41:15 UTC 2002,,,,,,0|i0sjdj:,164616,,,,,,,,"02/Nov/02 03:37;rwaldhof@us.britannica.com;I added a unit test for this in the generic 
TestMap.testValuesRemovedFromValuesCollectionAreRemovedFromMap, but override 
that in TestMultiHashMap to be a no-op for now.

(At least there is a test in place now)",25/Nov/02 03:41;scolebourne@joda.org;Fix supplied by Julien Buret,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
[collections] CollectionWrapper should implement Serializable,COLLECTIONS-91,12341101,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Minor,Duplicate,,news@schof.com,news@schof.com,18/Nov/03 05:22,15/Mar/08 21:36,07/Apr/19 20:37,14/Jul/06 12:07,2.1,,,,,,,,,,,,,,1,,,,"The CollectionWrapper inner class (part of CollectionUtils) should implement 
Serializable.  This would allow the creation of serializable lists in the event 
that the user needs this functionality.  Making this change would assume that 
all the objects contained in the list were serializable (not a big deal IMO.)

I discovered this problem when using ListUtils.lazyList() method.  The 
resulting list is not serializable and I need it to be.","Operating System: All
Platform: All",,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,24762.0,,,2004-01-13 11:03:34.0,,,false,,,,,,,,,,,,,,18907,,,Fri Jul 14 12:07:05 UTC 2006,,,,,,0|i0sjdr:,164617,,,,,,,,"13/Jan/04 11:03;amamment;Current implementations in CVS no longer have a CollectionWrapper inner class 
in CollectionUtils.  However, the issue of serializability of the decorators 
continues to be a problem and is recorded in Bugzilla elsewhere.  


*** This bug has been marked as a duplicate of 18815 ***",14/Jul/06 12:07;bayard;Reopen/reclose to deal with migration bug.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
[collections][PATCH] JavaDoc simplification for CollectionUtils,COLLECTIONS-90,12340945,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,janekdb@yahoo.co.uk,janekdb@yahoo.co.uk,07/Sep/03 08:40,15/Mar/08 21:36,07/Apr/19 20:37,15/Mar/08 21:36,Nightly Builds,,,,,,,,,,,,,,0,,,,"The attached patch removes some extraneous @return and @throws tags and makes
the effect of a null Predicate easier to understand for a couple of methods.","Operating System: other
Platform: Other",,,,,,,,,,,,,,,,,,07/Sep/03 08:41;janekdb@yahoo.co.uk;ASF.LICENSE.NOT.GRANTED--CollectionUtils-javadoc-fixes.txt;https://issues.apache.org/jira/secure/attachment/12332505/ASF.LICENSE.NOT.GRANTED--CollectionUtils-javadoc-fixes.txt,,,,,,,,,1.0,,,,,,,,,,,,,,,,22964.0,,,2003-09-07 15:48:08.0,,,false,,,,,,,,,,,,,,18908,,,Sun Sep 07 15:48:08 UTC 2003,,,,,,0|i0sjdz:,164618,,,,,,,,"07/Sep/03 08:41;janekdb@yahoo.co.uk;Created an attachment (id=8086)
JavaDoc simplifications for CollectionUtils
","07/Sep/03 15:48;scolebourne@joda.org;Patch applied, thanks",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
[collections][PATCH] TestBlockingBuffer extensions and BlockingBuffer fix,COLLECTIONS-89,12340979,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,janekdb@yahoo.co.uk,janekdb@yahoo.co.uk,18/Sep/03 06:31,15/Mar/08 21:36,07/Apr/19 20:37,15/Mar/08 21:36,Nightly Builds,,,,,,,,,,,,,,0,,,,"The attached patch adds some tests to assert the behaviour of
BlockingBuffer.get()/remove()/add()/addAll in various combinations.

The discussion that led to this patch can be found at COM-816.

Also attached is a patch to change notify() to notifyAll() in BlockingBuffer
which allows the tests in TestBlockingBuffer to pass.","Operating System: other
Platform: Other",,,,,,,,,,,,,,,,,,18/Sep/03 06:37;janekdb@yahoo.co.uk;ASF.LICENSE.NOT.GRANTED--BlockingBuffer-notify-fix.patch;https://issues.apache.org/jira/secure/attachment/12332534/ASF.LICENSE.NOT.GRANTED--BlockingBuffer-notify-fix.patch,18/Sep/03 06:33;janekdb@yahoo.co.uk;ASF.LICENSE.NOT.GRANTED--TestBlockingBuffer-adds-tests.patch;https://issues.apache.org/jira/secure/attachment/12332533/ASF.LICENSE.NOT.GRANTED--TestBlockingBuffer-adds-tests.patch,,,,,,,,2.0,,,,,,,,,,,,,,,,23232.0,,,2003-09-18 12:14:02.0,,,false,,,,,,,,,,,,,,18909,,,Thu Sep 18 12:14:02 UTC 2003,,,,,,0|i0sje7:,164619,,,,,,,,"18/Sep/03 06:33;janekdb@yahoo.co.uk;Created an attachment (id=8265)
patch adding several useful test cases to o.a.c.c.decorators.TestBlockingBuffer
","18/Sep/03 06:37;janekdb@yahoo.co.uk;Created an attachment (id=8266)
patch fixing BlockingBuffer to use notifyAll
",18/Sep/03 12:14;phil@steitz.com;Patches applied.  Thanks.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
[collection] Map filter with MapUtils.predicatedMap feature request,COLLECTIONS-88,12342188,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Won't Fix,,luc.carpentier@uniway.be,luc.carpentier@uniway.be,14/Apr/05 15:32,03/May/11 00:36,07/Apr/19 20:37,15/Mar/08 21:36,3.1,,,,,,,,,,,,,,0,,,,"Hello,

I stumbled into the following problem:

A client submits an http request with prefixed parameters. Each prefix will 
have it's own javabean to populate. So if there are two prefixes, then there 
will be two different javabeans to populate from the request parameters.

I created a PrefixPredicate that only allows values with a specific prefix. I 
then used this PrefixPredicate to copy the Map with the request parameters to 
a predicated Map with:

Map predicatedMap = MapUtils.predicatedMap(dataMap,keyPredicate,null);

However, since the request parameters contain parameters with other prefixes 
as well, this returns an IllegalArgumentException.

It would be nice to be able to specify to the MapUtils.predicatedMap method to 
ignore entries that do not comply to the predicate instead of to throw an 
exception.

There are lots of possabilities to filter on a Collection, but a Map is not a 
collection...","Operating System: other
Platform: Other",,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,34446.0,,,2005-05-23 03:04:52.0,,,false,,,,,,,,,,,,,,18910,,,Tue May 03 00:36:57 UTC 2011,,,,,,0|i0sjef:,164620,,,,,,,,"23/May/05 03:04;scolebourne@joda.org;The solution to your problem would appear to be:

Map reqParams;
CollectionUtils.filter(reqParams.keySet(), filterPredicate);


The deeper request in this call is covered by the proposal to add FilteredMap to
[collections].

Closing this call as wontfix.","03/May/11 00:25;anirudhvyas;I don't buy that argument, I can submit the patch if thats what it takes, I still feel this is a valid issue, and the method should be called filter( ) on MapUtils, that solution being described is ugly. My 2 cents.

Anirudh","03/May/11 00:36;anirudhvyas;I would like to commit this feature if permitted, please provide me with the instructions, your formatting standards etc link and I'll be happy to help you guys out.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
[collections] Implement a TimeoutBuffer class,COLLECTIONS-87,12342712,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Won't Fix,,jwcarman,jwcarman,12/Nov/05 05:35,15/Mar/08 21:36,07/Apr/19 20:37,15/Mar/08 21:36,3.2,,,,,,,,,,,,,,0,,,,"Please implement a TimeoutBuffer wrapper class which blocks on read()/get()
operations until a timeout expires.","Operating System: other
Platform: Other",,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,37472.0,,,,,,false,,,,,,,,,,,,,,18911,,,Wed Nov 23 21:54:13 UTC 2005,,,,,,0|i0sjen:,164621,,,,,,,,"23/Nov/05 21:54;jwcarman;We're going to modify BlockingBuffer for this functionality.  Will open up
additional enhancement request.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
LRUMap.get doesn't change usage status,COLLECTIONS-86,12340371,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,frank.finger@hybris.de,frank.finger@hybris.de,17/Oct/02 14:48,15/Mar/08 21:36,07/Apr/19 20:37,15/Mar/08 21:36,2.0,,,,,,,,,,,,,,0,,,,"LRUMap drops the least resently added item, not the least recently used one. The
following test fails in line 6 (and 7, if you comment out 6).


1: LRUMap map = new LRUMap( 2 );
2: map.put( ""2"", ""zwei"" );
3: map.put( ""3"", ""drei"" );

4: map.get( ""2"" ); // now, ""2"" should be least recently used
5: map.put( ""4"", ""vier"" ); // this should drop ""3""

6: assertEquals( ""zwei"", map.get(""2"") );
7: assertEquals( null, map.get(""3"") );
8: assertEquals( ""vier"", map.get(""4"") );","Operating System: All
Platform: PC",,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,13722.0,,,2002-10-17 19:41:00.0,,,false,,,,,,,,,,,,,,18912,,,Thu Oct 17 19:41:00 UTC 2002,,,,,,0|i0sjev:,164622,,,,,,,,"17/Oct/02 19:41;mas@apache.org;This has been fixed in CVS for 5 months now.  Either grab a recent nightly
build, checkout the latest snapshot from CVS, or wait for the forthcoming 2.1
release of commons-collections.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
ReferenceMap clears bindings too early,COLLECTIONS-85,12342952,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Invalid,,eric@bodden.de,eric@bodden.de,04/Mar/06 15:58,07/Aug/06 21:08,07/Apr/19 20:37,07/Aug/06 21:08,3.1,,,,,,,,Map,,,,,,0,,,,"Hello. This week I had to debug some small example program we are currently 
working on and it really took me a long time to find the actual problem because 
apprently there seems to be a bug in the implementation of ReferenceMap, which 
was really very unexpected for me. To me this seems very critical because I 
reckon that the ReferenceMap is in wide use. Hence I am describing my findings 
in detail.

The code is AspectJ code, but I also provide the bytecode. The puspose of the 
code is to detect the so-called ""lock order reversal pattern"", a temporal event 
pattern which gives indication of potentially unsafe locking. It tries to 
detect patterns where a thread t1 tries to acquire locks in the order l1 l2 and 
another thread t2 tries to do so in the order r2 r1.

When you compile the attached code with the AspectBench compiler (www.
aspectbench.org) and then execute ""java LORTest"", depending on the map 
implementation you choose, one of the following traces is produced:

- ""log"": your commons impl. (Reference identity map with weak key and values)
- ""log_jre"": the JRE impl. (hash map with weak keys, no identity map, but does 
not matter since the keys are threads, which do not implement equals(...))

(Both logs are also in the tarball.)

In log_jre you see that the LOR is detected (at the bottom). That works as 
follows: Whenever a lock is taken, the relationship (thread,lock) is put into a 
first (weak) map (see logging points ""Xa""). Also, for all such relations which 
are contained already, we put a reference to a pair (thread,(lock1,lock2)) into 
a second map (logging points ""Xb""). This represents the information ""thread"" 
took first ""lock1"" then ""lock2"".

As ""log"" shows, the weak map by commons is looses all the sudden some bindings. 
(Compare to log_jre.) This seems really buggy, since subsequent logging output 
shows that the threads and locked resources still exist! 

For me this is fully deterministically reproducable. I am using Windows XP with 
this JRE:

java version ""1.5.0_06""
Java(TM) 2 Runtime Environment, Standard Edition (build 1.5.0_06-b05)
Java HotSpot(TM) Client VM (build 1.5.0_06-b05, mixed mode, sharing)

You can compile the code (using the AspectBench compiler) with ""compile.bat"" or 
you can just run it with ""run.bat"", if you like.","Operating System: Windows XP
Platform: Other",,,,,,,,,,,,,,,,,,04/Mar/06 16:00;eric@bodden.de;ASF.LICENSE.NOT.GRANTED--LORTest - Commons Map.zip;https://issues.apache.org/jira/secure/attachment/12334055/ASF.LICENSE.NOT.GRANTED--LORTest+-+Commons+Map.zip,,,,,,,,,1.0,,,,,,,,,,,,,,,,38853.0,,,2006-03-26 03:20:00.0,,,false,,,,,,,,,,,,,,18913,,,Mon Aug 07 02:43:33 UTC 2006,,,,,,0|i0sjf3:,164623,,,,,,,,"04/Mar/06 16:00;eric@bodden.de;Created an attachment (id=17835)
The test case.

The zip file contains the sources and the compiled classes along with two batch
files to recompile and run the files. Also the zip included two dumps, one with
the commons map and one with the JRE map.","26/Mar/06 03:20;scolebourne@joda.org;Thanks for the report.

Unfortunately, it hasn't helper me understand the issue particularly. I can
reproduce the trace you supply (note that log_jre is missing from the zip).
However, this doesn't help me understand what is going on.

For a start, I can't even find the piece of code where the commons ReferenceMap
is being created. I can't see what sequence of operations is being called, etc.

This is a general problem with aspects - they break so much of what programmers
expect from Java.

In fact, I believe that this is just a special example of not correctly
synchronizing the ReferenceMap implementation. For example, here is the javadoc
of the purge mathod:
    /**
     * Purges stale mappings from this map.
     * <p>
     * Note that this method is not synchronized!  Special
     * care must be taken if, for instance, you want stale
     * mappings to be removed on a periodic basis by some
     * background thread.
     */

And the javadoc from the top of the class:
 * This implementation is not synchronized.
 * You can use {@link java.util.Collections#synchronizedMap} to 
 * provide synchronized access to a <code>ReferenceMap</code>.


Basically, ReferenceMap has no synchronization, and no thread handling. Its only
interaction with threads is via the standard JDK API on a ReferenceQueue.
","27/Mar/06 19:17;eric@bodden.de;Ok, thanks for the hint. That could of course be an issue. I will try to verify 
this. Sorry about the AspectJ code - but there's not much to do about it. I 
will report back in a bit.

",19/Jul/06 21:59;scolebourne;Awaiting feedback - I will close as unreproducible otherwise,07/Aug/06 02:43;eric@bodden.de;Hello. This was indeed apparently due to a lack of synchronization. My apologies for not noticing that earlier and for the late reply.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
TreeList with inproved iterator() and listIterator() implementation,COLLECTIONS-84,12341192,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,js@ekkono.com,js@ekkono.com,12/May/04 23:08,15/Mar/08 21:36,07/Apr/19 20:37,15/Mar/08 21:36,3.1,,,,,,,,,,,,,,0,,,,"Added references to next and and prev using a flag.  This is called Faedelung in
German :-)","Operating System: other
Platform: Other",,,,,,,,,,,,,,,,,,12/May/04 23:11;js@ekkono.com;ASF.LICENSE.NOT.GRANTED--TreeList.java;https://issues.apache.org/jira/secure/attachment/12332686/ASF.LICENSE.NOT.GRANTED--TreeList.java,12/May/04 23:09;js@ekkono.com;ASF.LICENSE.NOT.GRANTED--TreeList.java;https://issues.apache.org/jira/secure/attachment/12332685/ASF.LICENSE.NOT.GRANTED--TreeList.java,,,,,,,,2.0,,,,,,,,,,,,,,,,28930.0,,,2004-05-13 06:19:41.0,,,false,,,,,,,,,,,,,,18914,,,Thu May 13 06:19:41 UTC 2004,,,,,,0|i0sjfb:,164624,,,,,,,,"12/May/04 23:09;js@ekkono.com;Created an attachment (id=11523)
Source ofnew version
","12/May/04 23:11;js@ekkono.com;Created an attachment (id=11524)
Forgot to rename _height to height
",13/May/04 06:19;scolebourne@joda.org;Patch applied thanks,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Implementation of List with an AVLTree (TreeList),COLLECTIONS-83,12341244,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Duplicate,,js@ekkono.com,js@ekkono.com,05/Feb/04 18:33,15/Mar/08 21:36,07/Apr/19 20:37,15/Mar/08 21:36,,,,,,,,,,,,,,,0,,,,"The existing Java List implementations are rather slow if it comes to big lists 
and insertions and/or random access.  To mitigate that this List is based on an 
AVL-Tree and uses offsets to locate objects.  The following benchmarks show the 
performance compared to LinkedList and ArrayList.

          add     insert    get
TreeList  300     501       110
ArrayList  70   20390        20
LinkedList 50  226636    279742

add - 100K times add( new Object() )
insert - 100k times add( random() * 100K, new Object() ) on a List with 100K 
elements.
get - 100k times get( random() * 100k ) on a List with 200K elements.

P.S.: I will try to attach the code as a zip.","Operating System: All
Platform: All",,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,26679.0,,,2004-02-05 19:07:38.0,,,false,,,,,,,,,,,,,,18915,,,Thu Feb 05 19:08:22 UTC 2004,,,,,,0|i0sjfj:,164625,,,,,,,,05/Feb/04 19:07;ebourg;Reopening to dupe instead of invalidating.,"05/Feb/04 19:08;ebourg;

*** This bug has been marked as a duplicate of 26680 ***",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
[collections] Map.debugPrint improvements,COLLECTIONS-82,12340786,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,max@eos.dk,max@eos.dk,13/Jun/03 18:07,15/Mar/08 21:36,07/Apr/19 20:37,15/Mar/08 21:36,2.1,,,,,,,,,,,,,,0,,,,"debugPrint and verbosePrint in MapUtils makes a cast of the key to a string 
(instead of calling toString() on it) which makes it impossible to use for debug 
printin maps with keys other than strings.","Operating System: other
Platform: Other",,,,,,,,,,,,,,,,,,14/Jun/03 00:37;amamment;ASF.LICENSE.NOT.GRANTED--MapUtils patch1;https://issues.apache.org/jira/secure/attachment/12332347/ASF.LICENSE.NOT.GRANTED--MapUtils+patch1,14/Jun/03 00:38;amamment;ASF.LICENSE.NOT.GRANTED--MapUtils patch2;https://issues.apache.org/jira/secure/attachment/12332348/ASF.LICENSE.NOT.GRANTED--MapUtils+patch2,14/Jun/03 00:36;amamment;ASF.LICENSE.NOT.GRANTED--TestMapUtils patch1;https://issues.apache.org/jira/secure/attachment/12332346/ASF.LICENSE.NOT.GRANTED--TestMapUtils+patch1,26/Aug/03 02:16;amamment;ASF.LICENSE.NOT.GRANTED--patch.txt;https://issues.apache.org/jira/secure/attachment/12332350/ASF.LICENSE.NOT.GRANTED--patch.txt,23/Aug/03 04:58;amamment;ASF.LICENSE.NOT.GRANTED--patch.txt;https://issues.apache.org/jira/secure/attachment/12332349/ASF.LICENSE.NOT.GRANTED--patch.txt,,,,,5.0,,,,,,,,,,,,,,,,20740.0,,,2003-06-14 00:35:53.0,,,false,,,,,,,,,,,,,,18916,,,Mon Sep 01 00:55:44 UTC 2003,,,,,,0|i0sjfr:,164626,,,,,,,,"14/Jun/03 00:35;amamment;
I'm attaching three patches....

1) TestMapUtilsPatch - test case to capture the error condition -
   ClassCastException if the map key is anything but a string.  

2) MapUtilsFixPatch - makes the following changes to MapUtils:
   A) Refactor common code from debupPrint and verbosePrint
   B) Remove the cast to String
   C) Rename ""key"" argument to debugPrint and verbosePrint as ""label"".  
      Paramter comment is updated appropriately.  

3) MapUtilsBehaviourPatch - changes behaviour of debug print
   A) Previously, debug print showed class names for any object values in the 
      map argument.  Any nested maps, however, although printed, were not 
      similarly treated.  Now the ""debug"" nature of the call propagates to 
      all nested maps - class names for values are always printed.  
   B) Debug print now also prints the class name of any nested map after the 
      map itself has been expanded - again, this is in line with the behaviour
      of debug print with any other type of value within the outer map.   ","14/Jun/03 00:36;amamment;Created an attachment (id=6796)
TestMapUtilsPatch - captures ClassCastException reported
","14/Jun/03 00:37;amamment;Created an attachment (id=6797)
MapUtilsFixPatch - Fixes problem reported + refactoring internally
","14/Jun/03 00:38;amamment;Created an attachment (id=6798)
MapUtilsBehaviourPatch - Changes behaviour of debugPrint to be propagate debug satus
","14/Jun/03 00:40;amamment;Please note that only one of MapUtilsFixPatch or MapUtilsBehaviourPatch should 
be applied.  The latter incorporates the former plus the additional changes to 
the behaviour of debugPrint.  (Forgot to mention this in my earlier 
comment.    ","21/Aug/03 04:08;scolebourne@joda.org;I have applied the first two patches, but not the third. The third makes sense 
(I think...) but as there is no test case I can't judge for sure. So, if you 
want it committed, can you resubmit the last patch together with a testcase 
against the latest CVS. Thanks
","23/Aug/03 04:57;amamment;The following attachment provides a patch of MapUtils which updates the 
behaviour of debugPrint as before, but, this time, includes test cases to test 
the expected output.  

A short summary of changes:

1) debugPrintIndent method was renamed printIndent - it is used both for debug 
printing and verbose printing.  Likewise, debugIndent field was renamed 
indentDepth.  Further, a field INDENT_STRING was added (to capture the actual 
WS string used for indenting) - these are refactoring/clarification changes 
which do not affect output at all. 

2) The ""debug"" nature of a print is now propagated to internal maps.  
Previously, only the contents of the outermost map was printed in debug mode.  
Any contained maps were printed in verbose mode.  

3) The ""debug"" behaviour of a print was extended to maps - the classnames of 
maps are now printed as part of the output (just like the classnames of map 
contents are printed).
","23/Aug/03 04:58;amamment;Created an attachment (id=7922)
New Patch including test case for debug mode printing
","23/Aug/03 04:59;amamment;Please note that the previous patch has been created as from the src 
directory.  Application of the patch from that level will change both main and 
test code to include the changes I propose.  ","24/Aug/03 16:50;scolebourne@joda.org;Patch applied with some changes and additional tests. You may want to check 
that my changes are OK for you. Thanks.","26/Aug/03 01:35;amamment;I disagree with two things in the changes made to my patch, though a bunch of 
the others are great!   I also have a question about one of your comments.... 

1) Some maps are allowed to have null keys.  Since the label field, during 
recursion, contains the key, the guard within verbosePrintInternal as 
currently stated will not print out any entry associated with a null key.  

2) I think that even when a nested map is present, the type of the map should 
be printed out in debug mode.  

3) You note that, in dealing with nested maps, it would make sense to have a 
stack.  I can see that - otherwise, there's the possibility of infinite 
recursion.  Is it acceptable to add an internal stack, and then add 
synchorization to the stack within utilities of this sort?  
","26/Aug/03 01:37;amamment;I will create and attach a patch for items 1 &  2 above, and would value input 
on item 3.  ","26/Aug/03 02:16;amamment;Created an attachment (id=7940)
Update to Allow printing of ""null"" label, and to output map type of nested self
","26/Aug/03 02:18;amamment;The patch attached does the following:
1) If the label supplied to debugPrint or verbosePrint is ""null"", then uses 
the string ""null"" as the label.  
2) If the value associated with a key is a reference to the containing map, 
then ""this MAP"" is printed when using verbosePrint, or ""this MAP "" and the 
type of the map is printed when using debugPrint.
3) Tests to show the above.  ","26/Aug/03 02:19;amamment;Note: 

For item 1 above - I essentially undid the changes that you had made to my 
original patch as this was my intention to begin with.  Please let me know why 
you felt it might be a problem to print ""null"" as the label if the label was 
null?  I think I may be missing something?

","26/Aug/03 02:23;amamment;I also just checked backwards in the revision history - printing of the label 
(key) as ""null"" was the behaviour prior to my initial change proposals for 
debugPrint and verbosePrint.  ","26/Aug/03 03:42;scolebourne@joda.org;The reason I made the label change was that it doesn't make sense to me that a 
null label should print 'null =' at the top level. null is generally used to 
mean 'ignore this argument', hence I made null just not output the label.

You are correct however that it should print the label null when nested. So I 
have fixed this.

I have also updated the 'this Map' message to be the same as AbstractMap uses.

See what you think.","27/Aug/03 01:47;amamment;Great.  

I like the ""standardization"" with the output of AbstractMap.  I also like how 
you've handled the label.  But I'm still concerned at the handling of null 
maps.  If both label and map are null, then the call to this function 
essentially vanishes....  Whether or not the label is printed out on the first 
call, should the fact that the map is null at least be recorded with 
a ""null""?  

I can provide a patch - one line change - if appropriate.  
","27/Aug/03 07:43;scolebourne@joda.org;Add a patch for what you believe is sensible, it always helps.",01/Sep/03 00:55;scolebourne@joda.org;Change made to output null if map is null and null label,,,,,,,,,,,,,,,,,,,,,,,,,,,
[collections] Open Patch 25553 for version 3.0,COLLECTIONS-81,12341493,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Incomplete,,stefan.damian@snt.ro,stefan.damian@snt.ro,07/Jun/04 19:46,15/Mar/08 21:36,07/Apr/19 20:37,15/Mar/08 21:36,3.0,,,,,,,,,,,,,,0,,,,Patch 25553 wasn't corrected in collection - final version 3.0,"Operating System: other
Platform: Other",,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,29423.0,,,2004-06-08 03:18:57.0,,,false,,,,,,,,,,,,,,18917,,,Sun Jun 26 01:44:43 UTC 2005,,,,,,0|i0sjfz:,164627,,,,,,,,"07/Jun/04 20:13;stefan.damian@snt.ro;What's happen with collection-3.0.jar but works with 2.1
        at org.apache.velocity.texen.ant.TexenTask.execute(TexenTask.java:546)
        at org.apache.tools.ant.Task.perform(Task.java:317)
        at org.apache.tools.ant.Target.execute(Target.java:309)
        at org.apache.tools.ant.Target.performTasks(Target.java:334)
        at org.apache.tools.ant.Project.executeTarget(Project.java:1306)
        at org.apache.tools.ant.taskdefs.Ant.execute(Ant.java:371)
        at org.apache.tools.ant.taskdefs.CallTarget.execute(CallTarget.java:143)

        at org.apache.tools.ant.Task.perform(Task.java:317)
        at org.apache.tools.ant.Target.execute(Target.java:309)
        at org.apache.tools.ant.Target.performTasks(Target.java:334)
        at org.apache.tools.ant.Project.executeTarget(Project.java:1306)
        at com.snt.dbi.editor.util.DBIWrapper.runBuild(DBIWrapper.java:652)
        at com.snt.dbi.editor.util.DBIWrapper$1.construct(DBIWrapper.java:580)
        at com.snt.dbi.editor.util.SwingWorker$2.run(SwingWorker.java:146)
        at java.lang.Thread.run(Thread.java:534)
--- Nested Exception ---
java.lang.IllegalStateException: infinite loop in property interpolation of ${da
tabaseName}: databaseName->databaseName
        at org.apache.commons.collections.ExtendedProperties.interpolateHelper(E
xtendedProperties.java:293)
        at org.apache.commons.collections.ExtendedProperties.interpolateHelper(E
xtendedProperties.java:304)
        at org.apache.commons.collections.ExtendedProperties.interpolate(Extende
dProperties.java:236)
        at org.apache.commons.collections.ExtendedProperties.getString(ExtendedP
roperties.java:1021)
        at org.apache.commons.collections.ExtendedProperties.getString(ExtendedP
roperties.java:1004)
        at org.apache.velocity.texen.ant.TexenTask.execute(TexenTask.java:466)","08/Jun/04 03:18;scolebourne@joda.org;Can you please provide a test case, or something reproducable? 
ExtendedProperties is really being replaced by commons-configuration so I'm not 
great at spotting issues with it.","23/May/05 08:09;scolebourne@joda.org;This bug is moving into the NeedInfo state.

This means that we need more info (in this case a small test case, preferably
junit) that can demonstrate the problem.",26/Jun/05 01:44;scolebourne@joda.org;Closing as INVALID as no info provided. Please reopen if you provide info.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
[Patch] [Collections] ExtendedProperties.interpolate does not do recursive substitution,COLLECTIONS-80,12341157,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,whoschek@lbl.gov,whoschek@lbl.gov,16/Dec/03 12:15,15/Mar/08 21:36,07/Apr/19 20:37,15/Mar/08 21:36,2.1,,,,,,,,,,,,,,0,,,,"[Patch] [Collections] ExtendedProperties.interpolate does not do recursive
substitution in commons-collections-2.1, but it probably should, when used with
getString(...).

Example:

firefish.home=/tmp/firefish
database.dir=${firefish.home}/samples/cfengine
database.file=${database.dir}/db.xml

extendedProps.getString(""database.file"")

I found out that this can be fixed with the patch below, which is simply a copy
and paste from the CVS of org.apache.commons.configuration.AbstractConfiguration.

	/**
	 * interpolate key names to handle ${key} stuff
	 *
	 * @param base string to interpolate
	 *
	 * @return returns the key name with the ${key} substituted
	 */
	protected String interpolate(String base)
	// copied from org.apache.commons.configuration.AbstractConfiguration
	{
		return (interpolateHelper(base, null));
	}

	/**
	 * Recursive handler for multple levels of interpolation.
	 *
	 * When called the first time, priorVariables should be null.
	 *
	 * @param base string with the ${key} variables
	 * @param priorVariables serves two purposes: to allow checking for
	 * loops, and creating a meaningful exception message should a loop
	 * occur.  It's 0'th element will be set to the value of base from
	 * the first call.  All subsequent interpolated variables are added
	 * afterward.
	 *
	 * @return the string with the interpolation taken care of
	 */
	protected String interpolateHelper(String base, List priorVariables)
	// copied from org.apache.commons.configuration.AbstractConfiguration
	{
		if (base == null)
		{
			return null;
		}

		// on the first call initialize priorVariables
		// and add base as the first element
		if (priorVariables == null)
		{
			priorVariables = new ArrayList();
			priorVariables.add(base);
		}

		int begin = -1;
		int end = -1;
		int prec = 0 - END_TOKEN.length();
		String variable = null;
		StringBuffer result = new StringBuffer();

		// FIXME: we should probably allow the escaping of the start token
		while (((begin = base.indexOf(START_TOKEN, prec + END_TOKEN.length()))
			> -1)
			&& ((end = base.indexOf(END_TOKEN, begin)) > -1))
		{
			result.append(base.substring(prec + END_TOKEN.length(), begin));
			variable = base.substring(begin + START_TOKEN.length(), end);

			// if we've got a loop, create a useful exception message and throw
			if (priorVariables.contains(variable))
			{
				String initialBase = priorVariables.remove(0).toString();
				priorVariables.add(variable);
				StringBuffer priorVariableSb = new StringBuffer();

				// create a nice trace of interpolated variables like so:
				// var1->var2->var3
				for (Iterator it = priorVariables.iterator(); it.hasNext();)
				{
					priorVariableSb.append(it.next());
					if (it.hasNext())
					{
						priorVariableSb.append(""->"");
					}
				}

				throw new IllegalStateException(
					""infinite loop in property interpolation of ""
						+ initialBase
						+ "": ""
						+ priorVariableSb.toString());
			}
			// otherwise, add this variable to the interpolation list.
			else
			{
				priorVariables.add(variable);
			}

			//QUESTION: getProperty or getPropertyDirect
			Object value = getProperty(variable);
			if (value != null)
			{
				result.append(interpolateHelper(value.toString(),
					priorVariables));

				// pop the interpolated variable off the stack
				// this maintains priorVariables correctness for
				// properties with multiple interpolations, e.g.
				// prop.name=${some.other.prop1}/blahblah/${some.other.prop2}
				priorVariables.remove(priorVariables.size() - 1);
			}
			else if (defaults != null && defaults.getString(variable,
				null) != null)
			{
				result.append(defaults.getString(variable));
			}
			else
			{
				//variable not defined - so put it back in the value
				result.append(START_TOKEN).append(variable).append(END_TOKEN);
			}
			prec = end;
		}
		result.append(base.substring(prec + END_TOKEN.length(), base.length()));

		return result.toString();
	}","Operating System: other
Platform: Other",,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,25553.0,,,2003-12-30 02:19:15.0,,,false,,,,,,,,,,,,,,18918,,,Tue Dec 30 02:19:15 UTC 2003,,,,,,0|i0sjg7:,164628,,,,,,,,"30/Dec/03 02:19;scolebourne@joda.org;Change made, thanks.

Hopefully [configuration] will replace this class soon.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
[collections] [RFE] MapToArrayTransformer,COLLECTIONS-79,12341610,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Won't Fix,,cote@computer.org,cote@computer.org,05/Aug/04 01:11,15/Mar/08 21:36,07/Apr/19 20:37,15/Mar/08 21:36,,,,,,,,,,,,,,,0,,,,"There is transformer received map and return a array containing the values of a
list of keys.  If I write proper javadoc and test case, could it be included in
commons collections.","Operating System: other
Platform: Other",,,,,,,,,,,,,,,,,,05/Aug/04 01:14;cote@computer.org;ASF.LICENSE.NOT.GRANTED--MapToArrayTransformer.java;https://issues.apache.org/jira/secure/attachment/12333023/ASF.LICENSE.NOT.GRANTED--MapToArrayTransformer.java,,,,,,,,,1.0,,,,,,,,,,,,,,,,30474.0,,,2004-10-17 06:00:49.0,,,false,,,,,,,,,,,,,,18919,,,Sun Oct 17 06:00:49 UTC 2004,,,,,,0|i0sjgf:,164629,,,,,,,,"05/Aug/04 01:14;cote@computer.org;Created an attachment (id=12332)
The proposed transformer
","17/Oct/04 06:00;scolebourne@joda.org;Thanks for your submission.

The aim of the functor package in [collections] is to provide basic functors, 
not application specific ones. Whilst I can understand that this transformer 
manipulates collections objects, I don't believe that it is a truly basic 
functor suitable for collections.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
BinaryHeap.remove(Object) seems to break heap order,COLLECTIONS-78,12341179,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,sphelps@csc.liv.ac.uk,sphelps@csc.liv.ac.uk,30/Dec/03 16:46,15/Mar/08 21:36,07/Apr/19 20:37,15/Mar/08 21:36,Nightly Builds,,,,,,,,,,,,,,0,,,,"I am currently attempting to migrate from my own implementation of a BinaryHeap
to the implementation in org.apache.commons.collections.BinaryHeap.

I have some existing unit tests for my implementation which fail when I run them
on the commons BinaryHeap.  Below is source-code for the JUnit test which fails.
 The test 'testRandom' is the test that fails.  This test creates heaps
initialised with 100 randomly generated Integers and proceeds to add and remove
random elements from these heaps and then checks the heap order.  Some of the
elements that are removed may not exist in the heap.  Heap order is checked by
disassembling the heap using BinaryHeap.pop() and ensuring that subsequent
elements are >= earlier elements.

The problem appears to be related to the BinaryHeap.remove(Object) method-- if
this is commented out the test succeeds.  It may be the case that the problem
occurs when non-existant elements are removed, but I have not attempted to
verify this.  


---------
BinaryHeapTest.java
---------
/*
 * JASA Java Auction Simulator API
 * Copyright (C) 2001-2003 Steve Phelps
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 */

package test.uk.ac.liv.util;

import test.uk.ac.liv.PRNGTestSeeds;

import junit.framework.*;

//import uk.ac.liv.util.*;

import org.apache.commons.collections.BinaryHeap;

import java.util.Random;
import java.util.Iterator;
import java.util.LinkedList;

public class BinaryHeapTest extends TestCase {

  BinaryHeap h1;

  public BinaryHeapTest( String name ) {
    super(name);
  }

  public void setUp() {

    h1 = new BinaryHeap();

    h1.insert(new Integer(1));
    h1.insert(new Integer(3));
    h1.insert(new Integer(9));
    h1.insert(new Integer(3));
    h1.insert(new Integer(5));
    h1.insert(new Integer(7));
  }

  public void test() {
    System.out.println(""h1 = "" + h1);
    assertTrue( h1.contains(new Integer(3)) );
    assertTrue( h1.contains(new Integer(9)) );
    assertTrue( h1.contains(new Integer(1)) );
    assertTrue( h1.contains(new Integer(5)) );
    assertTrue( !h1.contains(new Integer(10)) );
    assertTrue( !h1.contains(new Integer(-1)) );
    Object x = h1.pop();
    System.out.println(""h1 after removing first = "" + h1);
    checkOrder(h1);
    assertTrue( ((Integer) x).equals(new Integer(1)));
    assertTrue( !h1.contains(new Integer(1)) );
    assertTrue( h1.contains(new Integer(3)) );
    assertTrue( h1.contains(new Integer(9)) );
    assertTrue( h1.contains(new Integer(5)) );
    h1.remove(new Integer(9));
    System.out.println(""h1 after removing 9 = "" + h1);
    assertTrue( h1.contains(new Integer(3)) );
    assertTrue( !h1.contains(new Integer(9)) );
    assertTrue( h1.remove( new Integer(3) ) );
    System.out.println(""h1 after removing 3 = "" + h1);
    // assertTrue( ! h1.contains(new Integer(3)) );
    x = h1.pop();
    System.out.println(""h1 after removing first = "" + h1);
    h1.pop();
    System.out.println(""h1 after removing first = "" + h1);
    assertTrue( h1.remove( new Integer(7) ) );
    System.out.println(""h1 after removing 7 = "" + h1);
    assertTrue( h1.isEmpty() );
    assertTrue( ! h1.remove( new Integer(7) ) );
    h1.add( new Integer(666) );
    h1.add( new Integer(667) );
    assertTrue( h1.remove(new Integer(667)) );
    assertTrue( h1.size() == 1 );
    assertTrue( ! h1.contains(new Integer(667)) );
    assertTrue( h1.remove(new Integer(666)) );

  }


  public void checkOrder( BinaryHeap h ) {
    System.out.println(""Checking order of "" + h);
    Integer lastNum = null;
    LinkedList l = new LinkedList();
    while ( !h.isEmpty() ) {
      Integer num = (Integer) h.pop();
      System.out.println(num);
      if ( lastNum != null && num.intValue() < lastNum.intValue() ) {
        System.out.println(""!!??***  "" + num + "" smaller than "" + lastNum);
      }
      assertTrue( lastNum == null || num.intValue() >= lastNum.intValue() );
      lastNum = num;
      l.add(num);
    }
    Iterator it = l.iterator();
    while ( it.hasNext() ) {
      h.add( it.next() );
    }
  }

  public void testRandom() {
    Random randGenerator = new Random(PRNGTestSeeds.UNIT_TEST_SEED);
    for( int i=0; i<1000; i++ ) {
      BinaryHeap h = new BinaryHeap();
      for( int r=0; r<100; r++ ) {
        h.add( new Integer( randGenerator.nextInt(100)) );
      }
      System.out.println(""Starting with heap "" + h);
      for( int r=0; r<20; r++ ) {
        System.out.println(""Attempting to remove "" + r);
        System.out.println(""result = "" + h.remove( new Integer(r) ) );
        Integer n = new Integer( randGenerator.nextInt(100) );
        System.out.println(""Adding "" + n);
        h.add(n);
      }
      checkOrder(h);
    }
  }


  public static void main( String[] args ) {
    junit.textui.TestRunner.run (suite());
  }

  public static Test suite() {
    return new TestSuite(BinaryHeapTest.class);
  }

}


/*
 * JASA Java Auction Simulator API
 * Copyright (C) 2001-2003 Steve Phelps
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 */


-------
PRNGTestSeeds.java
-------

package test.uk.ac.liv;

/**
 * The PRNG seed to use for deterministing unit-testing of seedable classes.
 * This was introduced for ecj10, which uses a seed based on the
 * current system time when using the null argument constructor.
 *
 * @author Steve Phelps
 * @version $Revision: 1.2 $
 */

public class PRNGTestSeeds {

  /**
   * The seed to use for all unit tests.
   */
  public static final long UNIT_TEST_SEED = 1465187;

}","Operating System: Linux
Platform: PC",,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,25818.0,,,2003-12-31 07:47:17.0,,,false,,,,,,,,,,,,,,18920,,,Fri Jan 02 08:35:25 UTC 2004,,,,,,0|i0sjgn:,164630,,,,,,,,"31/Dec/03 07:47;scolebourne@joda.org;The problem lies with the remove 19. Unfortunately, I don't understand the 
meachanics of this class, so I could be stuck solving it :-(","31/Dec/03 17:13;phil@steitz.com;There is nothing obviously wrong with the iterator remove() and simple
add/remove tests work fine.  The random test above fails sporadically, always
for elements which have had copies removed.  There is usually just one element
out of order (out of 100-110).  Very strange.  I will work on this.  ","31/Dec/03 17:15;sphelps@csc.liv.ac.uk;I've done a bit more investigation of the actual source for commons.BinaryHeap,
and I think that there might be a comparision missing from the remove() method
of the Iterator returned by BinaryHeap.iterator().  This iterator is used by
AbstractCollection to implement the remove(Object) method.  

Attached is the code for the method remove(Object x) from my own implementation
of BinaryHeap.  Notice that after we swap the last element with the deleted
element we need to do a comparision before deciding whether to percolate up or
down the heap.  The full code for my BinaryHeap is included at the end of this
message.


  public boolean remove( Object x ) {
    return remove(indexOf(x));
  }

  public boolean remove( int index ) {
    if ( index < 1 ) {
      return false;
    }
    Object x = get(size());
    set(index, x);
    contents.shrink();
    if ( index <= size() ) {
      if ( index > 1 && compare(x, get(index/2)) < 0 ) {
        percolateUp(index);
      } else {
        percolateDown(index);
      }
    }
    return true;
  }


------
uk.ac.liv.util.BinaryHeap
------
/*
 * JASA Java Auction Simulator API
 * Copyright (C) 2001-2003 Steve Phelps
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 */

package uk.ac.liv.util;

import java.util.Comparator;
import java.util.Iterator;
import java.util.Collection;
import java.util.Vector;

import java.io.Serializable;

/**
 * This Collection class represents a binary heap, also known as a priority queue.
 *
 * The underlying data structure is a Vector.  Items are organised in such
 * a way that retrieving the smallest, or largest, item can be done in O(1) time.
 *
 * @author Steve Phelps
 * @version $Revision: 1.8 $
 *
 */

public class BinaryHeap implements Collection, PriorityQueue, Serializable {

  /**
   * The default initial capacity of the underlying Vector.
   */
  static final int DEFAULT_CAPACITY = 100;

  /**
   * Used to assign a unique id to each heap.
   */
  static IdAllocator idAllocator = new IdAllocator();

  /**
   * A unique id for this heap.  Its used mainly for debugging purposes.
   */
  long id;


  /**
   * The underlying Vector data structure holding the elements of the heap.
   */
  HeapContents contents;

  /**
   * The Comparator used to order items in the heap.  If it is not present then the
   * compareTo method of the Comparable interface is used.
   */
  Comparator comparator;


  /**
   * Inner class used to iterate over items in the heap.
   */
  class HeapIterator implements Iterator {

      int currentIndex = 1;

      public HeapIterator() {
      }

      public boolean hasNext() {
        return currentIndex <= size();
      }

      public Object next() {
        return get(currentIndex++);
      }

      public void remove() {
      }

    }

  /**
   * Construct the binary heap.  Objects will be ordered according to the Comparable
   * interface.
   */
  public BinaryHeap( )
  {
    this(DEFAULT_CAPACITY);
  }

  /**
    * Construct the binary heap.
    *
    * @param comparator If this comparator is non-null then it is used to order
items in the heap.
    * @param capacity The initial capacity of the underlying Vector
    */
  public BinaryHeap( Comparator comparator, int capacity ) {
    id = idAllocator.nextId();
    contents = new HeapContents(capacity);
    this.comparator = comparator;
  }

  /**
   * Construct the binary heap.
   * @param capacity The initial capcity of the underlying Vector
   */
  public BinaryHeap( int capacity ) {
    this(null, capacity);
  }

  public BinaryHeap( Comparator comparator ) {
    this(comparator, DEFAULT_CAPACITY);
  }

  /**
   * Compares two objects using either the heap's comparator, if it is present, or
   * the result of the compareTo method on o1.  Both o1 and o2 must implement
   * Comparable if no comparator is present.
   *
   * @param o1 The first object to compare
   * @param o2 The second object to compare
   */
  public int compare( Object o1, Object o2 ) {
    if ( comparator != null ) {
      return comparator.compare(o1,o2);
    } else {
      return ((Comparable) o1).compareTo((Comparable) o2);
    }
  }

  public Iterator iterator() {
    return new HeapIterator();
  }


  /**
   * Transfer the first item of this heap into the second heap.
   *
   * @param toOther The heap to transfer to
   */
  public void transfer( PriorityQueue toOther ) {
    // if ( ! isEmpty() ) {
      toOther.insert(removeFirst());
    // }
  }

  /**
   * Insert into the priority queue, maintaining heap order.
   * Duplicates are allowed.
   *
   * @param x the item to insert.
   */
  public void insert( Object x ) {
    int index = size()+1;
    set(index, x);
    percolateUp(index);
  }

  public boolean add( Object x ) {
    insert(x);
    return true;
  }

  /**
   * Find the smallest item in the priority queue.
   *
   * @return the smallest item, or null, if empty.
   */
  public Object getFirst() {
    if( isEmpty() ) {
      return null;
    }
    return get(1);
  }

  /**
   * Test if the priority queue is logically empty.
   *
   * @return true if empty, false otherwise.
   */
  public boolean isEmpty() {
    return size() == 0;
  }

  public boolean retainAll( Collection other ) {
    throw new UnsupportedOperationException(""BinaryHeap does not implement
retainAll"");
  }

  public boolean removeAll( Collection other ) {
    throw new UnsupportedOperationException(""BinaryHeap does not implement
removeAll"");
  }

  public boolean addAll( Collection other ) {
    throw new UnsupportedOperationException(""BinaryHeap does not implement addAll"");
  }

  public boolean containsAll( Collection other ) {
    throw new UnsupportedOperationException(""BinaryHeap does not implement
containsAll"");
  }

  /**
   * Make the priority queue logically empty.
   */
  public void clear() {
    contents.clear();
  }

  public int indexOf( Object key ) {
    for( int i=1; i<=contents.getCurrentSize(); i++ ) {
      if ( key.equals(get(i)) ) {
        return i;
      }
    }
    return -1;
  }

  public Object pop() {
    return removeFirst();
  }

  public Object get() {
    return getFirst();
  }

  public Object peek() {
    return getFirst();
  }

  public boolean contains( Object key ) {
    return indexOf(key) > 0;
  }

  public boolean remove( Object x ) {
    return remove(indexOf(x));
  }

  public boolean remove( int index ) {
    if ( index < 1 ) {
      return false;
    }
    Object x = get(size());
    set(index, x);
    contents.shrink();
    if ( index <= size() ) {
      if ( index > 1 && compare(x, get(index/2)) < 0 ) {
        percolateUp(index);
      } else {
        percolateDown(index);
      }
    }
    return true;
  }

  /**
   * Remove the smallest item from the priority queue.
   * @return the smallest item, or null, if empty.
   */
  public Object removeFirst() {
    if( isEmpty() ) {
        return null;
    }

    Object minItem = getFirst();
    if ( size() > 1 ) {
      set(1, get(size()));
      percolateDown(1);
    }
    contents.shrink();

    return minItem;
  }

  public String toString() {
    StringBuffer out = new StringBuffer(""("" + getClass() + "" id:"" + id + ""
size:"" + size() + "" contents:(\n"");
    Iterator i = new HeapIterator();
    while ( i.hasNext() ) {
      out.append(""\t"" + i.next() + ""\n"");
    }
    out.append(""))"");
    return out.toString();
  }

  public Object[] toArray() {
    return contents.toArray();
  }

  public Object[] toArray( Object[] a ) {
    return contents.toArray(a);
  }

  public int size() {
    return contents.getCurrentSize();
  }


  /**
   * Internal method to percolate down in the heap.
   *
   * @param hole the index at which the percolate begins.
   */
  protected void percolateDown( int hole ) {
    int child;
    Object tmp = get(hole);

    for( ; hole * 2 <= size(); hole = child ) {
      child = hole * 2;
      if( child != size() &&
              compare(get(child+1), get(child)) < 0 )
          child++;
      if( compare(get(child), tmp) < 0 ) {
        set(hole, get(child));
      } else {
        break;
      }
    }
    set(hole, tmp);
  }

  protected void percolateUp( int hole ) {
    Object x = get(hole);
    for( ; hole > 1 && compare(x, get(hole/2)) < 0; hole /= 2 ) {
      set(hole, get(hole/2));
    }
    set(hole,x);
  }


  protected void set( int index, Object x ) {
    contents.set(index, x);
  }

  protected Object get( int index ) {
    return contents.get(index);
  }

}


/**
 * Basically a wrapper for Vector with indexing starting at 1.
 */

class HeapContents implements Serializable {

  /**
   * The underlying data
   */
  private Vector contents;

 /**
   * The current size of the heap.
   */
  private int currentSize, maxSize = 0;

  public HeapContents( int capacity ) {
    contents = new Vector(capacity);
    currentSize = 0;
  }

  protected void grow( int increment ) {
    currentSize += increment;
    contents.ensureCapacity(currentSize);
  }

  public void set( int index, Object obj ) {
    if ( index > currentSize ) {
      grow(index-currentSize);
    }
    if ( index > maxSize ) {
      maxSize = index;
      contents.add(index-1, obj);
    } else {
      contents.set(index-1, obj);
    }
  }

  public Object get( int index ) {
    return contents.get(index-1);
  }

  public void shrink() {
    currentSize--;
  }

  public int getCurrentSize() {
    return currentSize;
  }

  public void clear() {
    currentSize = 0;
  }

  public Object[] toArray() {
    return contents.toArray();
  }

  public Object[] toArray( Object[] a ) {
    return contents.toArray(a);
  }
}
","01/Jan/04 02:22;phil@steitz.com;Ouch!  Yes, looks ""obviously wrong"" to always percolate down.  Interestingly,
the pop() operations in checkOrder() usually repair the tree before an element
pops off out of sequence, which explains the low incidence of failures.

For example, the following test (using checkOrder() above) succeeds, but
produces output showing what looks to me to be bad heap state after the remove.
 The pop()s in checkOrder() repair the damage (when 0 is popped).

public void testAddRemove() {
        BinaryHeap h = new BinaryHeap();
        h.add(new Integer(0));
        h.add(new Integer(2));
        h.add(new Integer(4));
        h.add(new Integer(3));
        h.add(new Integer(8));
        h.add(new Integer(10));
        h.add(new Integer(12));
        h.add(new Integer(3));
        System.out.println(h);
        h.remove(new Integer(12));
        System.out.println(h);
        checkOrder(h);
    }

Output:

[ 0, 2, 4, 3, 8, 10, 12, 3 ]
[ 0, 2, 4, 3, 8, 10, 3 ] <-- 3 should have percolated up after taking 12's spot.

A small test case like above showing API failure would be nice.
 ","02/Jan/04 02:07;scolebourne@joda.org;Test case that fails:
    public void testAddRemove() {
        resetEmpty();
        BinaryBuffer heap = (BinaryBuffer) collection;
        heap.add(new Integer(0));
        heap.add(new Integer(2));
        heap.add(new Integer(4));
        heap.add(new Integer(3));
        heap.add(new Integer(8));
        heap.add(new Integer(10));
        heap.add(new Integer(12));
        heap.add(new Integer(3));
        confirmed.addAll(heap);
        System.out.println(heap);
        Object obj = new Integer(10);
        heap.remove(obj);
        confirmed.remove(obj);
        System.out.println(heap);
        verify();
    }
","02/Jan/04 02:55;phil@steitz.com;Thanks, Stephen.  I am completing final testing/review of a fix Modifing
remove() to decide whether to percolate up or down, and adding percolateUp
methods that take start indexes.  All tests (incl the one you just suggested w/
""BinaryHeap"" in place of ""BinaryBuffer"") pass.  ","02/Jan/04 08:35;phil@steitz.com;Fixed in nightly builds starting 1/2/04.

Modified iterator remove() to compare repositioned ""last"" element to its new
parent to decide whether to percolate up or down.  Added percolateUp methods
with starting indexes to support this.  

Thanks, Steve, for reporting (and identifying the source of) this bug.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
[collections] IteratorChain.remove() in combination with FilterIterator,COLLECTIONS-77,12342151,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,peter@clueless.be,peter@clueless.be,02/Apr/05 03:52,15/Mar/08 21:36,07/Apr/19 20:37,15/Mar/08 21:36,3.1,,,,,,,,,,,,,,0,,,,"IteratorChain.remove() throws IllegalStateException when one of the underlying
iterators is a FilterIterator

code:
http://nagoya.apache.org/eyebrowse/ReadMsg?listName=commons-dev@jakarta.apache.org&msgNo=64950","Operating System: Windows XP
Platform: Other",,,,,,,,,,,,,,,,,,03/Apr/05 05:18;jwcarman;ASF.LICENSE.NOT.GRANTED--34267 .patch;https://issues.apache.org/jira/secure/attachment/12333439/ASF.LICENSE.NOT.GRANTED--34267+.patch,02/Apr/05 03:53;peter@clueless.be;ASF.LICENSE.NOT.GRANTED--Main.java;https://issues.apache.org/jira/secure/attachment/12333438/ASF.LICENSE.NOT.GRANTED--Main.java,,,,,,,,2.0,,,,,,,,,,,,,,,,34267.0,,,2005-04-03 05:18:38.0,,,false,,,,,,,,,,,,,,18921,,,Tue May 17 20:57:21 UTC 2005,,,,,,0|i0sjgv:,164631,,,,,,,,"02/Apr/05 03:53;peter@clueless.be;Created an attachment (id=14607)
example
","03/Apr/05 05:18;jwcarman;Created an attachment (id=14610)
Here's a patch.

Here's a patch (with test case) which fixes the problem and doesn't break any
of the other test cases (at least not in collections).	Since I'm relatively
new to the project as a committer, I didn't want to go ahead and commit this
stuff until one of the experts checks it out.","16/May/05 01:59;scolebourne@joda.org;If it fixes it, I suggest you commit it.

However, the patch does have rather a lot of stylistic fixes which should be
made in a separate commit, if at all.","17/May/05 06:21;peter@clueless.be;(In reply to comment #3)
> If it fixes it, I suggest you commit it.
> 
> However, the patch does have rather a lot of stylistic fixes which should be
> made in a separate commit, if at all.

The fix worked. Since I myself did not create the patch/fix, but James Carman
did, I suggest James commits it.","17/May/05 20:39;jwcarman;I would have committed it a while ago, but I don't remember my password.  I used
to use SSH to remember my password when using CVS.  I have to figure out how to
have my password reset.","17/May/05 20:57;jwcarman;I checked it in.  Didn't see that little bit about svnpasswd on the FAQ site. 
Guess it boiled down to RTFM.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"FastArrayList, FastHashMap and FastTreeMap not cross-platform",COLLECTIONS-76,12340226,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Won't Fix,,pjack@sfaf.org,pjack@sfaf.org,17/May/02 23:51,15/Mar/08 21:36,07/Apr/19 20:37,15/Mar/08 21:36,,,,,,,,,,,,,,,0,,,,"An optimizing compiler or a processor pipeline can reorder the operations that 
clone the internal collection and reassign the reference to the clone.  A 
thread invoking a read operation can conceivably fetch a reference to a non-
fully-cloned collection, resulting in arbitrary behavior.  

There seems to be no way to actually fix this bug, given the current Java 
Memory Model.  The code does seem to work on architectures that supply their 
own more strict memory models, such as single-processor 386 systems.

At minimum, the documentation for these classes should be updated to indicate 
that they are not cross-platform.  

The Java Memory Model is currently under revision, and some future version of 
Java will allow these classes to work by making the internal collection 
reference volatile.  (In the future, the volatile keyword will have better 
semantics; a write to any volatile field by a thread will force a write of ALL 
modifications made by that thread).

References:

http://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html
http://www.javaworld.com/javaworld/jw-02-2001/jw-0209-double.html
http://www.javaworld.com/javaworld/jw-05-2001/jw-0525-double.html

(These all deal with the double-checked locking algorithm, but the concepts 
apply to these classes as well.  Do a google search for ""Bill Pugh"" for more in-
depth information).","Operating System: other
Platform: Other",,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,9206.0,,,2002-08-10 11:23:27.0,,,false,,,,,,,,,,,,,,18922,,,Sat Aug 10 11:24:00 UTC 2002,,,,,,0|i0sjh3:,164632,,,,,,,,"10/Aug/02 07:52;pjack@sfaf.org;Added documentation that explains the problem, so that users are aware.  I'm
setting it to ""WONTFIX"" because I don't think there is a way to fix the
double-checked locking problem that will work for all conceivable JVM
implementations.
","10/Aug/02 11:23;mas@apache.org;Reopening...  It is definately possible to write a thread safe, yet still
efficiently multi-threaded without the double-check locking.... it just needs to
be done very carefully...   the documentation added should be sufficient though...","10/Aug/02 11:24;mas@apache.org;And since the documentation is sufficient, now resolving the bug until ""later"".  ",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
[collections] PriorityBuffer ignores natural order of elements,COLLECTIONS-75,12342083,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Blocker,Incomplete,,bobik72@freenet.de,bobik72@freenet.de,01/Mar/05 23:52,16/May/06 12:16,07/Apr/19 20:37,16/May/06 12:16,3.1,,,,,,,,,,,,,,0,,,,"The following code snippet:
-------------------------------
PriorityBuffer r = new PriorityBuffer();
r.add(new Integer(2));
r.add(new Integer(1));
r.add(new Integer(0));
for (Iterator it = r.iterator(); it.hasNext(); )
	System.out.println("":""+it.next());
-------------------------------
Prints this
:0
:2
:1","Operating System: All
Platform: All",,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,33788.0,,,,,,false,,,,,,,,,,,,,,18923,,,Wed Mar 02 00:16:26 UTC 2005,,,,,,0|i0sjhb:,164633,,,,,,,,"02/Mar/05 00:16;bobik72@freenet.de;Ok I noticed you have to use remove() to access elements in the natural order.
The  javadoc API could be a bit more specific about that - there is no word
about remove() returning elems in natural order and iterator() returning elems
in random order. As a matter of fact, an iterator in natural order would be useful.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
[collections] Predicated Collections Throw IllegalStateException,COLLECTIONS-74,12341382,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,nick@systemmobile.com,nick@systemmobile.com,01/Apr/04 12:50,15/Mar/08 21:36,07/Apr/19 20:37,15/Mar/08 21:36,,,,,,,,,,,,,,,0,,,,"When calling ListUtils.predicatedList(List,Predicate), the underlying class used
to create the predicated collection throws an IllegalArgumentException when it
encounters an item that failed evaluation.  This is not the documented behavior
for ListUtils, and it makes that method unusable. 

It probably effects the other predicated collections available in the other
Utils classes.","Operating System: other
Platform: Other",,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,28115.0,,,2004-04-02 04:13:12.0,,,false,,,,,,,,,,,,,,18924,,,Fri Apr 02 04:13:12 UTC 2004,,,,,,0|i0sjhj:,164634,,,,,,,,02/Apr/04 01:38;nick@systemmobile.com;Sorry for the mistake.  I meant to say that they throw IllegalArgumentExceptions.,02/Apr/04 04:13;scolebourne@joda.org;Extra javadoc added,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
BeanMap.putAllWriteable() does not count the write only methods,COLLECTIONS-73,12340477,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,dimiter@blue-edge.bg,dimiter@blue-edge.bg,09/Jan/03 02:26,15/Mar/08 21:36,07/Apr/19 20:37,15/Mar/08 21:36,2.1,,,,,,,,,,,,,,0,,,,"BeanMap.putAllWriteable(BeanMap) method, the java doc does not describe the implementation 
correctly.
According to Sun a property could be defined by getter OR mutator. The current 
implementation of the method assumes that a property always should have getter.

/**
 *  
Puts all of the writeable properties from the given BeanMap into this
 *  BeanMap.  Read-only 
properties will be ignored.
 */
 public void putAllWriteable(BeanMap map) {
   Iterator 
readableKeys = map.readMethods.keySet().iterator();
   while(readableKeys.hasNext()) 
{
     Object key = readableKeys.next();
     if(getWriteMethod(key) != null) {
       this.put(key, 
map.get(key));
     }
   }
 }


I have an adapter bean which have a mutator which accepting a 
long value (actualy a bit vector) And few boolean accessors which retrieve the actual values. 
Now I'm replacing my own utility classes with jakarta commons and I find that these issues make 
them nearly unusable for me :(

I suggest to change the method to:

 public void 
putAllWriteable(BeanMap map) {
   Iterator writableEntries = 
map.writeMethods.entrySet().iterator();
   while(writableEntries.hasNext()){
     
Map.Entry writableEntry = (Map.Entry) writableEntries.next();
     
writeMethods.put(writableEntry.getKey(), writableEntry.getValue());    
   }       
 }","Operating System: All
Platform: All",,,,,,,,,,,,,,,,,,09/Jan/03 02:26;dimiter@blue-edge.bg;ASF.LICENSE.NOT.GRANTED--TestBeanMap.patch;https://issues.apache.org/jira/secure/attachment/12332097/ASF.LICENSE.NOT.GRANTED--TestBeanMap.patch,,,,,,,,,1.0,,,,,,,,,,,,,,,,15897.0,,,2003-01-25 20:10:05.0,,,false,,,,,,,,,,,,,,18925,,,Sat Jan 25 20:10:05 UTC 2003,,,,,,0|i0sjhr:,164635,,,,,,,,"09/Jan/03 02:26;dimiter@blue-edge.bg;Created an attachment (id=4375)
test case
","09/Jan/03 02:55;dimiter@blue-edge.bg;As I looked at the implementation of the class, I think that it's mostly a documentation error, 
though I'm not sure what this method should do...
I needed a way to get a view of all readable 
properties and all writable properties of a bean, or at least check the readability of a 
property...

perhaps to expose isReadable and isWritable public methods?
","25/Jan/03 20:10;scolebourne@joda.org;Change made to the CVS to make getReadMethod() and getWriteMethod public. These 
can be used to effectively test whether a property is read/write, read only or 
write only.
Stephen",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
[collections] java.lang.ArrayIndexOutOfBoundsException,COLLECTIONS-72,12342893,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Duplicate,,stijn.christiaens@vub.ac.be,stijn.christiaens@vub.ac.be,08/Feb/06 20:03,15/Mar/08 21:36,07/Apr/19 20:37,15/Mar/08 21:36,3.1,,,,,,,,,,,,,,0,,,,"In BoundedFifoBuffer (line 340):

                // Other elements require us to shift the subsequent elements

                int i = lastReturnedIndex + 1;

                while (i != end) {

                    if (i >= maxElements) {

                        elements[i - 1] = elements[0];

                        i = 0;

                    } else {

                        elements[i - 1] = elements[i];

                        i++;

                    }

                }
An AIOOBException is thrown at line 347 when trying to remove an element and i = 0.","Operating System: other
Platform: Other",,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,38565.0,,,2006-02-08 23:21:43.0,,,false,,,,,,,,,,,,,,18926,,,Thu Feb 09 01:08:26 UTC 2006,,,,,,0|i0sjhz:,164636,,,,,,,,"08/Feb/06 23:21;gudnabrsam@yahoo.com;Looking at the code I don't immediately see how this is possible.  Can you
attach a testcase (simple main() harness or whatever) that reproduces the problem?","08/Feb/06 23:31;stijn.christiaens@vub.ac.be;This is the code that caused the bug. The variable breadCrumbs is a
BoundedFifoBuffer, but we use the Collection interface.
The target is to run over the buffer. If we encounter an element equal to the
one we have, all next elements in the buffer must be removed.
The Exception happens when the first element in the collection is the element we
have, so all the remaining ones must be removed, and only the first can stay.
The exception happens at the call of iter.remove()

		// see if this crumb is already present, because if it is
		// we must remove all later ones for a natural feel
		// breadCrumbs is a BoundedFifoBuffer, but we use the interface Collection
		boolean remove = false;
		Iterator<BreadCrumb> iter = breadCrumbs.iterator();
		while (iter.hasNext()) {
			BreadCrumb tempCrumb = iter.next();
			if (remove) {
				iter.remove();
			}
			if (crumb.equals(tempCrumb)) {
				remove = true;
			}
		}","08/Feb/06 23:54;gudnabrsam@yahoo.com;Silly question: are you using org.apache.commons.collections.BoundedFifoBuffer
or org.apache.commons.collections.buffer.BoundedFifoBuffer?  Based on the code
you provided in the beginning, the former?  Maybe you should try the latter.","09/Feb/06 00:11;stijn.christiaens@vub.ac.be;Actually I am using a CircularFifoBuffer in my class, which extends the
...collections.buffer.BoundedFifoBuffer.","09/Feb/06 00:41;stijn.christiaens@vub.ac.be;This little class recreates the bug. It must have something to do with the
automatic remove (which increases the member attribute start), because if there
is no overflow (and thus automatic remove) the problem does not occur. I hope
this helps.

import java.util.Collection;
import java.util.Iterator;

import org.apache.commons.collections.buffer.CircularFifoBuffer;

public class Test {

	/**
	 * @param args
	 */
	public static void main(String[] args) {
		Collection<String> breadCrumbs = new CircularFifoBuffer(4);
		breadCrumbs.add(""1"");
		breadCrumbs.add(""2"");
		breadCrumbs.add(""3"");
		breadCrumbs.add(""4"");
		breadCrumbs.add(""5"");
		
		String current = ""2"";

		Iterator<String> iter = breadCrumbs.iterator();
		boolean remove = false;
		while (iter.hasNext()) {
			String temp = iter.next();
			if (remove) {
				iter.remove();
			}
			if (current.equals(temp)) {
				remove = true;
			}
		}
		if (!remove) {
			breadCrumbs.add(current);
		}
		
		iter = breadCrumbs.iterator();
		while (iter.hasNext()) {
			String temp = iter.next();
			System.out.println(temp);
		}		
	}

}
","09/Feb/06 01:03;gudnabrsam@yahoo.com;I can recreate w/ 3.1 but not with SVN HEAD; therefore the bug has already been
fixed.","09/Feb/06 01:05;gudnabrsam@yahoo.com;Looks like a duplicate of COM-1844.

*** This bug has been marked as a duplicate of 33071 ***",09/Feb/06 01:08;stijn.christiaens@vub.ac.be;Ok. Thanks for the swift assistance!,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Missing LICENSE in source distribution (commons-collections-1.0-src.tar.gz),COLLECTIONS-71,12340179,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Blocker,Fixed,,marrotte@cs.fsu.edu,marrotte@cs.fsu.edu,05/Mar/02 02:11,15/Mar/08 21:36,07/Apr/19 20:37,15/Mar/08 21:36,1.0,,,,,,,,,,,,,,0,,,,"The build.xml in ""commons-collections-1.0-src.tar.gz"", references the 
""LICENSE"" file that does not exist.

This blocks a successful build of the API docs, i.e. ""ant doc"" as in 
""README.TXT"".

I ""touched ../../LICENSE"" for a quick fix.

--MTM","Operating System: Linux
Platform: Other",,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,6855.0,,,2002-04-10 10:33:04.0,,,false,,,,,,,,,,,,,,18927,,,Wed Apr 10 10:33:04 UTC 2002,,,,,,0|i0sji7:,164637,,,,,,,,10/Apr/02 10:33;mas@apache.org;This was fixed in the Collections 2.0 release.  ,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
[collections] TreeList Collections.binarySearch problem - general remove() after previous() problem,COLLECTIONS-70,12342290,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,trim@atlas.cz,trim@atlas.cz,08/Jun/05 06:21,15/Mar/08 21:36,07/Apr/19 20:37,15/Mar/08 21:36,3.1,,,,,,,,,,,,,,0,,,,"Sometimes TreeList crashes if i tried to call:
  Collections.binarySearch(queue, n, comp);
with ArrayList is everything ok.

Exception in thread ""main"" java.lang.NullPointerException
	at 
org.apache.commons.collections.list.TreeList$TreeListIterator.previous
(TreeList.java:841)
	at java.util.Collections.get(Unknown Source)
	at java.util.Collections.iteratorBinarySearch(Unknown Source)
	at java.util.Collections.binarySearch(Unknown Source)
	at utils.queue.QueueSorted.put(QueueSorted.java:51)
	at framework.search.GraphSearch.solve(GraphSearch.java:53)
	at search.informed.BestFirstSearch.solve(BestFirstSearch.java:20)
	at Hlavni.main(Hlavni.java:66)","Operating System: Windows XP
Platform: Other",,,,,,,,,,,,,,,,,,09/Dec/05 07:58;trim@atlas.cz;ASF.LICENSE.NOT.GRANTED--Test.java;https://issues.apache.org/jira/secure/attachment/12333547/ASF.LICENSE.NOT.GRANTED--Test.java,09/Dec/05 07:30;trim@atlas.cz;ASF.LICENSE.NOT.GRANTED--Test.java;https://issues.apache.org/jira/secure/attachment/12333546/ASF.LICENSE.NOT.GRANTED--Test.java,11/Dec/05 21:45;trim@atlas.cz;ASF.LICENSE.NOT.GRANTED--TestCaseForBug35258.java;https://issues.apache.org/jira/secure/attachment/12333548/ASF.LICENSE.NOT.GRANTED--TestCaseForBug35258.java,,,,,,,3.0,,,,,,,,,,,,,,,,35258.0,,,2005-07-09 10:37:53.0,,,false,,,,,,,,,,,,,,18928,,,Sat Jan 21 10:50:10 UTC 2006,,,,,,0|i0sjif:,164638,,,,,,,,09/Jul/05 10:37;jwcarman;Do you have a test case for this? ,"17/Jul/05 02:10;scolebourne@joda.org;This report lead me to examine the previous() method, and it was broken in
various classes when remove() is used afterwards.

Changes in svn rv219343","09/Dec/05 07:30;trim@atlas.cz;Created an attachment (id=17185)
TestSuite
","09/Dec/05 07:37;trim@atlas.cz;I posted a test case for a bug. It seems as previous() metod is unstable after 
remove(o);

This test failed after something about 6-15 cycles of 
       	int i = Collections.binarySearch(pq, n);
        pq.remove(n);

","09/Dec/05 07:39;jwcarman;We can't use the test case as-is, since it uses JDK5 features, but we'll
retrofit it.  Does this test fail repeatedly at the same point?  ","09/Dec/05 07:58;trim@atlas.cz;Created an attachment (id=17186)
TestSuite for java 1.4
","09/Dec/05 08:05;trim@atlas.cz;The test not fail repeatedly at the same point, because there is shuffed 
ArrayList which is romoving from TreeList.
If TreeList is in same order as List which we are removing, than there is no 
error reported.","09/Dec/05 19:06;jwcarman;Why don't you try passing in a Random instance to the Collections.shuffle()
method?  You could seed it with a known value that fails every time.  You could do:

Collections.shuffle( noes, new Random( 1 ) );

That way, it would be more deterministic.","11/Dec/05 21:45;trim@atlas.cz;Created an attachment (id=17194)
Test case for  a COM-2138 version 2.0

It was a good idea to use seeded random generator for Collections.shuffle(). So
i was able to find much more suitable test case. This test case has TreeList
size only 5 nodes and the point of inconsistece of listIterator is known too.
It can be much more easy to solve that bug with this test case than with
previous one.
","21/Jan/06 10:50;scolebourne@joda.org;As always, a good test case makes all the difference.

Fixed in SVN 370952",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
[collections] Comparable on AbstractKeyValue,COLLECTIONS-69,12341973,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Won't Fix,,sksingh@synapsistech.com,sksingh@synapsistech.com,03/Jan/05 01:54,15/Mar/08 21:35,07/Apr/19 20:37,15/Mar/08 21:35,3.1,,,,,,,,,,,,,,0,,,,"Can either the AbstractKeyValue or DefaultKeyValue implement Comparable. Many a 
times, the KeyValue needs to be sorted on key,value and don't want to have 
screate a new Comparator in order to sort it","Operating System: All
Platform: All",,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,32914.0,,,2005-01-04 09:17:19.0,,,false,,,,,,,,,,,,,,18929,,,Tue Jan 04 09:17:19 UTC 2005,,,,,,0|i0sjin:,164639,,,,,,,,"04/Jan/05 09:17;scolebourne@joda.org;To make these classes Comparable would imply quite a lot for what would appear
to be an unusual case. In general, implementing additional interfaces in core
classes would be something I would deem a Bad Idea. Instead, the better approach
is to write a smaller, focussed Comparator, even though it seems to be a pain
intially.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
[collections] Concurrent modification in FastArrayList,COLLECTIONS-68,12342218,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,guilhem@kaffe.org,guilhem@kaffe.org,01/May/05 03:11,15/Mar/08 21:35,07/Apr/19 20:37,14/Jul/06 12:04,Nightly Builds,,,,,,,,,,,,,,1,,,,"I confirm a bug highlighted by GNU Classpath internal checkings concerning
FastArrayList. It uses two different paths for modifying a list and accessing it
in FastArrayList$ListIter.remove.

On 2005-04-30 SVN snapshot the line which causes problem is at
org.apache.commons.collections.FastArrayList$ListIter.remove
(FastArrayList.java:1308)

because previousIndex() is used on an iterator which has not followed the
modification introduced by a call to List.remove.

This bug is not detected by Sun's JDK.","Operating System: All
Platform: All",,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,34690.0,,,2005-05-08 01:30:59.0,,,false,,,,,,,,,,,,,,18930,,,Fri Jul 14 12:04:03 UTC 2006,,,,,,0|i0sjiv:,164640,,,,,,,,"08/May/05 01:30;ms419@freezone.co.uk;I just encountered this bug also

Here is a test case of FastArrayList$ListIter.remove which one expects should
work, but throws ConcurrentModificationException instead -
http://www.sfu.ca/~jdbates/tmp/commons-collections/TestFastArrayList.java

Here is a test case of the unfolded TestFastArrayList code which one expects
should throw ConcurrentModificationException & (at least with gnu classpath)
does - http://www.sfu.ca/~jdbates/tmp/commons-collections/TestClasspath.java

Thanks for your work on these excellent tools!

Jack","23/May/05 04:26;scolebourne@joda.org;I have committed a change to avoid calling previousIndex().

I can't test it using GNU Classpath easily, so I'll close the call, and leave it
to be re-opened if necessary.","24/May/05 13:48;ms419@freezone.co.uk;(In reply to comment #2)
> I can't test it using GNU Classpath easily, so I'll close the call, and leave it
> to be re-opened if necessary.

Cool - works awesome!

- but I think the change made to FastArrayList$ListIter.remove (FastArrayList.java:1308) must also be 
made to FastArrayList$SubList$SubListIter (FastArrayList.java:1222) before build tests will succeed - 
http://www.sfu.ca/~jdbates/tmp/commons-collections/patch


    [...]
    [junit] Testcase: testCollectionIteratorRemove(TestFastArrayList1.bulkTestSu
bList.testCollectionIteratorRemove) :   Caused an ERROR
    [junit] null
    [junit] java.util.ConcurrentModificationException
    [junit]    at java.util.AbstractList$2.checkMod (AbstractList.java:455)
    [junit]    at java.util.AbstractList$2.previousIndex (AbstractList.java:548)
    [junit]    at java.util.AbstractList$SubList$1.previousIndex (AbstractList.java:1114)
    [junit]    at org.apache.commons.collections.FastArrayList$SubList$SubListIter.previousIndex 
(FastArrayList.java:1206)
    [junit]    at org.apache.commons.collections.FastArrayList$SubList$SubListIter.remove 
(FastArrayList.java:1222)
    [junit]    at 
org.apache.commons.collections.collection.AbstractTestCollection.testCollectionIteratorRemove 
(AbstractTestCollection.java:836)
    [junit]    at java.lang.reflect.Method.invokeNative (Method.java)
    [junit]    at java.lang.reflect.Method.invoke (Method.java:616)
    [junit]    at java.lang.VirtualMachine.invokeMain (VirtualMachine.java)
    [junit]    at java.lang.VirtualMachine.main (VirtualMachine.java:108)
    [...]


Many thanks for your work on this!

Jack","25/May/05 07:40;scolebourne@joda.org;(In reply to comment #3)
Patch applied, thanks. Again, please re-open in case of issues.",14/Jul/06 12:04;bayard;Reopen/reclose to deal with migration bug.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
[collections] PriorityBuffer does not implement Serializable,COLLECTIONS-67,12342462,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Minor,Fixed,,sphelps@csc.liv.ac.uk,sphelps@csc.liv.ac.uk,12/Aug/05 23:42,15/Mar/08 21:35,07/Apr/19 20:37,15/Mar/08 21:35,3.1,,,,,,,,,,,,,,0,,,,"The class org.apache.commons.collections.buffer.PriorityBuffer does not
implement java.io.Serializable","Operating System: other
Platform: Other",,,,,,,,,,,,,,,,,,12/Aug/05 23:43;sphelps@csc.liv.ac.uk;ASF.LICENSE.NOT.GRANTED--PriorityBuffer.java.patch;https://issues.apache.org/jira/secure/attachment/12333706/ASF.LICENSE.NOT.GRANTED--PriorityBuffer.java.patch,12/Aug/05 23:45;sphelps@csc.liv.ac.uk;ASF.LICENSE.NOT.GRANTED--TestPriorityBuffer.java.patch;https://issues.apache.org/jira/secure/attachment/12333707/ASF.LICENSE.NOT.GRANTED--TestPriorityBuffer.java.patch,,,,,,,,2.0,,,,,,,,,,,,,,,,36163.0,,,2005-10-08 21:51:33.0,,,false,,,,,,,,,,,,,,18931,,,Sat Oct 08 21:51:33 UTC 2005,,,,,,0|i0sjj3:,164641,,,,,,,,"12/Aug/05 23:43;sphelps@csc.liv.ac.uk;Created an attachment (id=16019)
patch to make PriorityBuffer implement the Serializable interface

patch in unified format to make PriorityBuffer implement the Serializable
interface.  The class now implements Serializable and declares a
serialVersionUID field.","12/Aug/05 23:45;sphelps@csc.liv.ac.uk;Created an attachment (id=16020)
patch to org.apache.commons.collections.TestPriorityBuffer class

A new method 'testSerialization()' has been added which tests that heaps can be
serialized and restored safely.","08/Oct/05 21:51;scolebourne@joda.org;Change made (your patch was backwards, removing the code, not adding it)
thanks",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"FastArrayList, FastHashMap and FastTreeMap not thread safe",COLLECTIONS-66,12340202,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,pjack@sfaf.org,pjack@sfaf.org,10/Apr/02 22:03,15/Mar/08 21:35,07/Apr/19 20:37,15/Mar/08 21:35,,,,,,,,,,,,,,,0,,,,"Hi,

I noticed that version 2.0 of the Commons Collections
has been released so I thought I'd browse through the
code.  While doing so I noticed something about 
FastArrayList, FastHashMap and FastTreeMap.

List and Map objects can return views on their contents
that can be modified.  For instance, elements can be 
removed from an ArrayList via its iterator().  Elements
can be removed from a map via its keySet() or its values()
collection.  A TreeMap can also return a submap that can
be modified.  Generally, changes on a view of a collection
are reflected in the original and vice-versa.

The problem is, with FastArrayList or FastHashMap, in ""fast""
mode, if somebody tries to modify a collection view (say, a
keySet() of a FastHashMap) they will never enter the FastHashMap's
monitor.  The state of the FastHashMap can become corrupted if
more than one thread attempts to modify its keySet(); and threads
attempting a fast get(Object) on a FastHashMap while another
thread modifies its keySet() may get faulty data back.

Here's the list of methods that worry me:

FastArrayList.iterator()
FastArrayList.subList(int, int)

FastHashMap.keySet()
FastHashMap.entrySet()
FastHashMap.values()

FastTreeMap.keySet()
FastTreeMap.entrySet()
FastTreeMap.values()
FastTreeMap.subMap(Object, Object)
FastTreeMap.headMap(Object)
FastTreeMap.tailMap(Object)","Operating System: All
Platform: All",,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,7924.0,,,,,,false,,,,,,,,,,,,,,18932,,,Tue Aug 13 11:35:16 UTC 2002,,,,,,0|i0sjjb:,164642,,,,,,,,"13/Aug/02 11:35;pjack@sfaf.org;The collection views are now backed by the parent collection, even in fast mode.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
[collections] Collection inside Abstract[AnyCollection]Decorator really needed to be transient?,COLLECTIONS-65,12341697,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Cannot Reproduce,,xdury@hotmail.com,xdury@hotmail.com,07/Sep/04 21:42,15/Mar/08 21:35,07/Apr/19 20:37,15/Mar/08 21:35,3.1,,,,,,,,,,,,,,0,,,,"Hi,

I would like to know if there was any good reason for all abstract decorator 
classes (like AbstractMapDecorator) to have their decorated collection (map)
transient? It doesn't help when trying to store decorated collections with 
XStream for example... Maybe there's a -really- good reason but I can't see it.

thanks a lot and go on with the good work! :)

Xavier.","Operating System: other
Platform: Other",,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,31091.0,,,2004-09-08 04:01:18.0,,,false,,,,,,,,,,,,,,18933,,,Wed Sep 08 04:01:18 UTC 2004,,,,,,0|i0sjjj:,164643,,,,,,,,"08/Sep/04 04:01;scolebourne@joda.org;The transient tag is merely a marker to emphasise that the field will not be 
serialized automatically.

Since the Abstract*Decorator classes do not implement the Serializable 
interface themselves, the transient marker actually has no effect. Each 
subclass that IS serializable must manually store the map field using 
readObject/writeObject methods, as per the serialization spec.

The reason behind all of this is to maintain backwards compatability of 
Abstract*Decorator from v3.1 to v3.0, by not forcing all decorators to be 
serializable.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
[collections] UnboundedFifoBuffer deserialization is broken,COLLECTIONS-64,12342377,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,scolebourne@joda.org,scolebourne@joda.org,16/Jul/05 20:24,15/Mar/08 21:35,07/Apr/19 20:37,15/Mar/08 21:35,3.1,,,,,,,,,,,,,,0,,,,"The patch should be:

private void readObject(ObjectInputStream in) throws IOException,
ClassNotFoundException {
	in.defaultReadObject();
	int size = in.readInt();
-	buffer = new Object[size];     
+	buffer = new Object[size + 1];     
	for (int i = 0; i < size; i++) {
		buffer[i] = in.readObject();
	}
	head = 0;
	tail = size;
}

Setting tail = size - 1; just caused another bug (ie you couldn't get the last
element in the buffer). This is because tail is supposed to point to the next
unused cell in the buffer array. By creating the buffer to be size + 1, tail
will be set to a valid cell within buffer that is empty (but the cell before it
has an element in it), and the class works properly. 

Thomas Knych, Jordan Krey & Citigroup Analytics Dev team","Operating System: All
Platform: All",,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,35763.0,,,,,,false,,,,,,,,,,,,,,18934,,,Sat Jul 16 20:32:22 UTC 2005,,,,,,0|i0sjjr:,164644,,,,,,,,"16/Jul/05 20:32;scolebourne@joda.org;This class has an undocumented invariant that the buffer length must be at least
one larger than the size at all times. Comment on invariant added.

Patch applied, thanks.

svn rv219317 and rv219232",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"[collections] compile failes with jdk 1.5 due to ""enum""",COLLECTIONS-63,12341618,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Blocker,Cannot Reproduce,,georgmueller@gmx.net,georgmueller@gmx.net,06/Aug/04 05:21,02/May/13 02:28,07/Apr/19 20:37,15/Mar/08 21:35,,,,,,,,,,,,,,,0,,,,"enum is a keyword in jdk 1.5 
so a lot off commons (not only collections) did not compile.
A lot of variables have the name enum.
Could this be changed, please.","Operating System: other
Platform: Other",,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,30503.0,,,2004-09-23 05:23:57.0,,,false,,,,,,,,,,,,,,18935,,,Thu Sep 23 05:23:57 UTC 2004,,,,,,0|i0sjjz:,164645,,,,,,,,"23/Sep/04 05:23;scolebourne@joda.org;This was fixed for collections 3.1 I believe, and is certainly fixed on CVS.

Note I haven't tried compiling with 1.5, but there are no enum keywords.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
ReferenceMap contract,COLLECTIONS-62,12340436,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,efrancos@incontext.fr,efrancos@incontext.fr,27/Nov/02 17:50,15/Mar/08 21:35,07/Apr/19 20:37,15/Mar/08 21:35,2.1,,,,,,,,,,,,,,0,,,,"I switched from SoftRefHashMap to ReferenceMap and I noticed that the purge
method as become private and is called in many places in the source code, but
the documentation for the method states that it is called only for write operations.
I must be sure that the stale mappings are removed for read operations too
(ex:size) and though currently the implementation calls purge() for all read
methods as well this may change in the future.
I think that calling purge on all [relevant] public methods is the right
approach to preserve a coherent state.","Operating System: All
Platform: All",,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,14889.0,,,2003-01-25 20:35:02.0,,,false,,,,,,,,,,,,,,18936,,,Sat Jan 25 20:35:02 UTC 2003,,,,,,0|i0sjk7:,164646,,,,,,,,"25/Jan/03 20:35;scolebourne@joda.org;I have changed the javadoc for the purge() method to indicate that it is called 
from both read and write operations.
Stephen",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
[collections] FilterIterator doesn't reset when properties are set,COLLECTIONS-61,12342823,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,huw12345@hotmail.com,huw12345@hotmail.com,30/Dec/05 05:14,15/Mar/08 21:35,07/Apr/19 20:37,15/Mar/08 21:35,3.1,,,,,,,,,,,,,,0,,,,"Test case follows:

[pre]
    /**
     * Test that when the iterator is changed, the hasNext method
     * returns the correct response for the new iterator.
     */
    public void testSetIterator() {
        Iterator iter1 = Collections.singleton(new Object()).iterator();
        Iterator iter2 = Collections.EMPTY_LIST.iterator();
        
        FilterIterator filterIterator = new FilterIterator(iter1);
        filterIterator.setPredicate(TruePredicate.getInstance());
        
        assertTrue(""filterIterator should have an element"", 
filterIterator.hasNext());
        
        filterIterator.setIterator(iter2);
        
        assertTrue(""filterIterator should not have an element"", !
filterIterator.hasNext());
    }

    /**
     * Test that when the predicate is changed, the hasNext method
     * returns the correct response for the new predicate.
     */
    public void testSetPredicate() {
        Iterator iter = Collections.singleton(null).iterator();
        
        FilterIterator filterIterator = new FilterIterator(iter);
        filterIterator.setPredicate(TruePredicate.getInstance());
        
        assertTrue(""filterIterator should have an element"", 
filterIterator.hasNext());
        
        filterIterator.setPredicate(NotNullPredicate.getInstance());
        
        assertTrue(""filterIterator should not have an element"", !
filterIterator.hasNext());
    }
[/pre]","Operating System: other
Platform: Other",,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,38074.0,,,2005-12-30 05:25:30.0,,,false,,,,,,,,,,,,,,18937,,,Sat Jan 07 07:11:26 UTC 2006,,,,,,0|i0sjkf:,164647,,,,,,,,"30/Dec/05 05:25;jwcarman;Aren't you asserting the opposite of what you want to test?  

assertTrue(""filterIterator should not have an element"", !
filterIterator.hasNext());

Shouldn't this be:

assertFalse(""filterIterator should not have an element"", !
filterIterator.hasNext());","06/Jan/06 08:32;huw12345@hotmail.com;(In reply to comment #1)
> Aren't you asserting the opposite of what you want to test?  

I don't think so.  I admit that I'm living in the past because I'd forgotten 
that JUnit has assertFalse (added about four years ago), but possibly the 
formatting of my code has caused the confusion.  There's a ""!"" hanging at the 
end of the line that means that the test does have the meaning I intend.
","07/Jan/06 07:11;scolebourne@joda.org;Fixed, thanks",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Minor problems in SequencedHashMap and LRUMap,COLLECTIONS-60,12340239,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,pjack@sfaf.org,pjack@sfaf.org,09/Jun/02 04:42,15/Mar/08 21:35,07/Apr/19 20:37,15/Mar/08 21:35,Nightly Builds,,,,,,,,,,,,,,0,,,,"1.  The remove(Object) methods in the keySet and entrySet correctly remove null 
keys, but incorrectly return false after they do so.

2.  The retainAll(Collection) and removeAll(Collection) methods in the 
collection views do not properly modify the map's modCount, and thus will never 
cause a ConcurrentModificationException.","Operating System: other
Platform: Other",,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,9719.0,,,2002-06-09 14:15:57.0,,,false,,,,,,,,,,,,,,18938,,,Sun Jun 09 14:15:57 UTC 2002,,,,,,0|i0sjkn:,164648,,,,,,,,09/Jun/02 14:15;mas@apache.org;Fixed in latest CVS. ,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
[collections] FastArrayList iterator method throwing ConcurrentModificationException in 'fast' mode,COLLECTIONS-59,12341519,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,cooker123456@yahoo.com,cooker123456@yahoo.com,17/Jun/04 06:55,15/Mar/08 21:35,07/Apr/19 20:37,15/Mar/08 21:35,3.1,,,,,3.2,,,,,,,,,0,,,,"Please review the below code, I was under the impression that this not throw an
exception.

 

Thanks,

Rob Cooke.

 

----------------------------

 

 

import org.apache.commons.collections.FastArrayList;

import java.util.Iterator;

 

public class Test2 extends Thread{

  public static void main(String argv[]) throws Exception{

    FastArrayList array=new FastArrayList();

    array.add(""this"");

    array.add(""is"");

    array.add(""a"");

    new Test2(array).start();

    array.setFast(true);

    Thread.sleep(2000);

    array.add(""test"");

  }

  protected FastArrayList array;

  public Test2(FastArrayList array){

    this.array=array;

  }

  public void run(){

    for(Iterator i=array.iterator();i.hasNext();){

      try{Thread.sleep(1000);}catch(Exception e){}

      System.out.println(i.next());

    }

  }

}","Operating System: Linux
Platform: All",,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,29625.0,,,2004-06-23 04:19:24.0,,,false,,,,,,,,,,,,,,18939,,,Thu Jun 24 04:48:57 UTC 2004,,,,,,0|i0sjkv:,164649,,,,,,,,"23/Jun/04 04:19;scolebourne@joda.org;The code below should throw a ConcurrentModificationException. When using 
collections you are not permitted to iterate and update a collection from 
different threads.

FastArrayList does allow add/remove/clear from different threads, but not 
iteration. This is because iteration is not a single atomic operation.","23/Jun/04 05:18;cooker123456@yahoo.com;What does the below implementation note for the FastArrayList.iterator() method
mean then?

Thanks,
Rob.

IMPLEMENTATION NOTE - If the list is operating in fast mode, an Iterator is
returned, and a structural modification to the list is made, then the Iterator
will continue over the previous contents of the list (at the time that the
Iterator was created), rather than failing due to concurrent modifications.
","23/Jun/04 05:54;scolebourne@joda.org;It looks like your test code has a race condition. The line to setFast(true) is 
after the thread start (which creates the iterator). This might be what you are 
seeing.

In general, we would not advise relying on an implementation note as a 
guarantee of behaviour.","23/Jun/04 07:09;cooker123456@yahoo.com;I just tried several cases including moving the setFast() method prior to the
start(). I also tried not using multiple threads at all.  It simply does not
work... If this is the case it's impossible to loop (thread safely) through all
the elements of the array while in fast mode.  This makes the list fairly useless.

Thanks,
Rob.","24/Jun/04 04:48;scolebourne@joda.org;I took a proper look and found various holes. There was no easy full solution, 
however I have managed to make some simple changes which greatly enhance 
usability.

1) Fast mode SubList iterator add() then set() and add() then remove() now 
works correctly.

2) Fast mode Iterator add() doesn't break the iterator from then on.

3) Fast mode now allows modification EITHER via the Iterator methods OR via the 
List methods. Mixing them gives a ConcurrentModificationException.

4) Some extra tests added.

Change in CVS, but won't be in 3.1 (unless 3.1 has to be rebuilt).
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
[collections] [PATCH] patch to reduce object creation in CollectionUtils,COLLECTIONS-58,12340947,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Minor,Fixed,,janekdb@yahoo.co.uk,janekdb@yahoo.co.uk,08/Sep/03 05:29,15/Mar/08 21:35,07/Apr/19 20:37,15/Mar/08 21:35,Nightly Builds,,,,,,,,,,,,,,0,,,,"The attached patch reduces the number of Integer objects created when invoking
CollectionUtils.getCardinalityMap(final Collection col). The number of Integers
created is reduced by the count of unique objects within col.

The patch does not change the basic algorithm so the simplicity of the method is
not lost.

The change was profiled with the class below. These are the absolute times for
JDK 1.3.1_04 and 1.4.1_03

       1.4         1.3
pre:   168267      153849
post:  164473      150866

and normalised to the pre version for each JDK

       1.4         1.3
pre:   1.00        1.00
post:  0.98        0.98

so there was only a minor speed difference however the reduction in the number
of created objects has a memory use advantage. It was surprising to see that JDK
1.4.1 was slower than 1.3.1, in this limited test. The binaries were compiled
with JDK 1.4.1.

This is the test class:

import org.apache.commons.collections.CollectionUtils ;

import java.util.*;

public class CollectionUtilsTest {


    Set a ;
    Set b ;
    Set c ;

    Collection cols []  ;

    long startMillis ;
    void init () {

	a = new HashSet () ;
	for ( int i = 1 ; i <= 10000 ; i++ ) {
	    a.add ( new Integer ( i ) ) ;
	}

	b = new HashSet () ;
	for ( int i = 5001 ; i <= 15000 ; i++ ) {
	    b.add ( new Integer ( i ) ) ;
	}

	c = new HashSet () ;
	for ( int i = 1001 ; i <= 20000 ; i++ ) {
	    c.add ( new Integer ( i ) ) ;
	}

	cols = new Collection [] { a, b, c } ;

	startMillis = System.currentTimeMillis () ;
    }


    void run () {

	for ( int i = 0 ; i < 3 ; i++ ) {
	    for ( int j = 0 ; j < 3 ; j++ ) {
		CollectionUtils.union ( cols [ i ], cols [ j ] ) ;
		CollectionUtils.intersection ( cols [ i ], cols [ j ] ) ;
		CollectionUtils.disjunction ( cols [ i ], cols [ j ] ) ;
		CollectionUtils.subtract ( cols [ i ], cols [ j ] ) ;
	    }
	}

    }


    void report () {

	System.out.println ( ""Elapsed millis: "" + ( System.currentTimeMillis () -
startMillis ) ) ;
    }



    public static void main ( String  [] arg ) {

	CollectionUtilsTest t = new CollectionUtilsTest () ;

	t.init () ;
	t.run () ;
	t.report () ;

    }
}","Operating System: other
Platform: Other",,,,,,,,,,,,,,,,,,08/Sep/03 05:30;janekdb@yahoo.co.uk;ASF.LICENSE.NOT.GRANTED--CollectionUtils-object-creation-reduction.patch;https://issues.apache.org/jira/secure/attachment/12332507/ASF.LICENSE.NOT.GRANTED--CollectionUtils-object-creation-reduction.patch,,,,,,,,,1.0,,,,,,,,,,,,,,,,22973.0,,,2003-09-10 04:28:31.0,,,false,,,,,,,,,,,,,,18940,,,Wed Sep 10 04:28:31 UTC 2003,,,,,,0|i0sjl3:,164650,,,,,,,,"08/Sep/03 05:30;janekdb@yahoo.co.uk;Created an attachment (id=8095)
This patch reduces the number of objects created in getCardinalityMap
","10/Sep/03 04:28;scolebourne@joda.org;Patch applied, thanks",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Addition of static class modifer to inner classes,COLLECTIONS-57,12340801,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Minor,Fixed,,janekdb@yahoo.co.uk,janekdb@yahoo.co.uk,20/Jun/03 06:56,15/Mar/08 21:35,07/Apr/19 20:37,15/Mar/08 21:35,Nightly Builds,,,,,,,,,,,,,,0,,,,"findbugs 0.6.0 suggested that these classes had inner classes which could be
made static

    CursorableLinkedList.java
    DefaultMapBag.java
    ExtendedProperties.java
    StaticBucketMap.java

The attached patch file patches these classes in that way. After patching the
unit test passed okay.

I'm assuming the unit tests passing is proof enough that these changes are okay.","Operating System: All
Platform: All",,,,,,,,,,,,,,,,,,20/Jun/03 06:58;janekdb@yahoo.co.uk;ASF.LICENSE.NOT.GRANTED--static-diff.txt;https://issues.apache.org/jira/secure/attachment/12332370/ASF.LICENSE.NOT.GRANTED--static-diff.txt,,,,,,,,,1.0,,,,,,,,,,,,,,,,20931.0,,,2003-06-20 15:00:26.0,,,false,,,,,,,,,,,,,,18941,,,Fri Jun 20 15:00:26 UTC 2003,,,,,,0|i0sjlb:,164651,,,,,,,,"20/Jun/03 06:58;janekdb@yahoo.co.uk;Created an attachment (id=6899)
Patch to add 'static' class modifier to inner classes
","20/Jun/03 15:00;scolebourne@joda.org;Patch applied,
thanks",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
NoSuchElementException in ReferenceMap views,COLLECTIONS-56,12341156,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,nullforge@hotmail.com,nullforge@hotmail.com,16/Dec/03 08:57,15/Mar/08 21:35,07/Apr/19 20:37,15/Mar/08 21:35,Nightly Builds,,,,,,,,,,,,,,0,,,,"The keySet() and values() views for the 
org.apache.commons.collections.map.ReferenceMap class will throw a 
NoSuchElementException in their toArray(Object[]) methods if any keys or values 
have been reclaimed by the garbage collector and purge() has not been invoked.  
The toArray(Object[]) implementation inherited from 
java.util.AbstractCollection uses size()-based iteration rather than hasNext()-
based iteration.  This is inappropriate because the size of the map can change 
during iteration.  The problem is exacerbated by the fact that neither the 
KeySet nor Values classes purge stale elements from the list in their size() 
methods.

The attached test case reliably reproduces this exception with Sun's 1.3.1_07 
and 1.4.2 Win2K Hotspot VMs.

The attached diff is a proposed fix for this issue.","Operating System: All
Platform: PC",,,,,,,,,,,,,,,,,,16/Dec/03 08:58;nullforge@hotmail.com;ASF.LICENSE.NOT.GRANTED--ReferenceMapTest.java;https://issues.apache.org/jira/secure/attachment/12332658/ASF.LICENSE.NOT.GRANTED--ReferenceMapTest.java,16/Dec/03 08:59;nullforge@hotmail.com;ASF.LICENSE.NOT.GRANTED--diff.txt;https://issues.apache.org/jira/secure/attachment/12332659/ASF.LICENSE.NOT.GRANTED--diff.txt,,,,,,,,2.0,,,,,,,,,,,,,,,,25551.0,,,2003-12-29 23:37:48.0,,,false,,,,,,,,,,,,,,18942,,,Mon Dec 29 23:37:48 UTC 2003,,,,,,0|i0sjlj:,164652,,,,,,,,"16/Dec/03 08:58;nullforge@hotmail.com;Created an attachment (id=9594)
Test case for this issue.
","16/Dec/03 08:59;nullforge@hotmail.com;Created an attachment (id=9595)
Diff for proposed patch.
","29/Dec/03 23:37;scolebourne@joda.org;Patch applied, good catch, thanks.

I didn't apply the test case, as it may not fail in all circumstances (a 
general problem with testing this class ;-)",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
[collections] Filling out PredicatedXXX Javadoc - a functor package.html,COLLECTIONS-55,12341451,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,tobrien@discursive.com,tobrien@discursive.com,16/May/04 09:30,15/Mar/08 21:35,07/Apr/19 20:37,15/Mar/08 21:35,2.1,,,,,,,,,,,,,,0,,,,"In general Predicated collections and maps should probably be created before a 
data structure has any contents.  Maybe this is just an artifact of the way I 
use PredicatedList, but, nevertheless, I think all of the PredicatedXXX 
classes need fuller JavaDoc - possibly pointing to an anchor in the 
package.html for the functors package that talks about some scenarios for 
using PredicatedXXX classes.  Right now we don't have a good in JavaDoc 
explanation of the various ways to apply a Predicate to a collection.

(I'm on a Javadoc kick, sorry.)","Operating System: other
Platform: Other",,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,29018.0,,,2004-05-22 04:40:06.0,,,false,,,,,,,,,,,,,,18943,,,Sat May 22 04:40:06 UTC 2004,,,,,,0|i0sjlr:,164653,,,,,,,,22/May/04 04:40;scolebourne@joda.org;Additional docs added,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
[collections][PATCH] increase number of tests run from 2484 to 7429,COLLECTIONS-54,12340963,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Critical,Fixed,,janekdb@yahoo.co.uk,janekdb@yahoo.co.uk,14/Sep/03 04:29,15/Mar/08 21:35,07/Apr/19 20:37,15/Mar/08 21:35,Nightly Builds,,,,,,,,,,,,,,0,,,,"The attached file patches build.xml to use 'TestAllPackages' instead of
'TestAll' for the value of 'test.entry'. This results in a greater number of
tests being run.

project.xml also uses 'TestAll' but there this patch does not fix that becuase I
am not using maven.

(I find this situation a bit odd because Stephen Colebourne mentioned that some
bugs had been detected in o.a.c.collections.observed package a few days ago by
some tests and as far as I can see those tests would not have run without this
change. Is the use of ant deprecated or am I just not seeing something obvious
or customary?)","Operating System: other
Platform: Other",,,,,,,,,,,,,,,,,,14/Sep/03 04:30;janekdb@yahoo.co.uk;ASF.LICENSE.NOT.GRANTED--build-TestAllPackages.patch;https://issues.apache.org/jira/secure/attachment/12332518/ASF.LICENSE.NOT.GRANTED--build-TestAllPackages.patch,,,,,,,,,1.0,,,,,,,,,,,,,,,,23155.0,,,2003-09-17 15:36:18.0,,,false,,,,,,,,,,,,,,18944,,,Wed Sep 17 15:36:18 UTC 2003,,,,,,0|i0sjlz:,164654,,,,,,,,"14/Sep/03 04:30;janekdb@yahoo.co.uk;Created an attachment (id=8199)
patch to run more tests by using TestAllPackages instead of TestAll
","17/Sep/03 15:36;scolebourne@joda.org;Should be fixed now, thanks",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
[collections] Iterator.remove() in UnboundedFifoBuffer does not work,COLLECTIONS-53,12342371,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,schlosser@informatik.tu-darmstadt.de,schlosser@informatik.tu-darmstadt.de,14/Jul/05 18:29,15/Mar/08 21:35,07/Apr/19 20:37,15/Mar/08 21:35,3.1,,,,,,,,,,,,,,0,,,,"The implementation of Iterator.remove() in the unbounded fifo buffer is buggy.
It produces an ArrayIndexOutOfBoundExceptions when it needs to swap around the
end of the array to its start.

The code should be:

            public void remove() {
                if (lastReturnedIndex == -1) {
                    throw new IllegalStateException();
                }

                // First element can be removed quickly
                if (lastReturnedIndex == head) {
                    UnboundedFifoBuffer.this.remove();
                    lastReturnedIndex = -1;
                    return;
                }

                // Other elements require us to shift the subsequent elements
                /*
                 * This loop is buggy in the original implementation!
                 */
                int i = lastReturnedIndex + 1;
                while (i != tail) {
                    buffer[decrement(i)] = buffer[i];
                    i = increment(i);
                }

                lastReturnedIndex = -1;
                tail = decrement(tail);
                buffer[tail] = null;
                index = decrement(index);
            }

while the original buggy loop is:

                // Other elements require us to shift the subsequent elements
                int i = lastReturnedIndex + 1;
                while (i != tail) {
                    if (i >= buffer.length) {
                        buffer[i - 1] = buffer[0];
                        i = 0;
                    } else {
                        buffer[i - 1] = buffer[i];
                        i++;
                    }
                }","Operating System: All
Platform: All",,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,35733.0,,,2005-07-15 07:43:31.0,,,false,,,,,,,,,,,,,,18945,,,Sat Jul 16 20:19:10 UTC 2005,,,,,,0|i0sjm7:,164655,,,,,,,,"15/Jul/05 07:43;scolebourne@joda.org;I cannot find the original code you refer to.

Both versions of UnboundedFifoBuffer are correct in CVS (ie. they match your
fixed code), and neither shows any change in this code since creation.

Have you reported the bug in the right class and right version of [collections]?","15/Jul/05 16:43;schlosser@informatik.tu-darmstadt.de;The source downloadable from the web page:
http://apache.imsam.info/jakarta/commons/collections/source/commons-collections-3.1-src.zip
contains the code I have cited.

Well, but if the code is already fixed in the current CVS it will surely be ok
in the next release of commons collections...","16/Jul/05 20:17;scolebourne@joda.org;Sorry, I misread your original bug report","16/Jul/05 20:19;scolebourne@joda.org;Changes made to SVN rv219316.

BTW, your fix was incomplete, and it demonstrates again the value of having a
test case that shows the bug.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
[collections] Method that add a Object to a Collection if it was not null,COLLECTIONS-52,12341563,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,r.u.c.afonso@uol.com.br,r.u.c.afonso@uol.com.br,10/Jul/04 08:52,15/Mar/08 21:35,07/Apr/19 20:37,15/Mar/08 21:35,3.2,,,,,,,,,,,,,,0,,,,"It would be a new static method to CollectionUtils class. It would retur 
boolean because add() method from Collection returns a boolean. It would had 
only a line:

public static boolean addNotNull(Collection c, Object o) {
   return (o != null)? c.add(o): false;
}

Of course if c was null, it will throw a NullPointerException. 
Aparently it is possible use a PredicatedCollection with NotNullPredicate. But 
it will trhow a IllegalArgumentException if o was null. It is not interesting.","Operating System: other
Platform: Other",,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,30020.0,,,2004-07-18 04:41:09.0,,,false,,,,,,,,,,,,,,18946,,,Sun Jul 18 04:41:09 UTC 2004,,,,,,0|i0sjmf:,164656,,,,,,,,18/Jul/04 04:41;scolebourne@joda.org;addIgnoreNull() added to CollectionUtils,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
[collections] LRUMap loses values when resizing.,COLLECTIONS-51,12342936,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Critical,Incomplete,,davedandeneau@yahoo.com,davedandeneau@yahoo.com,23/Feb/06 01:15,15/Mar/08 21:35,07/Apr/19 20:37,15/Mar/08 21:35,3.1,,,,,,,,,,,,,,0,,,,"I am using the LRUMap and I have noticed that when it resizes the Map it loses
the values that were in it previously. I noticed this when it was resizing my
map from size of 2 to size of 4.","Operating System: Windows XP
Platform: PC",,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,38753.0,,,2006-02-23 01:25:11.0,,,false,,,,,,,,,,,,,,18947,,,Thu Feb 23 01:47:43 UTC 2006,,,,,,0|i0sjmn:,164657,,,,,,,,23/Feb/06 01:25;gudnabrsam@yahoo.com;Got any sample code to evoke the bug?,23/Feb/06 01:47;davedandeneau@yahoo.com;This appears to not be a problem with LRUMap. ,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
[collections] ExtendedProperties combine and pre unescaped strings-values,COLLECTIONS-50,12341107,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Won't Fix,,dean.arnold@digitalunion.com,dean.arnold@digitalunion.com,20/Nov/03 17:42,15/Mar/08 21:35,07/Apr/19 20:37,15/Mar/08 21:35,2.1,,,,,,,,,,,,,,0,,,,"If you have 2 extended props (prop1 & prop2). prop1 contains some or none
key/value pairs and prop2 contains at least one key with string value with
commas that doesn't already exist in prop1. N.B. This assumes both props were
loaded from property files and the string values in prop2 were escaped in the
file-system properties.

If you call prop1.combine(prop2), the string-value from prop2 that contained
commas is treated as a non-escaped string and thus broken down into a Vector in
prop1. It should put the string-value into prop1 without procing the commas as
there were already processed by prop2 when it was loaded.

I believe that the combine method should merge the existing values from both
props and the putAll method should be overidden to overite existing keys in
prop1 from prop2 while maintaining the keysAsListed List.","Operating System: other
Platform: All",,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,24849.0,,,2004-03-15 01:32:00.0,,,false,,,,,,,,,,,,,,18948,,,Mon Mar 15 01:32:00 UTC 2004,,,,,,0|i0sjmv:,164658,,,,,,,,"15/Mar/04 01:32;scolebourne@joda.org;All work on ExtendedProperties has migrated to the [configuration] project.

Patches will be considered to solve a clear bug (ie. test case + patch to fix 
are required), however ExtendedProperties is effectively being treated as no-
change in [collections] until a [configuration] release, when it will be 
deprecated.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
[collections] Compile Errors when Importing in VAJ 4,COLLECTIONS-49,12342169,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Won't Fix,,dmueller@electronicpartner.de,dmueller@electronicpartner.de,08/Apr/05 18:48,15/Mar/08 21:35,07/Apr/19 20:37,15/Mar/08 21:35,3.1,,,,,,,,,,,,,,0,,,,"Hi,
when I try to import Collections Framework into IBM VisualAge for Java (VAJ) 4,
I get loads of Compile Errors. 
(For your information: VAJ is Java 1.2.2 based...)

Most Errors are in the Testing Framework, so could be ignored.
However, there are quite a few Errors from using 

Entry 

instead of

Map.Entry,

for Example in 

AbstractReferenceMap
    public Object get(Object key) {
        purgeBeforeRead();
        Entry entry = getEntry(key);
        if (entry == null) {
            return null;
        }
        return entry.getValue();
    }

It would be nice for less adventurous users not to have to change the source
code in order to use this in VAJ. 

I can send you the changed sources.

Yours,
David

P.S.: The severity ""major"" is debatable... 8-)","Operating System: Windows 2000
Platform: PC",,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,34368.0,,,2005-05-09 00:21:29.0,,,false,,,,,,,,,,,,,,18949,,,Mon May 23 16:07:57 UTC 2005,,,,,,0|i0sjn3:,164659,,,,,,,,"08/Apr/05 18:52;dmueller@electronicpartner.de;Oh, I just found out, you could also add an import statement of 

import java.util.Map.Entry;

to the Classes.","09/May/05 00:21;jwcarman;Why do you have to import the source into VAJ in order to use Commons
Collections?  Can't you just use the binary version as a jar file on your classpath?","09/May/05 22:40;dmueller@electronicpartner.de;(In reply to comment #2)
I don't REALLY have to import the source for running the program, but as I was
debugging a shared cache using the LRUMap, I wanted to be able to step into the
collections methods.","23/May/05 03:00;scolebourne@joda.org;The committers of [collections] have no simple means to test this problem (no
VAJ). While we would consider applying a cvs diff -u patch, that would only be a
temporary fix. As soon as we edited the file to make some other fix, the chances
are that we would break the VAJ code again.

Closing as wontfix.","23/May/05 03:13;tomdz;While I'm not directly affected (havn't used VAJ for several years now), I find
this solution unsatisfactory. For one, while this may be a temporary solution it
would be a solution, and when the code gets broken again for VAJ, then another
bug can be raised.
Also, there is at least one easy way to make certain that Entry gets only used
as Map.Entry, and that is by incorporating PMD (http://pmd.sourceforge.net) in
the build process and write a specific rule for Map.Entry. Perhaps David would
volunteer to write this rule ?

WDYT ?
Tom
","23/May/05 04:14;jwcarman;My question is why is this a compile error with one compiler and not with
another?  Which one is correct by the JLS?","23/May/05 04:22;tomdz;This is most likely a bug in VAJ. A subclass inherits all accessible
(non-private) inner classes from its basetype just like it would inherit
accessible fields. Thus for subtypes of Map, its perfectly valid to access Entry
directly without the starting ""Map."".","23/May/05 04:26;jwcarman;So, why should we change code to work around a broken compiler in a tool that
very few folks use anymore?","23/May/05 04:33;tomdz;(In reply to comment #8)

Because its the right thing to do ? David has noted a problem that he has with
commons-collections, and he outlines the solution which is neither complicated
nor does break anything. He probably would even create a patch to fix it (there
shouldn't be too much problematic usages of Map.Entry). So why should we refuse
to incorporate it ?
","23/May/05 07:50;scolebourne@joda.org;As I wrote before, if a patch is supplied, then we may apply it. But I agree
with James that this is low priority. [collections] has very limited committer
time, so sometimes we have to pick and choose which tasks to do.","23/May/05 08:07;tomdz;(In reply to comment #10)
My mistake, it didn't sound like you would accept a patch either.
","23/May/05 16:07;dmueller@electronicpartner.de;I was not aware this is a VAJ issue only, not a JDK 1.2.2 one also. 
Still I think it's worth a patch as soon as I come to do it (haven't done this yet) 
cvs diff -u, you say?
Anyway - I'll try.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
[collections] TransformedMap putAll(empty map) causes IllegalArgumentException,COLLECTIONS-48,12342216,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,mlottman@carefx.com,mlottman@carefx.com,30/Apr/05 06:33,15/Mar/08 21:35,07/Apr/19 20:37,15/Mar/08 21:35,3.1,,,,,,,,,,,,,,0,,,,"If you create a TransformedMap, and then call map.putAll with an empty map as 
an argument, an IllegalArgumentException is thrown.  putAll should be able to 
handle empty maps without erroring.  The error occurs regardless of whether 
the decorated map has any contents.  The implementation of the Transformers 
attached does not matter.  I am using Java 1.4.2_07.

Example code:
Map map = TransformedMap.decorate(
        new HashMap(),
        TransformerUtils.nopTransformer(),
        TransformerUtils.nopTransformer());

map.putAll(new HashMap()); // This causes IllegalArgumentException!

Fails with the following error:

java.lang.IllegalArgumentException: Initial capacity must be greater than 0
	at org.apache.commons.collections.map.AbstractHashedMap.<init>
(AbstractHashedMap.java:142)
	at org.apache.commons.collections.map.AbstractHashedMap.<init>
(AbstractHashedMap.java:127)
	at org.apache.commons.collections.map.AbstractLinkedMap.<init>
(AbstractLinkedMap.java:95)
	at org.apache.commons.collections.map.LinkedMap.<init>
(LinkedMap.java:78)
	at org.apache.commons.collections.map.TransformedMap.transformMap
(TransformedMap.java:153)
	at org.apache.commons.collections.map.TransformedMap.putAll
(TransformedMap.java:190)
	at net.carefx.contextagent.plugin.ldapuser.PluginTest.main
(PluginTest.java:71)","Operating System: Windows XP
Platform: PC",,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,34686.0,,,2005-05-08 02:14:21.0,,,false,,,,,,,,,,,,,,18950,,,Thu Feb 09 23:44:42 UTC 2006,,,,,,0|i0sjnb:,164660,,,,,,,,08/May/05 02:14;scolebourne@joda.org;Fixed in SVN revision 169097,09/Feb/06 23:44;gudnabrsam@yahoo.com;*** COM-2746 has been marked as a duplicate of this bug. ***,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
[collections] [PATCH] fixes 97 typos,COLLECTIONS-47,12340938,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Minor,Fixed,,janekdb@yahoo.co.uk,janekdb@yahoo.co.uk,31/Aug/03 08:35,15/Mar/08 21:35,07/Apr/19 20:37,15/Mar/08 21:35,Nightly Builds,,,,,,,,,,,,,,0,,,,The attached patch fixes 97 typos in the version of collections from 03-August-31.,"Operating System: other
Platform: Other",,,,,,,,,,,,,,,,,,31/Aug/03 08:38;janekdb@yahoo.co.uk;ASF.LICENSE.NOT.GRANTED--collections-97-typos-030831.patch.txt;https://issues.apache.org/jira/secure/attachment/12332499/ASF.LICENSE.NOT.GRANTED--collections-97-typos-030831.patch.txt,,,,,,,,,1.0,,,,,,,,,,,,,,,,22843.0,,,2003-08-31 20:13:34.0,,,false,,,,,,,,,,,,,,18951,,,Mon Sep 01 16:08:16 UTC 2003,,,,,,0|i0sjnj:,164661,,,,,,,,"31/Aug/03 08:38;janekdb@yahoo.co.uk;Created an attachment (id=8010)
patch file to fix 97 typos in collections
","31/Aug/03 20:13;scolebourne@joda.org;Great patch, definitely fun to apply seeing all the stupid spelling.
thanks",01/Sep/03 16:08;janekdb@yahoo.co.uk;It was quite a bit of fun to do! Thanks for the commit.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"[collections] CollectionUtils.transformedCollection(c,t) doesn't transform the elements of c",COLLECTIONS-46,12341605,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Won't Fix,,gunnar.zarncke@tipp24.de,gunnar.zarncke@tipp24.de,30/Jul/04 19:26,15/Mar/08 21:35,07/Apr/19 20:37,15/Mar/08 21:35,3.1,,,,,,,,,,,,,,0,,,,"CollectionUtils.transformedCollection(c,t) doesn't transform the elements of c 
as documented in the API.
The implementation passes this collection to 
TransformedCollection.decorate(collection, transformer) 
and further to
new TransformedCollection(coll, transformer);
where super(c) simply stored it WITHOUT conversion.","Operating System: other
Platform: All",,,,,,,,,,,,,,,,,,04/Aug/04 20:07;cote@computer.org;ASF.LICENSE.NOT.GRANTED--CollectionUtils.diff;https://issues.apache.org/jira/secure/attachment/12333017/ASF.LICENSE.NOT.GRANTED--CollectionUtils.diff,,,,,,,,,1.0,,,,,,,,,,,,,,,,30408.0,,,2004-08-04 00:11:45.0,,,false,,,,,,,,,,,,,,18952,,,Wed Aug 04 20:19:54 UTC 2004,,,,,,0|i0sjnr:,164662,,,,,,,,"04/Aug/04 00:11;cote@computer.org;I wrote the following test case that seem to confirm the bug :

    public void testTransformedCollection_2() {
        List list = new ArrayList();
        list.add(""1"");
        list.add(""2"");
        list.add(""3"");
        Collection result = CollectionUtils.transformedCollection(list,
TRANSFORM_TO_INTEGER);
        assertTrue(""returned object should be a TransformedCollection"",
            result instanceof TransformedCollection);
        assertEquals(""The transformed collection has the same size"", 3,
result.size());
        assertTrue(""The transformed collection contains the transformation of
the first elements"",result.contains(new Integer(1)));
        assertTrue(""The transformed collection contains the transformation of
the second elements"",result.contains(new Integer(2)));
        assertTrue(""The transformed collection contains the transformation of
the third elements"",result.contains(new Integer(3)));
        assertFalse(""The transformed collection doesn't contain the
transformation of the first elements"",result.contains(""1""));
        assertFalse(""The transformed collection doesn't contain  the
transformation of the second elements"",result.contains(""2""));
        assertFalse(""The transformed collection doesn't contain  the
transformation of the third elements"",result.contains(""3""));
    }

(I will provide a proper patch to TestCollectionUtils.java as soon as I get
cvsgrab working with my proxy.)
","04/Aug/04 01:43;scolebourne@joda.org;The code is working as per the specification, see the factory method:

     * Factory method to create a transforming collection.
     * <p>
     * If there are any elements already in the collection being decorated, they
     * are NOT transformed.

Elements already in the collection when the TransformedCollection is created 
are not transformed.","04/Aug/04 13:58;gunnar.zarncke@tipp24.de;This behavior of not transforming elements already present is not specified in 
the CollectionUtils docs:

http://jakarta.apache.org/commons/collections/apidocs-
COLLECTIONS_3_1/org/apache/commons/collections/CollectionUtils.html#transformedC
ollection(java.util.Collection,%20org.apache.commons.collections.Transformer)

Besides, how else am I supposed to transform (read: map) a Collection other 
than with that method? 

","04/Aug/04 20:07;cote@computer.org;Created an attachment (id=12326)
Comments of the method transformedCollection
","04/Aug/04 20:19;cote@computer.org;I agree with you, it would be better if somebody copy paste the two line saying
that the elements already in the collection being decorated are NOT transformed.
 Actually, I find the javadoc of the method pretty confusing.  I'll try to
improve it and I'll submit a patch.

I don't think there is anything to apply a tranformer to the elements of a
collections. Maybe, you should submit a rfe for a new transformer.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
[collections] ReferenceMap size of bug.,COLLECTIONS-45,12342917,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Critical,Cannot Reproduce,,hemilycrutcher@yahoo.com,hemilycrutcher@yahoo.com,16/Feb/06 04:26,15/Mar/08 21:35,07/Apr/19 20:37,15/Mar/08 21:35,,,,,,,,,,,,,,,0,,,,"I have the following declaration of my map:

Here is the code:
System.err.println(""elements are "" + elements + ""\n\t  element size is "" + 
elements.size() + ""\n\tkey set "" + elements.keySet()  + ""\n\telements:"" + 
elements.values());
Iterator iter = elements.keySet().iterator();
       while (iter.hasNext()) {
	Object element =  iter.next();
	System.err.println(""next element:"" + element);
	}
        System.err.println(""--------------"");
Here is the results below, where usually the answer is 2 but occationally 3


elements are {Concept=ConceptImpl Concept, ValueSet=ConceptImpl ValueSet}
 element size is 3
key set [Concept, ValueSet]
elements:[ConceptImpl Concept, ConceptImpl ValueSet]
next element:Concept
next element:ValueSet
--------------
size:3","Operating System: other
Platform: PC",,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,38661.0,,,2006-02-16 04:36:18.0,,,false,,,,,,,,,,,,,,18953,,,Fri Mar 03 04:18:13 UTC 2006,,,,,,0|i0sjnz:,164663,,,,,,,,16/Feb/06 04:36;gudnabrsam@yahoo.com;Version?,"16/Feb/06 20:48;hemilycrutcher@yahoo.com;It is version 3.1.  I have a feeling the problem is that the week reference is 
still counted in the size, but is skipped over in the iteration. ",17/Feb/06 04:17;gudnabrsam@yahoo.com;Is your map being used by > 1 thread?,"03/Mar/06 04:18;scolebourne@joda.org;It is likely that this is the correct behaviour, as ReferenceMap specifically
exists to release keys and values when they are no longer referenced by the rest
of the program. Since this gc can occur at any point in time, there can be a
difference between the size seen in an iteration as opposed to the size seen via
size().

Please reopen with a full junit test case if you believe you are seeing a
genuine error.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Upgrade your version number,COLLECTIONS-44,12340259,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Minor,Fixed,,aheritier@sopragroup.com,aheritier@sopragroup.com,11/Jul/02 21:05,15/Mar/08 21:35,07/Apr/19 20:37,15/Mar/08 21:35,Nightly Builds,,,,,,,,,,,,,,0,,,,"Can you update your build xml to modify the component.version property.
It is actually setted to 2.0 and should be to 3.0 dev or 2.1 dev ??

Futhermore, the Manifest file is not automatically generated from build.xml 
properties.

I attach a copy of the build.xml and the Manifest files that I modified to 
automatically update the release number.

I let you to choose which number to use in the build.xml.

Here are diffs that I done from Cygwin because I can't access to the CVS 
Repository from my office :-(

diff MANIFEST.MF :

5c5
< Implementation-Version: @version@
---
> Implementation-Version: 2.0

diff build.xml :

97,99d96
<       <echo message=""-------- ${Name-Long} ${component.version} --------""/>
<       <filter  token=""version""               value=""${component.version}""/>
< 
254,256c251
<       <mkdir dir=""${workdir}/classes""/>
<       <mkdir dir=""${workdir}/conf""/>      
<       <copy todir=""${workdir}/classes"">
---
>       <copy todir=""${workdir}"">
261,263d255
<       <copy  todir=""${workdir}/conf"" filtering=""on"">
<          <fileset dir=""${source.src}/conf"" includes=""*.MF""/>
<       </copy>
268c260
<       <jar jarfile=""${dest.jardir.jar}"" 
manifest=""${workdir}/conf/MANIFEST.MF"">
---
>       <jar jarfile=""${dest.jardir.jar}"" 
manifest=""${source.src}/conf/MANIFEST.MF"">","Operating System: other
Platform: Other",,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,10686.0,,,2002-11-25 03:48:28.0,,,false,,,,,,,,,,,,,,18954,,,Mon Nov 25 17:07:23 UTC 2002,,,,,,0|i0sjo7:,164664,,,,,,,,"25/Nov/02 03:48;scolebourne@joda.org;version number fixed as part of 2.1 release.

I'm not changing Manifest.mf to be updated from build.xml. If you particularly 
want that, please reopen the bug report.","25/Nov/02 17:07;aheritier@sopragroup.com;No problemo, if you don't forgot to update the Manifest.jar.
The commons collection is provided with a lot of Jakarta projects and it is not 
very easy to see which of them uses the most recent release.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
[collections] serialVersionUID should be private,COLLECTIONS-43,12342636,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Minor,Fixed,,sebb@apache.org,sebb@apache.org,17/Oct/05 04:03,15/Mar/08 21:35,07/Apr/19 20:37,15/Mar/08 21:35,,,,,,,,,,,,,,,0,,,,"The following classes define serialVersionUID with default (package) access:

HashBag
TreeBag
functors.*
NodeCachingLinkedList
LRUMap

This field should be defined as private.","Operating System: other
Platform: Other",,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,37106.0,,,2005-11-04 08:07:14.0,,,false,,,,,,,,,,,,,,18955,,,Wed Nov 23 23:07:38 UTC 2005,,,,,,0|i0sjof:,164665,,,,,,,,"04/Nov/05 08:07;scolebourne@joda.org;My understanding is that this causes no technical issues. Are you raising this
as a 'neatness' issue?","04/Nov/05 10:26;sebb@apache.org;Yes, mainly neatness; they are not a problem per se.

But untidiness can sometimes mean there are other problems lurking...","23/Nov/05 08:52;scolebourne@joda.org;I've fixed those not in the functors package, but there were just too many in
functors for me to bother with :-)","23/Nov/05 09:06;elharo@metalab.unc.edu;Thanks for fixing the part you did, but this probably should probably be left
open until someone can get around to fixing the functors package too. Even if
it's not a huge problem now, a future version of Java or a different VM might
get pickier about this. ",23/Nov/05 23:07;jwcarman;I believe I got them all.  Let me know if you see any stragglers.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
[collections] PriorityBuffer iterator does not remove elements properly,COLLECTIONS-42,12342084,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Cannot Reproduce,,bobik72@freenet.de,bobik72@freenet.de,02/Mar/05 01:11,15/Mar/08 21:35,07/Apr/19 20:38,15/Mar/08 21:35,3.1,,,,,,,,,,,,,,0,,,,"The following code snippet:

System.out.println(""----------"");
PriorityBuffer s = new PriorityBuffer();
s.add(new Integer(1));
s.add(new Integer(2));
s.add(new Integer(3));
		
for (Iterator it = s.iterator(); it.hasNext(); s.remove() )
	System.out.println(it.next());
System.out.println(""----------"");

Prints this:
----------
1
3
----------
Element 2 is lost, contrary to javadoc of java.util.Iterator","Operating System: All
Platform: All",,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,33791.0,,,2005-03-23 08:06:42.0,,,false,,,,,,,,,,,,,,18956,,,Wed Mar 23 08:06:42 UTC 2005,,,,,,0|i0sjon:,164666,,,,,,,,"23/Mar/05 08:06;scolebourne@joda.org;The javadoc for PriorityBuffer states that the iterator may return results in a
random order, so there is no issue there.

Your code sample, is repeatable on my system, however it uses the remove method
of the map within the iterator. As a general rule for collections, you may not
alter the collection while you are iterating through it, except via the iterator
remove method.

Thus, I suspect that you reported this because you used s.remove() in the code
example when you should have used it.remove().",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
LazyCollections.lazyList.get(i) grows wrong,COLLECTIONS-41,12340285,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,nikolaj@joergensen-mail.dk,nikolaj@joergensen-mail.dk,07/Aug/02 13:39,15/Mar/08 21:35,07/Apr/19 20:38,15/Mar/08 21:35,Nightly Builds,,,,,,,,,,,,,,0,,,,"LazyCollections.lazyList.get(i) grows wrong when called with i == (size() -1).

If the list has 3 elements and LazyCollections.lazyList.get(2) is called then 
size of the list will grow to size == 4 because within bounds check says:

if(index < (this.listImpl.size()-1) {

Should be:

if(index < this.listImpl.size()) {","Operating System: other
Platform: Other",,,,,,,,,,,,,,,,,,09/Aug/02 13:58;nikolaj@joergensen-mail.dk;ASF.LICENSE.NOT.GRANTED--LazyCollections.java;https://issues.apache.org/jira/secure/attachment/12332001/ASF.LICENSE.NOT.GRANTED--LazyCollections.java,,,,,,,,,1.0,,,,,,,,,,,,,,,,11522.0,,,2002-08-13 07:33:25.0,,,false,,,,,,,,,,,,,,18957,,,Tue Aug 13 07:33:25 UTC 2002,,,,,,0|i0sjov:,164667,,,,,,,,"09/Aug/02 13:58;nikolaj@joergensen-mail.dk;Created an attachment (id=2671)
Changed within bounds check in LazyList.get(int index)
","13/Aug/02 07:33;pjack@sfaf.org;Note that LazyCollections has been replaced by:

ListUtils.lazyList
MapUtils.lazyMap
MapUtils.lazySortedMap

The ListUtils.lazyList implementation fixes the bug.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"ExtendedProperties.load should default to encoding ""8859_1""",COLLECTIONS-40,12340577,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,kirk@wolf-associates.com,kirk@wolf-associates.com,04/Mar/03 03:47,15/Mar/08 21:35,07/Apr/19 20:38,15/Mar/08 21:35,2.1,,,,,,,,,,,,,,0,,,,"The default load method for commons.collections.ExtendedProperties currently 
loads properties using the default JVM encoding.  The default load() method 
should use ""8859_1"" encoding.

Rationale:
1) consistency: java.util.Properties.load() method always uses ""8859_1""
2) properties resources are always 8859_1, by convention.
2) On edbcic machines, particularly IBM mainframes, the default encoding is 
Cp1047 (ebcdic), but properties files are always ASCII (ISO8859-1)
3) This bug causes many Apache tools, such as Velocity, which uses 
commons.collections, to fail on non-ascii machines, since they distribute 
properties resources which are (correctly) in 8859-1.","Operating System: All
Platform: All",,,,,,,,,,,,,,,,,,13/Mar/03 01:01;amamment;ASF.LICENSE.NOT.GRANTED--ExtendedPropertiesPatch.txt;https://issues.apache.org/jira/secure/attachment/12332162/ASF.LICENSE.NOT.GRANTED--ExtendedPropertiesPatch.txt,,,,,,,,,1.0,,,,,,,,,,,,,,,,17616.0,,,2003-03-13 01:01:27.0,,,false,,,,,,,,,,,,,,18958,,,Sat Apr 19 07:48:51 UTC 2003,,,,,,0|i0sjp3:,164668,,,,,,,,"13/Mar/03 01:01;amamment;Created an attachment (id=5291)
[PATCH] Update to always attempt using ISO-8859-1
","13/Mar/03 01:03;amamment;I'm submitting a patch which should resolve this problem.  If the encoding is 
null (the case for load()), or the supplied encoding is not supported, the 
Property file is loaded with encoding ISO-8859-1.  If this encoding is not 
supported (and support is required for all java platforms), only then is the 
platform default encoding is used....","19/Mar/03 04:48;dlr;Is this fix also applicable to Commons Configuration?  Strikes me that it would
be, but I haven't verified.
","19/Apr/03 06:20;rwaldhoff@apache.org;Patch applied, thanks Arun and Kirk.

By the way, it seems to me that if one calls load(InputStream in,String
encoding) with some non-null encoding then we shouldn't be attempting other
encodings (what if some other encoding ""works"" but isn't right?), but this isn't
substantially different from the previous behavior.","19/Apr/03 07:48;dlr;Rodney, yeah, an IllegalArgumentException might be more appropriate.  Unless
perhaps the non-null encoding is an empty string, in which case falling back to
the JVM default or UTF-8 might make sense.
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
[collections] ExtendedProperties should not just allow NPEs,COLLECTIONS-39,12341617,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Minor,Fixed,,john.tal@gxs.com,john.tal@gxs.com,06/Aug/04 01:23,15/Mar/08 21:35,07/Apr/19 20:38,15/Mar/08 21:35,3.1,,,,,,,,,,,,,,0,,,,"Its really an annoyance because I frequently have my debugger stop on
NullPointerException.

ExtendedProperties.readProperty

Change from         
                    String line = readLine().trim();
to
                    String line = readLine();
                    if(line != null) line = line.trim(); else return null;

Also in ExtendedProperties.load

            while (true) {
                String line = reader.readProperty();
				if(line == null)
					return;
                int equalSign = line.indexOf('=');","Operating System: other
Platform: Other",,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,30497.0,,,2004-09-23 06:37:23.0,,,false,,,,,,,,,,,,,,18959,,,Thu Sep 23 06:37:23 UTC 2004,,,,,,0|i0sjpb:,164669,,,,,,,,23/Sep/04 06:37;scolebourne@joda.org;Changes made to avoid NPE in normal processing,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
[collections] Javadoc entry page overview has bad links for 'Transformer' and 'Factory',COLLECTIONS-38,12342281,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Trivial,Fixed,,andreas.przygienda@zkb.ch,andreas.przygienda@zkb.ch,02/Jun/05 22:04,15/Mar/08 21:35,07/Apr/19 20:38,15/Mar/08 21:35,3.1,,,,,,,,,,,,,,0,,,,"the overview in the entry page of the collections API javadoc has bad links in 
the description of the ""org.apache.commons.collections.functors"" package.
(*...* means an underlying link):

""This package contains implementations of the *Closure*, *Predicate*, 
*Transformer* and *Factory* interfaces.""

*Transformer* and *Factory* link to the Predicate Interface","Operating System: All
Platform: All",,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,35186.0,,,2005-06-07 08:05:11.0,,,false,,,,,,,,,,,,,,18960,,,Tue Jun 07 08:05:11 UTC 2005,,,,,,0|i0sjpj:,164670,,,,,,,,07/Jun/05 08:05;scolebourne@joda.org;Fixed thanks,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
[collections] The commons-collections 'binary distro' on the Jakarta Website is actually the 'source distro',COLLECTIONS-37,12341654,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Won't Fix,,d.tonhofer@m-plify.com,d.tonhofer@m-plify.com,23/Aug/04 23:22,15/Mar/08 21:35,07/Apr/19 20:38,15/Mar/08 21:35,3.1,,,,,,,,,,,,,,0,,,,The subject says it all,"Operating System: Linux
Platform: PC",,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,30806.0,,,2004-08-24 03:00:15.0,,,false,,,,,,,,,,,,,,18961,,,Wed Aug 25 01:31:26 UTC 2004,,,,,,0|i0sjpr:,164671,,,,,,,,"24/Aug/04 03:00;scolebourne@joda.org;Can you help me with the URL/link you have trouble with? I can't find anything 
wrong.","24/Aug/04 17:02;d.tonhofer@m-plify.com;That's right, I was not very specific:

If you are on 

http://jakarta.apache.org/commons/collections/

Then click on the left-hand frame's ""Download"" link, you are directed to

http://jakarta.apache.org/site/sourceindex.cgi#commons-collections

instead of

http://jakarta.apache.org/site/binindex.cgi#commons-collections

which is probably not what is intended. ","25/Aug/04 01:31;scolebourne@joda.org;It was exactly what I intended ;-)

The source distro contains the jar file and the source code, which is far more 
useful to plug in to an IDE like Eclipse than the binary distro (ie. you need 
the source code to make the best use of commons IMHO)",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"[collections] MultiHashMap.remove(key, value) always returns a value",COLLECTIONS-36,12341891,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,tad@tadland.net,tad@tadland.net,24/Nov/04 06:01,15/Mar/08 21:35,07/Apr/19 20:38,15/Mar/08 21:35,3.1,,,,,,,,,,,,,,0,,,,"According to the documentation, MultiHashMap.remove(key, value) will only return
a value when it removes a value, null if nothing was removed. Instead, it always
returns a value.","Operating System: Linux
Platform: PC",,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,32366.0,,,2005-01-04 09:13:46.0,,,false,,,,,,,,,,,,,,18962,,,Tue Jan 04 09:13:46 UTC 2005,,,,,,0|i0sjpz:,164672,,,,,,,,"04/Jan/05 09:13;scolebourne@joda.org;Fixed, thanks",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
[collections] IteratorChain.hasNext() throws when chain is empty,COLLECTIONS-35,12341083,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,phil@steitz.com,phil@steitz.com,08/Nov/03 12:22,15/Mar/08 21:35,07/Apr/19 20:38,14/Jul/06 12:05,Nightly Builds,,,,,,,,,,,,,,1,,,,"If added to TestIteratorChain, the following test case fails with the stack
trace that follows.  The exception is documented in the javadoc for
IteratorChain.hasNext(), but the behavior may be inconsistent with the Iterator
interface spec.

Test case:

public void testEmptyChainHasNext() {
        IteratorChain chain = new IteratorChain();
        assertTrue(!chain.hasNext());      
    }

Stack trace:

[java] Time: 20.733
     [java] There was 1 error:
     [java] 1)
testEmptyChainHasNext(org.apache.commons.collections.iterators.TestIteratorChain)
java.lang.UnsupportedOperationException: IteratorChains must contain at least
one Iterator
     [java] 	at
org.apache.commons.collections.iterators.IteratorChain.checkChainIntegrity(IteratorChain.java:248)
     [java] 	at
org.apache.commons.collections.iterators.IteratorChain.lockChain(IteratorChain.java:256)
     [java] 	at
org.apache.commons.collections.iterators.IteratorChain.hasNext(IteratorChain.java:295)
     [java] 	at
org.apache.commons.collections.iterators.TestIteratorChain.testEmptyChainHasNext(TestIteratorChain.java:186)
     [java] 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
     [java] 	at
sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
     [java] 	at
sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)","Operating System: other
Platform: Other",,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,24520.0,,,2003-12-30 00:08:28.0,,,false,,,,,,,,,,,,,,18963,,,Fri Jul 14 12:05:02 UTC 2006,,,,,,0|i0sjq7:,164673,,,,,,,,30/Dec/03 00:08;scolebourne@joda.org;I have enabled zero iterators in the chain.,14/Jul/06 12:05;bayard;Reopen/reclose to deal with migration bug.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Collections doesn't build with jdk1.2 javac,COLLECTIONS-34,12340154,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,jeff@socialchange.net.au,jeff@socialchange.net.au,12/May/01 05:46,15/Mar/08 21:35,07/Apr/19 20:38,15/Mar/08 21:35,Nightly Builds,,,,,,,,,,,,,,0,,,,"Hi,

Just tried building jakarta-commons/collections from CVS (12/5), and it doesn't
compile with Sun's 'javac' for linux:

$ java -version
java version ""1.2.2""
Classic VM (build JDK-1.2.2_007, green threads, nojit)

$ ant clean ; ant
....
build-java:
    [mkdir] Created dir:
/home/jeff/apache/jakarta/jakarta-commons/collections/dist/classes
    [javac] Compiling 26 source files to
/home/jeff/apache/jakarta/jakarta-commons/collections/dist/classes
    [javac]
/home/jeff/apache/jakarta/jakarta-commons/collections/src/java/org/apache/commons/collections/FastTreeMap.java:325:
Inner type Entry in class java.util.TreeMap not accessible from class
org.apache.commons.collections.FastTreeMap.
    [javac]                 Entry e = (Entry) i.next();
    [javac]                 ^
    [javac]
....
BUILD FAILED


However, it *does* work if I set build.compiler=jikes. It also works if I use
jdk1.3 'javac'. Possibly a bug in javac?

Anyway, just thought I'd bring this to people's attention, as the STATUS.html
file states it needs ""JDK1.2 or later"".

thanks,

--Jeff","Operating System: Linux
Platform: PC",,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,1729.0,,,2001-05-18 00:20:27.0,,,false,,,,,,,,,,,,,,18964,,,Fri May 18 00:20:27 UTC 2001,,,,,,0|i0sjqf:,164674,,,,,,,,"18/May/01 00:20;rwaldhoff@apache.org;I'm pretty sure this is fixed as of May 17th 2001, with version 1.3 of 
FastHashMap and FastTreeMap, but I don't have a Linux/JDK 1.2.2 environment to 
test it on. - rw",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
[collections] AbstractHashedMap: initial threshold too conservative,COLLECTIONS-33,12342254,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,christian@siefkes.net,christian@siefkes.net,23/May/05 00:28,15/Mar/08 21:35,07/Apr/19 20:38,15/Mar/08 21:35,3.1,,,,,,,,,,,,,,0,,,,"The (int initialCapacity, float loadFactor) constructor of
org.apache.commons.collections.map.AbstractHashedMap calculates the initial
resize too threshold conservatively, based on the requested initial capacity
instead of the actually chosen initial capacity (which is round up to the next
power of too). This could be fixed switching two lines to calculating the
initial threshold after rounding up the capacity instead of before:

--- AbstractHashedMap.java      2005-05-22 17:04:23.000000000 +0200
+++ AbstractHashedMap-patched.java      2005-05-22 17:08:46.000000000 +0200
@@ -147,4 +147,4 @@
         this.loadFactor = loadFactor;
-        this.threshold = calculateThreshold(initialCapacity, loadFactor);
         initialCapacity = calculateNewCapacity(initialCapacity);
+        this.threshold = calculateThreshold(initialCapacity, loadFactor);
         this.data = new HashEntry[initialCapacity];

A map with an requested capacity of 600 and a load factor of 0.75, will start
with an initial array of length 1024. Without the fix, the array will be resized
for the first time as soon as there are 450 entries, i.e. the array is less than
45% filled instead of the 75% suggested by the load factor.","Operating System: other
Platform: All",,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,35012.0,,,2005-05-23 02:49:34.0,,,false,,,,,,,,,,,,,,18965,,,Mon May 23 02:49:34 UTC 2005,,,,,,0|i0sjqn:,164675,,,,,,,,"23/May/05 02:49;scolebourne@joda.org;Patch applied, thanks",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
[collections] DualTreeBidiMap does not  sort with custom Comparator,COLLECTIONS-32,12341505,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,jonas.vanpoucke@actonomy.com,jonas.vanpoucke@actonomy.com,11/Jun/04 15:47,15/Mar/08 21:35,07/Apr/19 20:38,15/Mar/08 21:35,3.0,,,,,3.1,,,,,,,,,0,,,,"When you supply a Comparator to the constructor of DualTreeBidiMap, the custom
sorting order is NOT maintained. 

The problem lies in the order where 
    protected Map createMap()
is called: The constructors in AbstractDualBidiMap call this metod, but the
comparator is set *after* calling super() in DualTreeBidiMap:

//--- Class AbstractDualBidiMap---// 
    protected AbstractDualBidiMap() {
        super();
        maps[0] = createMap();
        maps[1] = createMap();
    }
//--- Class DualTreeBidiMap ---// 
    public DualTreeBidiMap(Comparator comparator) {
        super();
        this.comparator = comparator; // <-- Too late, createMap already called!
    }
    protected Map createMap() {
        return new TreeMap(comparator); // <-- Comparator always null
    }


Hence, DualTreeBidiMap.compatator() always returns null.","Operating System: other
Platform: Other",,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,29519.0,,,2004-06-12 06:32:09.0,,,false,,,,,,,,,,,,,,18966,,,Mon Jun 14 15:01:25 UTC 2004,,,,,,0|i0sjqv:,164676,,,,,,,,"12/Jun/04 06:32;scolebourne@joda.org;protected Map createMap() is a lousy design :-((

I have changed CVS with updated AbstractDualBidiMap, DualHashBidiMap and 
DualTreeBidiMap. If you have a chance to get these from CSV and test them I 
would be grateful.","14/Jun/04 15:01;jonas.vanpoucke@actonomy.com;Hi,
I did a quick test for DualTreeBidiMap and everything seems to work as expected.
Thanks! 

I also included some code for the JUnit test (add the following to
TestDualTreeBidiMap2):

//--- Additional JUnit method start ---//
  public void testSortOrder() throws Exception {
    SortedBidiMap sm = (SortedBidiMap) makeFullMap();

    // Sort by the comparator used in the makeEmptyBidiMap() method
    List newSortedKeys = Arrays.asList(getSampleKeys());
    Collections.sort(newSortedKeys,
                     new ReverseComparator(ComparableComparator.getInstance()));
    newSortedKeys = Collections.unmodifiableList(newSortedKeys);

    Iterator mapIter = sm.keySet().iterator();
    Iterator expectedIter = newSortedKeys.iterator();
    while (expectedIter.hasNext()) {
      Object expectedKey = expectedIter.next();
      Object mapKey = mapIter.next();
      assertNotNull(""key in sorted list may not be null"", expectedKey);
      assertNotNull(""key in map may not be null"", mapKey);
      assertEquals(""key from sorted list and map must be equal"", expectedKey,
                   mapKey);
    }
  }
//--- Additional JUnit method end---//",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
[collections][PATCH] BlockingBuffer JavaDoc improvement,COLLECTIONS-31,12340980,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,janekdb@yahoo.co.uk,janekdb@yahoo.co.uk,18/Sep/03 07:13,15/Mar/08 21:35,07/Apr/19 20:38,15/Mar/08 21:35,Nightly Builds,,,,,,,,,,,,,,0,,,,"The attached patch improvements the JavaDoc for
o.a.c.c.decorators.BlockingBuffer by describing the behaviour of get() and
remove() in a multithreaded environment.","Operating System: other
Platform: Other",,,,,,,,,,,,,,,,,,18/Sep/03 07:14;janekdb@yahoo.co.uk;ASF.LICENSE.NOT.GRANTED--BlockingBuffer-javadoc-improvement.patch;https://issues.apache.org/jira/secure/attachment/12332535/ASF.LICENSE.NOT.GRANTED--BlockingBuffer-javadoc-improvement.patch,,,,,,,,,1.0,,,,,,,,,,,,,,,,23234.0,,,2003-09-18 12:12:52.0,,,false,,,,,,,,,,,,,,18967,,,Thu Sep 18 12:12:52 UTC 2003,,,,,,0|i0sjr3:,164677,,,,,,,,"18/Sep/03 07:14;janekdb@yahoo.co.uk;Created an attachment (id=8267)
patch to improve JavaDoc for o.a.c.c.decorators.BlockingBuffer
","18/Sep/03 12:12;phil@steitz.com;Slightly edited patch applied.

Thanks.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
[collections] TransformedMap.putAll fails with empty Map,COLLECTIONS-30,12342898,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Duplicate,,polx,polx,09/Feb/06 22:45,15/Mar/08 21:35,07/Apr/19 20:38,15/Mar/08 21:35,3.1,,,,,,,,,,,,,,0,,,,"Using collections 3.1, TransformedMap.putAll creates a new LinkedMap with the
size of the parameter's collection as capacity. When this size is zero, however,
this raises exceptions.

paul","Operating System: other
Platform: Other",,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,38591.0,,,2006-02-09 23:44:42.0,,,false,,,,,,,,,,,,,,18968,,,Thu Feb 09 23:44:42 UTC 2006,,,,,,0|i0sjrb:,164678,,,,,,,,"09/Feb/06 23:44;gudnabrsam@yahoo.com;

*** This bug has been marked as a duplicate of 34686 ***",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"[collections] ""Upload to m2 repo @ibiblio.org""",COLLECTIONS-29,12343084,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Invalid,,david@davidkarlsen.com,david@davidkarlsen.com,15/May/06 21:27,18/Jul/06 22:04,07/Apr/19 20:38,18/Jul/06 22:04,3.2,,,,,,,,,,,,,,0,,,,Could somebody upload collections 3.2 to www.ibiblio.org/maven2 repo?,"Operating System: other
Platform: Other",,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,39584.0,,,2006-05-18 06:52:16.0,,,false,,,,,,,,,,,,,,18969,,,Tue Jul 18 22:04:12 UTC 2006,,,,,,0|i0sjrj:,164679,,,,,,,,"18/May/06 06:52;bayard;Tomislav Stojcevich  said (in Bugzilla):

Actually, please upload to the Apache Repository which is automatically sync'd
into the m2 repository.","18/May/06 06:56;bayard;Other related todos:

* Need to pgp and md5 the files too.
* Need to decide what our group-id will be in the m2 world:   org.apache.commons.collections I presume?
* Deploy sources and javadoc jars.","18/May/06 07:35;scolebourne;There seems to be a sync problem. Its in the ASF repo at
http://www.apache.org/dist/java-repository/commons-collections/jars/
but hasn't appeared at
http://www.ibiblio.org/maven/commons-collections/jars/","19/May/06 20:22;stojcevicht;I added a maven jira.

http://jira.codehaus.org/browse/MAVENUPLOAD-914",18/Jul/06 22:04;scolebourne;Action taken by Maven team,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
SequencedHashMap.indexOf(Object key) throws annoying exceptions,COLLECTIONS-28,12340373,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,johal@nakedrobot.com,johal@nakedrobot.com,18/Oct/02 16:10,15/Mar/08 21:35,07/Apr/19 20:38,15/Mar/08 21:35,2.0,,,,,,,,,,,,,,0,,,,"Is it intentional that SequencedHashMap.indexOf(Object key) throws a 
NullPointerException when the key does not exist in the map?

Shouldn't it return -1 in those situations?

Here is an addition to the TestSequencedHashMap which examplifies the problem

public void testIndexOf() throws Exception {
  Object[] keys = getKeys();
  int expectedSize = keys.length;
  Object[] values = getValues();
  for (int i = 0; i < expectedSize; i++) {
    labRat.put(keys[i], values[i]);
  }
  // test that the index returned are in the same order that they were 
  // placed in the map
  for (int i=0;i<keys.length;i++) {
    assertEquals(""indexOf with existing key failed"",i,labRat.indexOf(keys[i]));
  }
  // test non existing key..

  assertEquals(""test with non-existing key failed"",-1,labRat.indexOf
(""NonExistingKey""));
}","Operating System: All
Platform: All",,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,13758.0,,,2002-11-25 04:51:16.0,,,false,,,,,,,,,,,,,,18970,,,Mon Nov 25 04:51:16 UTC 2002,,,,,,0|i0sjrr:,164680,,,,,,,,"25/Nov/02 04:51;scolebourne@joda.org;Fix made to SequencedHashMap.indexOf.

Thanks for the test.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
[collections] LRUMap.clone() broken?,COLLECTIONS-27,12341285,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,fgiust,fgiust,23/Feb/04 22:21,15/Mar/08 21:35,07/Apr/19 20:38,15/Mar/08 21:35,3.0,,,,,,,,,,,,,,0,,,,"LRUMap.clone() always produces an empty Map. Shouldn't it produce a shallow 
copy with all the entries?

This test actually fails in 3.0:

    public void testLRUMapClone()
    {
        LRUMap lru = new LRUMap(10);
        lru.put(""1"", ""1"");

        Map lruClone = (Map) lru.clone();

        assertEquals(lru.size(), lruClone.size());
    }","Operating System: other
Platform: Other",,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,27159.0,,,2004-02-27 08:26:48.0,,,false,,,,,,,,,,,,,,18971,,,Fri Feb 27 08:26:48 UTC 2004,,,,,,0|i0sjrz:,164681,,,,,,,,"27/Feb/04 08:26;scolebourne@joda.org;This is a nasty bug afecting the cloning of all AbstractHashedMap subclasses.
Fixed in CVS now, with added tests. Thanks.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
CompositeSet always supports remove operation,COLLECTIONS-26,12341695,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,koji.sekiguchi@bluemartini.com,koji.sekiguchi@bluemartini.com,07/Sep/04 13:38,15/Mar/08 21:35,07/Apr/19 20:38,15/Mar/08 21:35,3.1,,,,,,,,,,,,,,0,,,,"CompositeSet javadoc says ""If no strategy is provided then add and remove are
unsupported."" but the class always supports remove operation. The documentation
should be revised as ""If no strategy is provided then add is unsupported.""

regards,

Koji","Operating System: other
Platform: Other",,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,31082.0,,,2004-09-23 06:41:51.0,,,false,,,,,,,,,,,,,,18972,,,Thu Sep 23 06:41:51 UTC 2004,,,,,,0|i0sjs7:,164682,,,,,,,,"23/Sep/04 06:41;scolebourne@joda.org;Change made, thanks",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
[collections][PATCH] OutOfMemoryError test case for MapUtils.verbosePrint.,COLLECTIONS-25,12340954,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,janekdb@yahoo.co.uk,janekdb@yahoo.co.uk,10/Sep/03 04:02,15/Mar/08 21:35,07/Apr/19 20:38,15/Mar/08 21:35,Nightly Builds,,,,,,,,,,,,,,0,,,,"The attached patch adds a test case to TestMapUtils that demonstrates infinite
recursion in MapUtils.verbosePrint.","Operating System: other
Platform: Other",,,,,,,,,,,,,,,,,,10/Sep/03 04:03;janekdb@yahoo.co.uk;ASF.LICENSE.NOT.GRANTED--TestMapUtils-verbosePrint-recursion.patch;https://issues.apache.org/jira/secure/attachment/12332514/ASF.LICENSE.NOT.GRANTED--TestMapUtils-verbosePrint-recursion.patch,10/Sep/03 23:57;amamment;ASF.LICENSE.NOT.GRANTED--patch.txt;https://issues.apache.org/jira/secure/attachment/12332515/ASF.LICENSE.NOT.GRANTED--patch.txt,,,,,,,,2.0,,,,,,,,,,,,,,,,23041.0,,,2003-09-10 05:02:49.0,,,false,,,,,,,,,,,,,,18973,,,Thu Sep 18 03:19:14 UTC 2003,,,,,,0|i0sjsf:,164683,,,,,,,,"10/Sep/03 04:03;janekdb@yahoo.co.uk;Created an attachment (id=8120)
demonstrates infinite
patch demonstrating recursion in MapUtils.verbosePrint
",10/Sep/03 05:02;scolebourne@joda.org;All we need now is the fix for the newly demonstrated bug....;-),"10/Sep/03 11:47;phil@steitz.com;Is this really a bug??

As a user, I would personally not complain about a documented limitation/warning
that this method should not be used for maps that may contain cyclic object
graphs.  I agree that infinite recursions are evil, but if you want to ask for
recursive traversals... As the javadoc states, ""When the value is a Map,
recursive behaviour occurs.""

Otherwise what are the choices?

1. limit the depth of the recursion

2. hold an array of visited nodes and check each new node against the visited
list to prevent cycles

3. put some other absolute limit on the number of nodes visited

Options 1 and 3 are ugly.  I suppose that I could live with 2., but do we really
need to do this?

I suppose we could also consider dumping the recursive contract -- i.e., just
iterate and print the map entries, eliminating the quoted line above from the
javadoc.","10/Sep/03 23:56;amamment;As the result of a previous submission of patches (COM-635) I already had 
planned some work to prevent this kind of recursion.  I attach a patch which 
actually does multiple things....

1) Modifies test cases to make duplicate any tests available for debugPrint 
apply to verbosePrint and vice-versa (there were a few tests present for one 
and not the other, and it seemed easy to do).  

2) Updates verbosePrintInternal to also pass an internal stack of previously 
visited maps.  If a previously visited map is seen again, the text ""(ancestor
[i] Map) is printed out as the value of the Map, where i refers to level of 
ancestor - the parent of the current Map is 0, the parent's parent 1, and so 
on.... 

3) Modified the test in the previously attached patch (<a 
href=""showattachment.cgi?attach_id=8120"">attachment=8120</a>); effectively 
replacing it with an alternate version that tests for the behaviour mentioned 
in #2 above.  If the test is executed on unmodified code, an OutOfMemory error 
should be generated as previously.  Also added an equivalent test for 
verbosePrint.  

Area of Concern 1 - the mechanism used for preventing infinitely recursive 
printing makes sense to me.  However, the exact notation for the text to print 
out when an ancestor map is included within the current map was something that 
I made up.  Anyone have better suggestions?  I just tried to go with something 
like the ""(this Map)"" text used for identifying the current map when one is 
included within itself.

Area of Concern 2 - The code recursively passes a stack of previously 
navigated maps along with the recursive call to print child maps.  Each 
element of the child's values is checked for existence in the stack in order 
to determine if the notation listed above should be used.  However, the check 
is done with Stack.contains().  Is this guaranteed to work?  I 
assume .contains calls .equals on members of the stack to determine if any 
specific element is already present.  I'm not sure what the guarantees are 
when you call .equals on a self-referencing Map.  It worked for the testcase 
with a TreeMap on the IBM JDK 1.3, but will it work in general?    ","10/Sep/03 23:57;amamment;Created an attachment (id=8130)
[Patch] Updates to verbosePrintInternal to handle recursion - deprecates previous patch
","18/Sep/03 03:19;scolebourne@joda.org;Patch applied, however Stack uses .equals() as you mentioned, and we should be 
using == really. But its an unusual case, so I'm not that bothered.

Thanks",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
[collections] [patch] TransformingPredicate,COLLECTIONS-24,12341274,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,alban,alban,15/Feb/04 05:47,15/Mar/08 21:35,07/Apr/19 20:38,15/Mar/08 21:35,3.0,,,,,,,,,,,,,,0,,,,"A Predicate which transforms the given object before evaluating the result with
another Predicate :

    public boolean evaluate(Object object) {
        Object result = transformer.transform(object);
        return predicate.evaluate(result);
    }","Operating System: other
Platform: Other",,,,,,,,,,,,,,,,,,15/Feb/04 05:48;alban;ASF.LICENSE.NOT.GRANTED--collections-TransformingPredicate.patch;https://issues.apache.org/jira/secure/attachment/12332743/ASF.LICENSE.NOT.GRANTED--collections-TransformingPredicate.patch,,,,,,,,,1.0,,,,,,,,,,,,,,,,26946.0,,,2004-03-14 00:36:22.0,,,false,,,,,,,,,,,,,,18974,,,Sun Mar 14 00:36:22 UTC 2004,,,,,,0|i0sjsn:,164684,,,,,,,,"15/Feb/04 05:48;alban;Created an attachment (id=10361)
Adds TransformingPredicate
","14/Mar/04 00:36;scolebourne@joda.org;Class added, although unit tests would have been preferred. Thanks.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
BeanMap.putAll(beanmap) fails,COLLECTIONS-23,12340278,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Minor,Fixed,,acroyear@io.com,acroyear@io.com,30/Jul/02 03:08,15/Mar/08 21:35,07/Apr/19 20:38,15/Mar/08 21:35,2.0,,,,,,,,,,,,,,0,,,,"I created two beanmaps, both around objects of the same class, to try to
effectively clone the underlying objects (this was before I looked harder and
realized that BeanMap.clone() would try to instantiate a new object on its own).

I found that this fails with a java.lang.IllegalArgumentException: The bean of
type: com.isx.isaf.IsafAgentDescription has no property called: class

The reason: BeanMap's underlying introspector notices the read-only property of
""class"" (the class of the bean object), and has a get() entry for it that has
no matching put.

When AbstractMap.putAll iterates through the values, it tries to put() the class
value and this causes the failure.

The workarounds is to reimplement putAll() outside the map and catch exceptions 
for every failed put (this should be the only one unless the bean itself has 
other read-only properties).  

BeanMap.clone() correctly checks for read-only properties and doesn't try to 
set them, but is limited to beans that have zero-parameter constructors; its 
real problem is that it is still ""protected"" in BeanMap, not public.  

Possible fix is to override putAll() from AbstractMap and check if the
property is read-only before calling put() and ignoring it if it is.  Options
involving fixing put() itself would cause more problems than solutions, IMHO.

Another fix is to catch the ""class"" property and filter it out completely so
it never shows up in the keySet or entrySet at all.","Operating System: other
Platform: Other",,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,11262.0,,,2002-08-10 09:06:51.0,,,false,,,,,,,,,,,,,,18975,,,Sat Aug 10 09:06:51 UTC 2002,,,,,,0|i0sjsv:,164685,,,,,,,,"10/Aug/02 09:06;pjack@sfaf.org;Added a putAllWriteable(BeanMap) method that will let you only copy the
writeable properties.  Didn't want to override putAll(Map) because it would
break backwards compatibility, and in most cases it really is an exception to
try to put a read-only property.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
[collections] In BeanMap all properties are writable (some with null mutator),COLLECTIONS-22,12340476,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,dimiter@blue-edge.bg,dimiter@blue-edge.bg,09/Jan/03 01:24,15/Mar/08 21:35,07/Apr/19 20:38,15/Mar/08 21:35,2.1,,,,,,,,,,,,,,0,,,,"In BeanMap.initialize() method there is a bug that causes all properties to have write methods 
(even if they are null).","Operating System: All
Platform: All",,,,,,,,,,,,,,,,,,09/Jan/03 01:47;dimiter@blue-edge.bg;ASF.LICENSE.NOT.GRANTED--patch1.diff;https://issues.apache.org/jira/secure/attachment/12332096/ASF.LICENSE.NOT.GRANTED--patch1.diff,,,,,,,,,1.0,,,,,,,,,,,,,,,,15895.0,,,2005-03-23 08:30:02.0,,,false,,,,,,,,,,,,,,18976,,,Wed Mar 23 08:30:02 UTC 2005,,,,,,0|i0sjt3:,164686,,,,,,,,"09/Jan/03 01:47;dimiter@blue-edge.bg;Created an attachment (id=4374)
the fix
","09/Jan/03 02:06;dimiter@blue-edge.bg;I know that the member is private, but still I think it matters...","23/Mar/05 08:30;scolebourne@joda.org;Patch applied (to collections and beanutils),thanks",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
TestMap.tearDown() should throw Exception,COLLECTIONS-21,12340393,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Minor,Fixed,,rich@rd.gen.nz,rich@rd.gen.nz,01/Nov/02 07:20,15/Mar/08 21:35,07/Apr/19 20:38,15/Mar/08 21:35,2.1,,,,,,,,,,,,,,0,,,,"TestMap.tearDown() overrides TestCase.tearDown(). The original method throws an
Exception, however the redeclared method doesn't. This means that methods which
override TestMap.tearDown() cannot throw an Exception. In my case, I'm creating
and removing a test database in the setUp() and tearDown() so an Exception could
easily be thrown.

I realise that TestMap isn't part of Collections' public API, however I thought
I'd mention this in case other people want to reuse your excellent testing code.","Operating System: other
Platform: All",,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,14151.0,,,2002-11-02 03:09:15.0,,,false,,,,,,,,,,,,,,18977,,,Sat Nov 02 03:09:15 UTC 2002,,,,,,0|i0sjtb:,164687,,,,,,,,"02/Nov/02 03:09;rwaldhof@us.britannica.com;fixed
also made similar changes in a few more test files",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
[collections] TestObservedBag and TestObservedSet fail under Java 1.3.1,COLLECTIONS-20,12340972,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,janekdb@yahoo.co.uk,janekdb@yahoo.co.uk,17/Sep/03 03:05,15/Mar/08 21:35,07/Apr/19 20:38,15/Mar/08 21:35,Nightly Builds,,,,,,,,,,,,,,0,,,,"With CVS HEAD of 2003-Sept-16 two unit tests fail under Java 1.3.1_04.

  $ java -version
  java version ""1.3.1_04""
  Java(TM) 2 Runtime Environment, Standard Edition (build 1.3.1_04-b02)
  Java HotSpot(TM) Client VM (build 1.3.1_04-b02, mixed mode)

The stack trace is:

    [java] There were 2 failures:
     [java] 1) testObservedSet(o.a.c.collections.observed.TestObservedBag)
junit.framework.AssertionFailedError: expected same:<7> was not:<6>
     [java]     at
o.a.c.collections.observed.ObservedTestHelper.doTestRemoveIterated(ObservedTestHelper.java:933)
     [java]     at
o.a.c.collections.observed.ObservedTestHelper.bulkTestObservedCollection(ObservedTestHelper.java:156)
     [java]     at
o.a.c.collections.observed.ObservedTestHelper.bulkTestObservedBag(ObservedTestHelper.java:188)
     [java]     at
o.a.c.collections.observed.TestObservedBag.testObservedSet(TestObservedBag.java:98)
     [java] 2) testObservedSet(o.a.c.collections.observed.TestObservedSet)
junit.framework.AssertionFailedError: expected same:<7> was not:<6>
     [java]     at
o.a.c.collections.observed.ObservedTestHelper.doTestRemoveIterated(ObservedTestHelper.java:933)
     [java]     at
o.a.c.collections.observed.ObservedTestHelper.bulkTestObservedCollection(ObservedTestHelper.java:156)
     [java]     at
o.a.c.collections.observed.ObservedTestHelper.bulkTestObservedSet(ObservedTestHelper.java:164)
     [java]     at
o.a.c.collections.observed.TestObservedSet.testObservedSet(TestObservedSet.java:106)

     [java] FAILURES!!!
     [java] Tests run: 7489,  Failures: 2,  Errors: 0


It doesn't matter whether it is compiled with 1.4.1 or 1.3.1 as summarized here:

                          Run with:

                          1.3.1_04        1.4.1_03

Compiled with:  1.3.1_04    fail            pass 

                1.4.1_03    fail            pass","Operating System: other
Platform: Other",,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,23201.0,,,2003-09-20 19:17:19.0,,,false,,,,,,,,,,,,,,18978,,,Sat Sep 20 19:17:19 UTC 2003,,,,,,0|i0sjtj:,164688,,,,,,,,"20/Sep/03 03:37;janekdb@yahoo.co.uk;I looked into this a (tiny) bit and discovered that the fault is related to an
assumption made in ObservedTestHelper.doTestRemoveIterated(ObservedFactory
factory) about the order of elements returned by the iterator:

        coll.addAll(SIX_SEVEN_LIST);
        LISTENER.preEvent = null;
        LISTENER.postEvent = null;
        Assert.assertEquals(2, coll.size());
        Iterator it = coll.iterator();
        it.next();
        it.next();
        it.remove();
        Assert.assertEquals(1, coll.size());

Here the last element of the collection is removed however the order the
elements returned by the iterator is different between JDK 1.3.1 and JDK 1.4.1.

The order by type is show here:

                       1.3.1    1.4.1     

  ObservedBag          7, 6     6, 7
  ObservedBuffer       6, 7     6, 7
  ObservedCollection   6, 7     6, 7
  ObservedList         6, 7     6, 7
  ObservedSet          7, 6     6, 7
","20/Sep/03 19:17;scolebourne@joda.org;Fixed, good catch, thanks",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
[collections] 'acknowledgement' typos in licence headers,COLLECTIONS-19,12340940,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Minor,Fixed,,janekdb@yahoo.co.uk,janekdb@yahoo.co.uk,31/Aug/03 08:58,15/Mar/08 21:35,07/Apr/19 20:38,15/Mar/08 21:35,Nightly Builds,,,,,,,,,,,,,,0,,,,"The Apache Software License includes these typos in various files

   'acknowlegement'                  in  54 files
   'acknowledgment/acknowledgements' in 519 files","Operating System: other
Platform: Other",,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,22845.0,,,2003-09-01 00:34:25.0,,,false,,,,,,,,,,,,,,18979,,,Mon Sep 01 00:34:25 UTC 2003,,,,,,0|i0sjtr:,164689,,,,,,,,01/Sep/03 00:34;scolebourne@joda.org;Changes made,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
[collections] ListOrderedSet broken or documentation wrong.,COLLECTIONS-18,12341853,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Minor,Fixed,,rlenard,rlenard,05/Nov/04 08:45,15/Mar/08 21:35,07/Apr/19 20:38,15/Mar/08 21:35,3.1,,,,,,,,,,,,,,0,,,,"The method ListOrderedSet.decorate(List list) ""decorates"" the list, implying 
that it leaves the underlying list un-modified.  But this is just not true - it 
requires a modifiable List so it can remove duplicates.  It should at least 
warn about this - so you don't have to look in the code to see how it works and 
see why it fails when using an unmodifiable list (such as given by 
java.util.Collections.unmodifiableList()).

Actually it'd be good to have a variant that worked with unmodifiable lists.","Operating System: other
Platform: All",,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,32073.0,,,2005-01-04 09:02:21.0,,,false,,,,,,,,,,,,,,18980,,,Tue Jan 04 09:02:21 UTC 2005,,,,,,0|i0sjtz:,164690,,,,,,,,"04/Jan/05 09:02;scolebourne@joda.org;The class is behaving as intended,, although I can see why you might have been
confused. I have added extra javadoc.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
[collections] Enhance BlockingBuffer to allow for a timeout value,COLLECTIONS-17,12342733,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,jwcarman,jwcarman,23/Nov/05 22:00,15/Mar/08 21:35,07/Apr/19 20:38,15/Mar/08 21:35,3.2,,,,,,,,,,,,,,0,,,,"BlockingBuffer currently waits forever.  Add the capability to specify a timeout
value to BlockingBuffer.","Operating System: other
Platform: Other",,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,37607.0,,,,,,false,,,,,,,,,,,,,,18981,,,2005-11-23 22:00:56.0,,,,,,0|i0sju7:,164691,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
ExtendedProperties never sets isInitialized,COLLECTIONS-16,12340496,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,walta@concur.com,walta@concur.com,18/Jan/03 06:16,15/Mar/08 21:35,07/Apr/19 20:38,14/Jul/06 12:05,Nightly Builds,,,,,,,,,,,,,,1,,,,"ExtendedProperties.isInitialized() is always false.  The only code that sets it
is in a private init() function that is never called.  Some other apps (Torque)
have depended on isInitialized being set to true after a load but apparently the
Torque devs never realized it wasn't.

I'll attach a patch to correct this.  The patch removes the private, never used,
init() function and sets isInitialized on either a load() or addProperty().","Operating System: All
Platform: All",,,,,,,,,,,,,,,,,,18/Jan/03 06:17;walta@concur.com;ASF.LICENSE.NOT.GRANTED--coll-2.1-extprop-init.patch;https://issues.apache.org/jira/secure/attachment/12332103/ASF.LICENSE.NOT.GRANTED--coll-2.1-extprop-init.patch,,,,,,,,,1.0,,,,,,,,,,,,,,,,16225.0,,,2003-01-25 20:23:16.0,,,false,,,,,,,,,,,,,,18982,,,Fri Jul 14 12:05:16 UTC 2006,,,,,,0|i0sjuf:,164692,,,,,,,,"18/Jan/03 06:17;walta@concur.com;Created an attachment (id=4480)
Patch to set isInitialized flag after a load
","25/Jan/03 20:23;scolebourne@joda.org;Patch applied, thanks
Stephen",14/Jul/06 12:05;bayard;Reopen/reclose to deal with migration bug.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
[collection] ListOrderedSet doesn't implements SortedSet,COLLECTIONS-15,12341483,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Won't Fix,,mguillemot@yahoo.fr,mguillemot@yahoo.fr,03/Jun/04 17:43,15/Mar/08 21:35,07/Apr/19 20:38,15/Mar/08 21:35,,,,,,,,,,,,,,,0,,,,Is it a good reason why ListOrderedSet implements Set but not SortedSet?,"Operating System: other
Platform: Other",,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,29356.0,,,2004-06-04 04:28:35.0,,,false,,,,,,,,,,,,,,18983,,,Sat Jun 05 05:29:16 UTC 2004,,,,,,0|i0sjun:,164693,,,,,,,,"04/Jun/04 04:28;scolebourne@joda.org;Yes. Because a SortedSet must be sorted (A-Z or Z-A or 1-100 or some other 
sorting order). The iterator returns this sorted order no matter what order the 
elements are added in.

ListOrderedSet simply maintains the order in which the elements are added to 
the set. The iterator always returns the order of adding the elements.","04/Jun/04 14:36;mguillemot@yahoo.fr;I don't fully agree.
From the javadoc for a SortedSet:
""sorted according to the natural ordering of its elements (see Comparable), or
by a Comparator provided at sorted set creation time.""

A ""UnmodifiableListOrderedSet"" would obey this rule as the ""comparator"" would be
provided at creation time through the list. It is discutable as soon as more
than 1 element can be added to the set as the ""comparator"" would not only need
the information provided at creation time but should know about the previous
additions.","05/Jun/04 05:29;scolebourne@joda.org;ListOrderedSet does not currently hold a Comparator as an instance variable, 
nor should it. This class aims to solve the problem of keeping the Set in the 
same order as elements are added.

Looking at the SortedSet interface, the comparator() method is irrelevant, first
() and last() could be supported. The set views head/tail/sub all rely on a 
comparator based ordering.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
[collections] Missing putAll(Map map) in MultiHashMap since 3.1,COLLECTIONS-14,12342356,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,sven.macke@rewe.de,sven.macke@rewe.de,06/Jul/05 23:44,15/Mar/08 21:35,07/Apr/19 20:38,15/Mar/08 21:35,3.1,,,,,,,,,,,,,,0,,,,"I just upgraded to version 3.1 and noticed some errors in my application. The 
cause is the method putAll(Map map) I used to call on a MultiHashMap to copy to 
content of one to another. That method is not defined in MultiHashMap any more, 
so HashMap.putAll(Map map) is used. The result of that is a MultiHashMap that 
contains ONE value per key and the value itself is a Collection.

Here is some test code I would expect to work, but it fails:

public class MultiHashMapTest extends TestCase
{
    public void testIt()
    {
        MultiMap original = new MultiHashMap();
        original.put(""key"", ""object1"");
        original.put(""key"", ""object2"");

        MultiMap copy = new MultiHashMap();
        copy.putAll(original);

        assertEquals(original.values().size(), copy.values().size());
        assertTrue(copy.containsValue(""object1""));
        assertTrue(copy.containsValue(""object2""));
    }
}","Operating System: Windows 2000
Platform: PC",,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,35631.0,,,2005-07-08 09:04:48.0,,,false,,,,,,,,,,,,,,18984,,,Sun Jul 17 03:10:23 UTC 2005,,,,,,0|i0sjuv:,164694,,,,,,,,"08/Jul/05 09:04;scolebourne@joda.org;This method was removed in November 2002 as it didn't do anything:
    public void putAll(Map mapToPut) {
        super.putAll(mapToPut);
    }
so, the removal of the method is not the problem.

The problem is that this test case will never have worked.","08/Jul/05 16:50;sven.macke@rewe.de;The test code worked for 2.1 so I had a closer look at the sources. 

You are right, the problem ist NOT the missing method HashMap.putAll(Map map) 
but differences in the implementation of HashMap.put(Object key, Object value). 
In 2.1 there is a check whether ""value"" is an ArrayList (-> call super.put(key, 
value)) or not (-> add value to the interal ArrayList for that key).","17/Jul/05 03:10;scolebourne@joda.org;The put(Object,Object) where value=ArrayList functionality was removed a very
long time ago, what is now svn rv130874 (24th November 2002).

The implementation that was there at that time was broken (it didn't merge
entries, it wiped them), and it was against the Map contract in various ways.

This is also not specified by the MultiMap interface.

However, what I committed to SVN rv209683 will fix the original bug report,
whereby you couldn't clone a multmap using putAll.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
[collections] Typo in user documentation,COLLECTIONS-13,12342003,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Trivial,Fixed,,mchenryc@gmail.com,mchenryc@gmail.com,17/Jan/05 07:34,15/Mar/08 21:35,07/Apr/19 20:38,15/Mar/08 21:35,,,,,,,,,,,,,,,0,,,,Will attach patch momentarily.,"Operating System: All
Platform: All",,,,,,,,,,,,,,,,,,17/Jan/05 07:35;mchenryc@gmail.com;ASF.LICENSE.NOT.GRANTED--commons.xdocs.userguide.bufferTypo.patch;https://issues.apache.org/jira/secure/attachment/12333349/ASF.LICENSE.NOT.GRANTED--commons.xdocs.userguide.bufferTypo.patch,,,,,,,,,1.0,,,,,,,,,,,,,,,,33125.0,,,2005-02-04 09:22:43.0,,,false,,,,,,,,,,,,,,18985,,,Fri Feb 04 09:22:43 UTC 2005,,,,,,0|i0sjv3:,164695,,,,,,,,"17/Jan/05 07:35;mchenryc@gmail.com;Created an attachment (id=14027)
fixes typo
",04/Feb/05 09:22;scolebourne@joda.org;Thanks for the spot ;-),,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
ListOrderedSet add results in separate objects in set/list if equal,COLLECTIONS-12,12342673,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Cannot Reproduce,scolebourne,genekhart@hotmail.com,genekhart@hotmail.com,03/Nov/05 07:59,19/Jul/06 22:01,07/Apr/19 20:38,19/Jul/06 22:01,3.1,,,,,,,,Set,,,,,,0,,,,"If you add an object to ListOrderedSet, and then try to replace the object with
add and the objects are different but equals() is true, you will have two
different objects in the internal list and set so after you do an add, doing a
listorderedset.get(i) will return the old object.","Operating System: other
Platform: Other",,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,37338.0,,,2005-11-04 08:05:20.0,,,false,,,,,,,,,,,,,,18986,,,Wed Jul 19 22:01:33 UTC 2006,,,,,,0|i0sjvb:,164696,,,,,,,,"04/Nov/05 08:05;scolebourne@joda.org;What implementations of Map and List are you using? This all works fine with a
HashMap and ArrayList.

Note that the functionality is to NOT replace the object in either the list or
map (as per the specification of Set).",19/Jul/06 22:01;scolebourne;With no test case or additional information I am closing this call,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
[Collections] LazyList throws IndexOutOfBoundsException when trying to set a value out of list bounds,COLLECTIONS-11,12342709,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Cannot Reproduce,,hestonfernandes@yahoo.com,hestonfernandes@yahoo.com,11/Nov/05 01:05,15/Mar/08 21:35,07/Apr/19 20:38,15/Mar/08 21:35,3.1,,,,,,,,,,,,,,0,,,,"This was discovered when using struts 1.2.7 with dynamic forms (Tomcat 5.0.24,
jdk 1.4.2). The reset() method in the ActionForm used LazyList.decorate(). 

        if(rooms==null) {
            rooms = new ArrayList();
            roomPrefs.add(""-"");
            roomPrefs = LazyList.decorate(roomPrefs, factory);
        }


However after reset() I get the error below when it tries to initialize the
ArrayList. 

IndexOutOfBoundsException -> Index: 1, Size: 1
java.lang.IndexOutOfBoundsException: Index: 1, Size: 1
	at java.util.ArrayList.RangeCheck(ArrayList.java:507)
	at java.util.ArrayList.set(ArrayList.java:340)
	at
org.apache.commons.collections.list.AbstractListDecorator.set(AbstractListDecorator.java:97)
	at
org.apache.commons.beanutils.PropertyUtilsBean.setIndexedProperty(PropertyUtilsBean.java:1417)
	at org.apache.commons.beanutils.BeanUtilsBean.setProperty(BeanUtilsBean.java:1016)
	at org.apache.commons.beanutils.BeanUtilsBean.populate(BeanUtilsBean.java:811)
	at org.apache.commons.beanutils.BeanUtils.populate(BeanUtils.java:298)
	at org.apache.struts.util.RequestUtils.populate(RequestUtils.java:493)
	at
org.apache.struts.action.RequestProcessor.processPopulate(RequestProcessor.java:805)
	at ....


Possible Solution: For now I've created a class similar to LazyList and have
overridden the set(object, element) method and it has worked. 

    public Object set(int index, Object element) {
        int size = list.size();

        // Grow the list
        if (index >= size) {
            for (int i = size; i <= index; i++) {
                list.add(null);
            }
        }
        return list.set(index, element);
    }

I'm not sure if I'm using LazyList the right way but thought I'd bring it to
your attention.

Thanks!","Operating System: Windows XP
Platform: PC",,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,37450.0,,,2005-11-11 09:12:20.0,,,false,,,,,,,,,,,,,,18987,,,Fri Nov 11 09:12:20 UTC 2005,,,,,,0|i0sjvj:,164697,,,,,,,,"11/Nov/05 01:10;hestonfernandes@yahoo.com;The correct code that failed was

       if(roomPrefs==null) {
            roomPrefs = new ArrayList();
            roomPrefs.add(""-"");
            roomPrefs = LazyList.decorate(roomPrefs, factory);
        }","11/Nov/05 09:12;scolebourne@joda.org;LazyList is performing as expected. It only expands the list when get(index) is
called.

The class that you want is GrowthList, which expands the list on add() and
set(). (You can decorate with both GrowthList and LazyList together!)

However, GrowthList is unreleased at present, so you will need a nightly build,
or to checkout SVN and build your own jar.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
[collections] minor javadoc fixes for OrderedIterator,COLLECTIONS-10,12341581,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Minor,Fixed,,heuermh@acm.org,heuermh@acm.org,20/Jul/04 03:40,15/Mar/08 21:35,07/Apr/19 20:38,15/Mar/08 21:35,,,,,,,,,,,,,,,0,,,,"Minor javadoc fixes for org.apache.commons.collections.OrderedIterator.
diff -u attached.","Operating System: other
Platform: Other",,,,,,,,,,,,,,,,,,20/Jul/04 03:41;heuermh@acm.org;ASF.LICENSE.NOT.GRANTED--diff.txt;https://issues.apache.org/jira/secure/attachment/12332994/ASF.LICENSE.NOT.GRANTED--diff.txt,,,,,,,,,1.0,,,,,,,,,,,,,,,,30191.0,,,2004-09-23 06:19:00.0,,,false,,,,,,,,,,,,,,18988,,,Thu Sep 23 06:19:00 UTC 2004,,,,,,0|i0sjvr:,164698,,,,,,,,"20/Jul/04 03:41;heuermh@acm.org;Created an attachment (id=12166)
diff -u patch file
","23/Sep/04 06:19;scolebourne@joda.org;Applied, thanks",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
[collections] ~20 Javadoc fixes and type cast  clean ups.,COLLECTIONS-9,12341188,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,garydgregory,,07/Jan/04 07:27,10/Mar/11 23:16,07/Apr/19 20:38,15/Mar/08 21:35,Nightly Builds,,,,,,,,,,,,,,0,,,,Please see patch file attached.,"Operating System: All
Platform: All",,,,,,,,,,,,,,,,,,07/Jan/04 07:28;ASF.LICENSE.NOT.GRANTED--gg-collection-pre-3.0-patch.txt;https://issues.apache.org/jira/secure/attachment/12332680/ASF.LICENSE.NOT.GRANTED--gg-collection-pre-3.0-patch.txt,,,,,,,,,1.0,,,,,,,,,,,,,,,,25936.0,,,2004-01-07 07:28:05.0,,,false,,,,,,,,,,,,,,18989,,,Fri Jan 09 06:26:26 UTC 2004,,,,,,0|i0sjvz:,164699,,,,,,,,"07/Jan/04 07:28;ggregory@seagullsw.com;Created an attachment (id=9834)
Patch file for ""what's left for 3.0"".
","07/Jan/04 08:33;amamment;Reviewed - will commit tomorrow (when access available) - unless another 
committer does so first.  

Thanks for the good work!","09/Jan/04 06:26;scolebourne@joda.org;Patch applied, thanks",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
[collections] BlockingBuffer waits/notifies wrong Object?,COLLECTIONS-7,12342621,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,sebb@apache.org,sebb@apache.org,12/Oct/05 04:22,15/Mar/08 21:35,07/Apr/19 20:38,15/Mar/08 21:35,,,,,,,,,,,,,,,0,,,,"The code contains various examples of the form:

synchronized (lock) {
            ...
            notifyAll();
        }

which should probably be:

synchronized (lock) {
            ...
            lock.notifyAll();
        }

Patch to follow","Operating System: other
Platform: Other",,,,,,,,,,,,,,,,,,12/Oct/05 04:23;sebb@apache.org;ASF.LICENSE.NOT.GRANTED--patch.txt;https://issues.apache.org/jira/secure/attachment/12333846/ASF.LICENSE.NOT.GRANTED--patch.txt,,,,,,,,,1.0,,,,,,,,,,,,,,,,37028.0,,,2005-10-12 06:11:16.0,,,false,,,,,,,,,,,,,,18991,,,Sat Oct 15 08:26:34 UTC 2005,,,,,,0|i0sjwf:,164701,,,,,,,,"12/Oct/05 04:23;sebb@apache.org;Created an attachment (id=16663)
Patch to fix wait/notify to use lock Object
","12/Oct/05 06:11;scolebourne@joda.org;This seemed terrible when I first read it, however it turns out that the fix
(while needed) is in effect a NOP.

For all cases, the lock object and this are the same object, ie. this. Hence,
the current code (and decent test case) passes.

Amyway, thanks for the spot. The truly correct code is now committed for code
reading clarity.","12/Oct/05 23:28;sebb@apache.org;[I guess I should have spotted that ...]

The code is now safer - someone might decide to change lock to be a different 
Object at some point.

BTW, I'd rather not have been added as an @author - besides, I thought the ASF 
are not keen on @author tags?","15/Oct/05 08:26;scolebourne@joda.org;@author removed as per your request :-)

(collections policy, if there is any really, is to add @author, but to remove it
on request)",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
[Collections] - MapUtils]Method to generate a Map from a Object[][],COLLECTIONS-6,12341663,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,r.u.c.afonso@uol.com.br,r.u.c.afonso@uol.com.br,27/Aug/04 08:02,15/Mar/08 21:35,07/Apr/19 20:38,15/Mar/08 21:35,2.1,,,,,,,,,,,,,,0,,,,"In Python Language it is possible create a dictionary (equivalent to Map) using 
only a single line:

myMap = {'alpha':'a', 'betha':'b', 'gamma':'c'}

In Java it is not possible. We must do it ""manually"":

Map myMap = new HashMap();
myMap.put(""alpha"", ""a"");
myMap.put(""betha"", ""b"");
myMap.put(""gamma"", ""c"");

My propose is create a way to do this with less burocracy. In 
org.apache.commons.collections.MapUtils class could have a method called 
fillMap (or better name) that receives a Map and a bi-dimentional array of 
Objects. It will work like this:

public static Map fillMap(Map map, Object[][] keyValue) {
	for(int i = 0; i < keyValue.length; i ++) {
		map.put(keyValue[i][0], keyValue[i][1]);
	}
	return map;
}

So, returning to prior example, we could do this:

Map myMap = MapUtils.fillMap(new HashMap(), {{""alpha"", ""a""}, {""betha"", ""b""}, 
{""gama"", ""c""}});

Or to put in mass in a pre-existent MAP:

MapUtils.fillMap(myMap, {{""delta"", ""d""}, {""epslon"", ""e""}, {""omega"", ""z""}});","Operating System: other
Platform: Other",,,,,,,,,,,,,,,,,,27/Aug/04 08:04;r.u.c.afonso@uol.com.br;ASF.LICENSE.NOT.GRANTED--FillMap.java;https://issues.apache.org/jira/secure/attachment/12333074/ASF.LICENSE.NOT.GRANTED--FillMap.java,,,,,,,,,1.0,,,,,,,,,,,,,,,,30882.0,,,2004-09-23 06:06:36.0,,,false,,,,,,,,,,,,,,18992,,,Thu Sep 23 06:06:36 UTC 2004,,,,,,0|i0sjwn:,164702,,,,,,,,"27/Aug/04 08:04;r.u.c.afonso@uol.com.br;Created an attachment (id=12541)
Class with proposed method fillMap(Map, Object[][])
","23/Sep/04 06:06;scolebourne@joda.org;Added putAll(Map, Object[]).

Note that an alternative released method exists in commons-lang ArrayUtils.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
[collections] Map.debug/verbosePrint Thread Safety,COLLECTIONS-5,12340959,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,amamment,amamment,11/Sep/03 10:26,15/Mar/08 21:35,07/Apr/19 20:38,15/Mar/08 21:35,,,,,,,,,,,,,,,0,,,,"This bug records a discussion on the mailing list, and provides a forum for 
continuing that discussion.  I include below the content of the mailing on the 
list because they raise some interesting points.  

-----------------------------------------------------
From: ""Arun Thomas"" <Arun.Thomas@solidusnetworks.com>
-----------------------------------------------------

I recently noticed that the current implementation of the debugPrint and 
verbosePrint methods in MapUtils is not thread safe - in fact, these are the 
only items that are not thread safe because the indentation state for the 
output is preserved in a static variable. 

I think it would be fairly simple to make this thread safe, but it would 
require a change to the signature of a protected member function printIndent
(PrintStream out) -> printIndent(PrintStream out, int indentDepth).  I'm not 
really clear as to why this method is protected rather than private (can 
anyone clarify?).  Does it need to be protected? 

Looking forward to input from others.
-AMT 

------------------------------------------------------
From: Stephen Colebourne [scolebourne@btopenworld.com]
------------------------------------------------------

The methods that call this one are synchronized to protect them, so it
should be thread-safe.

However, I would prefer them not to need to be synchronized. If you want to
submit a patch that reworks the methods that would be great.

Incompatable change?
The protected method should remain and be deprecated, as it may be used by a
MapUtils subclass (feasible but unlikely). However, I would prefer just to
go incompatable change on this one. Other committers may differ, but if they
don't I'll just commit the incompatable change.

Stephen

---------------------------------------
From: Janek Bogucki [yan@studylink.com]
---------------------------------------

These methods are synchronized so are currently thread safe.

    public static synchronized void verbosePrint (...)

    public static synchronized void debugPrint (...)

I would guess that a second intentional benefit of the synchronization
is to prevent overlapping invocations writing to System.out at the same
time.

-Janek

------------------------------------------------------
From: Stephen Colebourne [scolebourne@btopenworld.com]
------------------------------------------------------

I like the System.out theory. Its probably unintentional, but it true. So
only a documentation patch is required then...:-)
Stephen","Operating System: other
Platform: Other",,,,,,,,,,,,,,,,,,11/Sep/03 10:37;amamment;ASF.LICENSE.NOT.GRANTED--patch.txt;https://issues.apache.org/jira/secure/attachment/12332517/ASF.LICENSE.NOT.GRANTED--patch.txt,,,,,,,,,1.0,,,,,,,,,,,,,,,,23092.0,,,2003-09-11 14:50:54.0,,,false,,,,,,,,,,,,,,18993,,,Sat Sep 20 18:33:13 UTC 2003,,,,,,0|i0sjwv:,164703,,,,,,,,"11/Sep/03 10:36;amamment;First of all, after Stephen's original comment, I created a patch and came 
back online in order to create this bug and attach the patch.  I will do so 
anyway, though whether or not this is the appropriate patch has yet to be 
determined.  The patch makes use of the fact that debugPrint and verbosePrint 
both delegate to verbosePrintInternal to pass on an extra variable 
(indentDepth) removing the need for that state to be represented as part of 
the class state.

The old printIndent method has been deprecated, though, as you will see from 
the comments I include in the patch, it doesn't make much sense to do so.

That said, I'd like to address here Janek's comment about preventing 
overlapping invokations from writing to System.out at the same time.  I can 
see why that would be useful, but I think forcing the synchronization on the 
class (particularly a utility class like this) is the worst way to do it.  
This will prevent, as Janek notes, overlapping invokations to debugPrint and 
verbosePrint from interfering with each other.  However....

1) There is no lock on System.out.  In a multi-threaded environment, other 
sources of output outside this class may well be writing to System.out at the 
same time.  Such output may be interlaced with output from these two 
synchronized methods - there is no guard against such behavior.  As a result, 
preventing interlacing of output will most likely require an external guard 
anyway.  

2) The cost of synchronizing these two methods is that none of the otherwise 
thread safe methods in this utility class can be used while any thread is 
using either debugPrint or verbosePrint.  Any thread desiring to use any of 
the other utilities will be blocked until all output is written.  

IMHO, the two reasons above both suggest that the synchronized keyword should 
be removed - any synchronization should be external - perhaps with the 
additional class level documentation that the methods themselves are thread-
safe and do not require explicit synchronization.  ","11/Sep/03 10:37;amamment;Created an attachment (id=8144)
Update to make debugPrint and verbosePrint thread safe
","11/Sep/03 10:38;amamment;Note that the patch attached just previouslyt does not, in fact, remove the 
synchronized keyword from debugPrint and verbosePrint.  I think it should be 
removed, but I realized I had forgotten to do it.  I can submit another patch 
with those removed if required.  ","11/Sep/03 14:50;janekdb@yahoo.co.uk;I agree with Arun's removal of the synchronized key on these two methods. As 
he correctly points out it will not, in general, prevent overlapping use of 
System.out.","20/Sep/03 18:33;scolebourne@joda.org;Changes made so synchronization is now the responsibility of the caller if 
required.

(I should note that one thread in a synchronized method does NOT block access 
to non synchronized methods from another thread)",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Calling CollectionUtils.cardinality with null obj argument leads to NPE,COLLECTIONS-4,12340376,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,sye@mail.ru,sye@mail.ru,20/Oct/02 03:27,15/Mar/08 21:35,07/Apr/19 20:38,15/Mar/08 21:35,Nightly Builds,,,,,,,,,,,,,,0,,,,"There is a bug in cardinality method, which shows, when obj parameter is null;
It leads to NullPointerException.

In order to reveal it, add line

assertEquals(0, CollectionUtils.cardinality(null, _b));

to testCardinality in TestCollectionUtils.

One variant of correct implementation is following:

public static int cardinality(Object obj, final Collection col) {
       int count = 0;
       Iterator it = col.iterator();
       if(null==obj){
           while(it.hasNext()){
               Object elt = it.next();
               if(null==elt){
                   count++;
               }
           }
       }else{
           while(it.hasNext()) {
               Object elt = it.next();
               if(obj.equals(elt)) {
                   count++;
               }
           }
       }
       return count;
   }","Operating System: other
Platform: Other",,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,13785.0,,,2002-11-02 03:55:41.0,,,false,,,,,,,,,,,,,,18994,,,Sat Nov 02 03:55:41 UTC 2002,,,,,,0|i0sjx3:,164704,,,,,,,,"02/Nov/02 03:55;rwaldhof@us.britannica.com;fixed, added unit test as well
thanks Serhiy",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
NPE: map.LRUMap.reuseMapping(LRUMap.java:272),COLLECTIONS-3,12341922,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Cannot Reproduce,,otis@apache.org,otis@apache.org,08/Dec/04 03:39,28/Feb/13 19:53,07/Apr/19 20:38,17/Jun/09 09:48,3.1,,,,,,,,Map,,,,,,2,,,,"I'm using Collections 3.1 and just found this NPE in my logs:

java.lang.NullPointerException
        at
org.apache.commons.collections.map.LRUMap.reuseMapping(LRUMap.java:272)
        at
org.apache.commons.collections.map.LRUMap.addMapping(LRUMap.java:243)
        at
org.apache.commons.collections.map.AbstractHashedMap.put(AbstractHashedMap.java:282)

I instantiated LRUMap like this:

  LRUMap map = new LRUMap(31);

And from there on, I use it like I'd use any Map, putting things into
it, and so on.  Maybe I'm not using LRUMap correctly?  My _guess_ is
that this occurs when the Map is full, but I am not certain.

I am wrapping the LRUMap in my own Maps as follows, but I think they're
not the culprit:

  LRUMap map = new LRUMap(31);
    _userSessions = new ExpiringMap(map,
       new TimerTTLReferenceHolder(1800000), // ttl=30min
       300000);                              // purge frequency=5min


The only similar thing I found is COM-1288, but it looks like that was fixed
before 3.1 release.

I understand the value of a self-contained unit test that demonstrates this bug,
but it happens only occassionally on my production system, never during
development, so I can't really come up with it :(

My guess is that this is a boundary case, as line 272 is:

 loop = loop.next;

So 'loop' is most likely null, and it's null because ... not sure, maybe that
hashIndex is wrong.","Operating System: Linux
Platform: PC",,,,,,,,,,,,,,,COLLECTIONS-330,,,12/Oct/05 05:40;scolebourne@joda.org;ASF.LICENSE.NOT.GRANTED--LRUMap.java;https://issues.apache.org/jira/secure/attachment/12333276/ASF.LICENSE.NOT.GRANTED--LRUMap.java,08/Oct/05 22:34;scolebourne@joda.org;ASF.LICENSE.NOT.GRANTED--SoakLRUMap.java;https://issues.apache.org/jira/secure/attachment/12333275/ASF.LICENSE.NOT.GRANTED--SoakLRUMap.java,08/Oct/05 22:32;scolebourne@joda.org;ASF.LICENSE.NOT.GRANTED--commons-collections-3.2-LRUMap-debug.jar;https://issues.apache.org/jira/secure/attachment/12333274/ASF.LICENSE.NOT.GRANTED--commons-collections-3.2-LRUMap-debug.jar,,,,,,,3.0,,,,,,,,,,,,,,,,32573.0,,,2005-02-04 09:28:55.0,,,false,,,,,,,,,,,,,,18995,,,Wed Jun 17 09:48:47 UTC 2009,,,,,,0|i0sjxb:,164705,,,,,,,,"04/Feb/05 09:28;scolebourne@joda.org;Just a thought, but could your keys be changing after you insert them into the
map? Hash keys need to be immutable (or not changed) after being added as a key
in a map.","02/Mar/05 01:11;kreiger;I have a customer reporting the same problem, and i'm using java.lang.Integer
for the keys, and java.lang.ref.SoftReference for the values.","02/Mar/05 01:20;kreiger;Sorry, wrong. I'm using array of SoftReference (SoftReference[]) for the values.","20/Mar/05 04:13;endo@sb.net;Hello I am reporting a similar problem which makes LRUMap useless.  I am using 
LRUMap as a synchronizedMap.  I can confirm that this problem only occurs when 
the LRUMap becomes full, but not right away.  The problem may or may not arise 
(there is no pattern).  I am using LRUMap in a web environment to cache some 
stuff - the cache size is 40000.  Once the problem starts the problem 
continues with each next put.

java.lang.NullPointerException 
org/apache/commons/collections/map/LRUMap.addMapping
(IILjava/lang/Object;Ljava/lang/Object;)V+0 (LRUMap.java:227) 
org/apache/commons/collections/map/AbstractHashedMap.put
(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;+0 
(AbstractHashedMap.java:269) 
java/util/Collections$SynchronizedMap.put(Ljava/lang/Object;Ljava/lang/Object;)
Ljava/lang/Object;+11 (Collections.java:1432) 
","22/Mar/05 09:54;scolebourne@joda.org;I can reproduce this by not synchronizing access to the LRUMap.

Thus there are now two possible causes of this:
- Mutable keys (map keys must not be changed)
- Not correctly synchronized (use Collections.synchronizedMap)

Please check your code to ensure that you are using the collections correctly.","02/Apr/05 03:05;michael_girard@msn.com;we are also seeing this issue when using Strings as keys into the LRUMap. We are
using the Collections.synchronizedMap() call to synchronize access to the map as
well.

It also appears to us that this occurs when the cache fills.","02/Apr/05 04:15;otis@apache.org;This happening when the cache fills up was also something that I think was
happening when I saw the error.  Oh, I see I mentioned that in the original bug
report. :)","17/Jul/05 09:06;scolebourne@joda.org;I've just spent another 3 hours looking at this without finding anything, yet
with four separate bug reports here I guess there must be a problem :-(

Can any of you assist by answering the following:

What methods on LRUMap are you calling?
eg. get(), put(), iterator(), ...

Are any of you able to put a debug version of the jar into the environment that
causes the problem? Or have a way to reproduce it?","17/Jul/05 11:38;otis@apache.org;I'm no longer using the LRUMap, but I was using only put and get.  I know Kevin
Burton (another Apache guy) is seeing the same problems...","08/Oct/05 22:32;scolebourne@joda.org;Created an attachment (id=16622)
jar file

Jar file with additional debugging statements.

If anybody is able to run this and report back the debug, we would be most
grateful.","08/Oct/05 22:34;scolebourne@joda.org;Created an attachment (id=16623)
java file

My attempt at a test class to soak the LRUMap as in production","09/Oct/05 06:05;mliberato@gmail.com;That really seems a synchronization issue on the client. I have done some tests
here and the problem only occurs when there are non-thread-safe access to the
map. Are there more references to this kind of error?","09/Oct/05 06:45;scolebourne@joda.org;(In reply to comment #12)
> That really seems a synchronization issue on the client. I have done some tests
> here and the problem only occurs when there are non-thread-safe access to the
> map. Are there more references to this kind of error?

All the info is here in Bugzilla. It is only LRUMap that has issues against it,
other (similarly designed) classes have no issues raised.
","09/Oct/05 12:37;otis@apache.org;I'm no longer using this LRUMap in the application where I was having problems
with it, so I can't help retest/debug it in production any more.","10/Oct/05 21:56;kreiger;I can verify that when i wrapped the LRUMap in Collections.synchronizedMap(),
the problem went away.","12/Oct/05 05:40;scolebourne@joda.org;Created an attachment (id=16665)
java file

Java source code for LRUMap with debugging","11/Nov/05 09:13;scolebourne@joda.org;Can anyone who remembers please comment and state which JDK version, JDK vendor
and operating system they were using.

Thanks!","11/Nov/05 14:34;otis@apache.org;I (the original reporter of this bug) was using JDK 1.5 (beta-something,
probably whatever was the latest available beta in December 2004 when I reported
this bug.
","22/Nov/05 00:25;jhecking@netgaroo.com;Sorry, didn't mean to close the bug!

Re. comment #17 - we're running into the same problem when using LRUMap without
Collections.synchronizedMap(). Here's the requested info about JRE and OS version:

$ java -version
java version ""1.4.2_07""
Java(TM) 2 Runtime Environment, Standard Edition (build 1.4.2_07-b05)
Java HotSpot(TM) Client VM (build 1.4.2_07-b05, mixed mode)

$ uname -a
Linux XXX 2.6.9-5.ELsmp #1 SMP Wed Jan 5 19:30:39 EST 2005 i686 i686 i386 GNU/Linux

The NPE occurs when calling LRUMap.put(). The key is immutable (String). We're
only using the put() and get() methods.","22/Nov/05 03:05;rdonkin@apache.org;Hi Jan

Thanks for the information.

Are you really running without synchronisation?

Is there any chance that mutliple threads are accessing the map?

Robert","22/Nov/05 03:29;jhecking@netgaroo.com;(In reply to comment #20)
> Are you really running without synchronisation?
Yes, before we hit this bug we were running without synchronization. Now we
wrapped the LRUMap in a Collections.synchronizedMap().

> Is there any chance that mutliple threads are accessing the map?
Yes, multiple threads are reading and writing the map.

Off course in this case it was stupid to not use synchronized access in the
first place as LRUMap does not explicitly state that it is threadsafe...","22/Nov/05 04:57;rdonkin@apache.org;Thanks for the information. I expect occasional null pointers when this map is
used by multiple threads without synchronization. I'll take a look at fixing the
javadocs. 

Have you had any problems since switching to use the synchronized version?

Robert","13/Apr/06 06:36;eric@pandora.com;I'm currently experiencing an identical problem to what Jan has already reported.

> uname -a
Linux <snip> 2.6.13.1-20050914 #2 SMP Wed Sep 14 13:54:47 PDT 2005 i686 GNU/Linux

> vmjava -version
java version ""1.4.1_07""
Java(TM) 2 Runtime Environment, Standard Edition (build 1.4.1_07-b02)
Java HotSpot(TM) Client VM (build 1.4.1_07-b02, mixed mode)

I'm running Jakarta Commons Collections 3.1.

Like Jan, the NPE occurs when calling LRUMap.put(). The key is immutable
(String), and we're only using the put() and get() methods. The offending LRUMap
is contructed using the LRUMap(int) constructor.

Once the NPE exception within LRUMap.put occurs, all subsequent calls to that
method also provoke a NPE.

We *are* decorating our LRUMap using Collections.synchronizedMap, and the
problem still occurs.","13/Apr/06 08:17;scolebourne@joda.org;(In reply to comment #23)
Are you able to use the debug jar file from comment #10 ?
It would be great if you could.

Also, can you confirm that all iterator access to the map is wrapped as follows:

synchronized {
  Iterator it = map.keySet().iterator();
  while (it.hasNext()) {
    ...
  }
}

ie. that there is a synchronized block around the whole of any iteration?","01/Jul/07 02:54;bayard;That should be:

synchronized(map) {

Playing with SoakLRUMap, not doing that gives a ConcurrentModificationException, which hasn't been reported so far. 

Mostly I get IllegalStateExceptions when playing with SoakLRUMap and not synchronizing the Map, however I did get one NPE still:

java.lang.NullPointerException
        at org.apache.commons.collections.map.LRUMap.moveToMRU(LRUMap.java:194)
        at org.apache.commons.collections.map.LRUMap.updateEntry(LRUMap.java:217)

Line is:

            entry.before.after = entry.after;

Which, looking at the code, implies that entry.before is null. Maybe another place to put a state check?

Maybe a state check would be worth it there too?",19/Mar/08 06:50;bayard;TODO: Add the two state checks. Close as Cannot Reproduce.,"02/Apr/08 06:04;bayard;svn ci -m ""Adding a state check as per COLLECTIONS-3. I got an NPE when running through tests without synchronization"" src

Sending        src/java/org/apache/commons/collections/map/LRUMap.java
Transmitting file data .
Committed revision 643755.",02/Apr/08 06:05;bayard;Everything points to this being synchronization issues.,"17/Jun/09 09:29;joehni;Reopened, added a unit test (currently not executed, marked with TODO) that reproduces the ConcurrentModificationException. Happens only if the remove is called on the iterator from the keySet. Works fine for the iterators from the entrySet and values. See improved unit test TestLRUMap.","17/Jun/09 09:48;joehni;Closed again as ""Cannot reproduce"". I will open a new issue for the ConcurrentModificationException. This issue's history with different reported problems is simply too vague.",,,,,,,,,,,,,,,,,
[collections] ExtendedProperties.save(...) does not escape special characters,COLLECTIONS-2,12340665,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,dwojtas@myrealbox.com,dwojtas@myrealbox.com,16/Apr/03 18:28,15/Mar/08 21:35,07/Apr/19 20:38,15/Mar/08 21:35,2.1,,,,,,,,,,,,,,0,,,,"If some value ends with '\', then after saving it, load will fail or will have 
incorrect values.
Try to store some property with value ending with '\', eg.

path1=e:\
path2=c:\docs

Look for java.util.Properties on escaping characters.","Operating System: All
Platform: PC",,,,,,,,,,,,,,,,,,19/Apr/03 03:42;mohankishore@yahoo.com;ASF.LICENSE.NOT.GRANTED--Patch.txt;https://issues.apache.org/jira/secure/attachment/12332234/ASF.LICENSE.NOT.GRANTED--Patch.txt,,,,,,,,,1.0,,,,,,,,,,,,,,,,19061.0,,,2003-04-19 03:42:55.0,,,false,,,,,,,,,,,,,,18996,,,Sun Aug 24 17:54:15 UTC 2003,,,,,,0|i0sjxj:,164706,,,,,,,,"19/Apr/03 03:42;mohankishore@yahoo.com;Created an attachment (id=5896)
Patch for escaping back-slash characters
","19/Apr/03 03:48;mohankishore@yahoo.com;Have added a patch for escaping the back-slash characters. When adding a 
Property, now it unescapes the value (i.e. replaces 2 successive back-slashes 
with 1). When saving the object to a file, it escapes the commas and back-
slashes by placing a back-slash before them.

Have also added test cases for the same.

Note, the patch might break backward compatibility, but the change required to 
the property files would be minimal - i.e. replace all backslashes in the 
values, with 2 backslashes. You (still) need a single backslash at the end of 
the line, in order to continue the value on the next line.","19/Apr/03 06:22;rwaldhoff@apache.org;I'd be happy to apply this patch, but I'm not really a user of
ExtendedProperties.  Anyone have any objections?  Going once, going twice...","20/Apr/03 00:46;kevin@henrikson.com;Wouldn't it be much safer to document the current behavior, and add escaping
methods for users to use?  This will maintain backward compatibality yet allow
users that don't escape their values ahead of time the needed functionality.","20/Apr/03 03:01;rwaldhoff@apache.org;If the incompatiablity is troubling, adding something like ""escapeAndSave()"" or
""saveSafely()"" sounds reasonable to me.  One could even deprecate the old save()
method, eventually remove it, and eventually (after than) reintroduce it as an
alias for ""saveSafely()"".","20/Apr/03 03:07;mohankishore@yahoo.com;Actually to think about it, the patch submitted should not break a majority of 
existing files. 

When loading, it would condense 2 successive back-slashes in the input file 
into 1, but will read in a single back-slash as is.

I would recommend changing the method save() - the other options seem more 
confusing, imho. This would also make the properties file outputted more 
compatible with the java.util.Properties file. Currently, the commas in the 
values are not escaped, i.e. if you save and load a value with an embeded 
comma, it will come back as an array/vector.","20/Apr/03 03:14;dwojtas@myrealbox.com;I think tha just modifying save() and documenting it is enough.
If there are 2 methods to store the same contents resulting in different 
output, there must be 2 methods to read it different way. 
That will lead to many problems is some data files are exchanged with other 
apps or even different modules. No one will now with what method it was stored.
It should be made compatible with java.util.Properties.","26/Apr/03 22:33;scolebourne@joda.org;OK, my view is that the file produced by the save() method must be readable by 
the load() method. As I read the bug report and the code, that is not currently 
the case. So we should fix it. Creating extra save methods is unecessary.",24/Aug/03 17:54;scolebourne@joda.org;Patch applied with minor changes. Thanks,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
[collections] Collections Javadoc warnings with JDK 1.4.2,COLLECTIONS-1,12341022,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,eric@tibco.com,eric@tibco.com,09/Oct/03 00:57,14/Jul/06 05:48,07/Apr/19 20:38,14/Jul/06 05:48,Nightly Builds,,,,,3.0,,,,,,,,,0,,,,"Numerous javadoc warnings when doing ""ant dist"" target under JDK 1.4.2.  Partial
patch to follow","Operating System: All
Platform: All",,,,,,,,,,,,,,,,,,10/Oct/03 20:48;eric@tibco.com;ASF.LICENSE.NOT.GRANTED--javadoc.patch;https://issues.apache.org/jira/secure/attachment/12332571/ASF.LICENSE.NOT.GRANTED--javadoc.patch,09/Oct/03 01:04;eric@tibco.com;ASF.LICENSE.NOT.GRANTED--javadoc.patch;https://issues.apache.org/jira/secure/attachment/12332570/ASF.LICENSE.NOT.GRANTED--javadoc.patch,13/Oct/03 23:00;eric@tibco.com;ASF.LICENSE.NOT.GRANTED--lastjavadocpatch.patch;https://issues.apache.org/jira/secure/attachment/12332573/ASF.LICENSE.NOT.GRANTED--lastjavadocpatch.patch,10/Oct/03 21:56;eric@tibco.com;ASF.LICENSE.NOT.GRANTED--test-javadoc.patch;https://issues.apache.org/jira/secure/attachment/12332572/ASF.LICENSE.NOT.GRANTED--test-javadoc.patch,,,,,,4.0,,,,,,,,,,,,,,,,23680.0,,,2003-10-10 04:03:44.0,,,false,,,,,,,,,,,,,,18997,,,Thu Jul 28 20:01:48 UTC 2005,,,,,,0|i0sjxr:,164707,,,,,,,,"09/Oct/03 01:04;eric@tibco.com;Created an attachment (id=8495)
Fix JDK 1.4.2 Javadoc errors for API classes.
","10/Oct/03 04:03;scolebourne@joda.org;Patch applied, thanks.
I made a few minor changes, so I hope that I didn't break anything again ;-)","10/Oct/03 20:47;eric@tibco.com;Thanks for applying (most of) my first patch!

I've got two patches to follow.  The first one notes the remaining issues with
the collection classes themselves, and the second will be for the test classes.","10/Oct/03 20:48;eric@tibco.com;Created an attachment (id=8522)
Additional Javadoc issues.
","10/Oct/03 20:56;eric@tibco.com;Comments about previous patch:

1) I changed CommonsLinkedList to ""public"", if only because it is extended by
NodeCachingLinkedList which is public. Via protected functions,
NodeCachingLinkedList references protected functions of it CommonsLinkedList. 
For consistency, either those functions on NodeCachingLinkedList should be
private, or CommonsLinkedList should be public.  In my ignorance of the details
and history, I thought more transparency was better, and opted for the ""public""
change.

2) In several files, I added an import, where the import serves only to block
warnings by javadoc, and is not needed by the code itself.  The alternative
would be to fully qualify all the references to StandardModificationHandler in
the comments, but I thought this change more concise.

Thanks for considering these additional changes.","10/Oct/03 21:56;eric@tibco.com;Created an attachment (id=8525)
Javadoc issues with test framework
","11/Oct/03 04:29;scolebourne@joda.org;Patches applied.

I can't make CommonsLinkedList public until it has a test case, so I have to 
take the javadoc issues instead.

I prefer the imports to not throw up 'unused import' in Eclipse, so I'm leaving 
the StandardModificationHandler in the javadoc even though its long. With the 
iterators I got around this by directly referencing the iterator in code.

Thanks","13/Oct/03 23:00;eric@tibco.com;Created an attachment (id=8557)
Last cleanups for StandardModificationHandler - no import change
","13/Oct/03 23:00;eric@tibco.com;Attached patch with last issues related to StandardModificationHandler.

Thanks for applying previous patches.","14/Oct/03 04:32;scolebourne@joda.org;Patch applied, thanks.",14/Oct/03 21:03;eric@tibco.com;Cool.,28/Jul/05 20:01;dennisl@apache.org;This issue has been fixed and commit. Shouldn't it be closed in bugzilla?,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
